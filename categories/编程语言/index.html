<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  
  <meta name="description" content="momoda">
  

  
  <meta name="keywords" content="momoda">
  
  
  
  
  
  
  
  
  
  <title>Category: 编程语言 | Just another blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="momoda">
<meta name="keywords" content="momoda">
<meta property="og:type" content="website">
<meta property="og:title" content="Just another blog">
<meta property="og:url" content="https://wnhby.github.io/categories/编程语言/index.html">
<meta property="og:site_name" content="Just another blog">
<meta property="og:description" content="momoda">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Just another blog">
<meta name="twitter:description" content="momoda">
  
    <link rel="alternative" href="/atom.xml" title="Just another blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  

  
  <!-- baidu webmaster push -->
  <script src="//push.zhanzhang.baidu.com/push.js"></script>
</head></html>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="Just another blog" rel="home">Just another blog</a>
      </h1>
      
        <h2 class="site-description">
          <a href="/" id="subtitle">momoda blog</a>
        </h2>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/atom.xml">RSS</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/sitemap.xml">Site map</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/more/share.html">Share</a></li>
                
                </ul>
            </div>
    </nav>
</header>

      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main">
  
    <article id="post-se-notes/Java基础/多线程" class="post-se-notes/Java基础/多线程 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/se-notes/Java基础/多线程/">多线程</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://wnhby.github.io/se-notes/Java基础/多线程/" data-id="cjsbez09u003cczs6cm8n0pk5" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <!-- TOC -->
<ul>
<li><a href="#java-多线程">Java 多线程</a><ul>
<li><a href="#创建任务和线程">创建任务和线程</a></li>
</ul>
</li>
<li><a href="#thread类">Thread类</a></li>
<li><a href="#线程池">线程池</a></li>
<li><a href="#线程同步">线程同步</a><ul>
<li><a href="#同步语句">同步语句</a></li>
</ul>
</li>
<li><a href="#利用加锁同步">利用加锁同步</a></li>
<li><a href="#volatile-关键字">Volatile 关键字</a><pre><code>- [使用场景](#使用场景)
</code></pre></li>
<li><a href="#线程间协作">线程间协作</a></li>
<li><a href="#避免死锁">避免死锁</a><pre><code>- [Ads](#ads)
</code></pre></li>
</ul>
<!-- /TOC -->
<h1 id="Java-多线程"><a href="#Java-多线程" class="headerlink" title="Java 多线程"></a>Java 多线程</h1><p>一个程序可能包含多个并发运行的任务，线程是指一个任务从头至尾的执行流。Java 可以在一个程序中并发地启动多个线程，这些线程可以在多处理器系统上同时运行。</p>
<h2 id="创建任务和线程"><a href="#创建任务和线程" class="headerlink" title="创建任务和线程"></a>创建任务和线程</h2><p>任务就是对象。为了创建任务，必须为任务定义一个实现了 Runnable 接口的类。Runnable 接口只包含了一个 run 方法，该方法告诉系统线程如何运行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskClass</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TaskClass</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">	    <span class="comment">// Tell system how to run custom thread</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行线程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TaskClass task = new TaskClass(); //根据任务类，创建任务</span><br><span class="line">Thread thread = new Thread(task); //创建任务的线程</span><br><span class="line">thread.start(); //启动线程</span><br></pre></td></tr></table></figure></p>
<h1 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h1><p>Thread 类包含为任务而创建的线程的构造方法，以及控制线程的方法。</p>
<ul>
<li>方法 yield()：可为其他线程临时让出 CPU 时间。</li>
<li>方法 sleep(long mills)：可以将线程设置为休眠以确保其他线程的执行，休眠时间为指定的毫秒数。也可能抛出必检异常，因此需要放到 try-catch 块中。</li>
<li>方法 join()：使一个线程等待另一个线程的结束。</li>
<li>Java 为每个线程都指定了一个优先级（1~10），可用 setPriority 方法设置优先级，用 getPriority 方法获取优先级。JVM 总是选择当前优先级最高的可运行线程，较低优先级的线程只有在没有比它更高优先级的线程运行时才能运行。</li>
</ul>
<blockquote>
<p>注：由于 Thread 类也实现了 Runnable 接口，所以可以定义一个 Thread 的扩展类，在里面实现 run 方法来实现线程。但<strong>不推荐</strong>使用这种方式，因为把任务和运行任务的机制混在了一起。把任务从线程中分离出来是比较好的选择。</p>
</blockquote>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>对于大量的任务而言，为每一个任务开始一个新线程是不够高效的。线程池是管理并发执行任务个数的理想办法。Java 提供 Executor 接口来执行线程池里的任务，提供 ExecutorService 接口来管理和控制任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">public class ExecutorDemo&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		// 创建一个固定线程数的线程池</span><br><span class="line">		ExecutorService executor = Executors.newFixedThreadPool(3);</span><br><span class="line">		</span><br><span class="line">		// 或者按需创建线程池</span><br><span class="line">		// ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">		</span><br><span class="line">		// 执行任务（PrintChar实现了Runnable接口）</span><br><span class="line">		executor.execute(new PrintChar(&apos;a&apos;,100));</span><br><span class="line">		executor.execute(new PrintChar(&apos;b&apos;,100));</span><br><span class="line">		executor.execute(new PrintChar(&apos;c&apos;,100));</span><br><span class="line">		// 关闭执行器，之后便不能接受新的任务</span><br><span class="line">		executor.shutdown();</span><br><span class="line">		// 判断所有任务是否已结束，返回boolean型</span><br><span class="line">		executor.isTerminated();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><p>如果一个共享资源被多个线程同时访问，可能会遭到破坏。当任务1和任务2以一种会引起冲突的方式访问一个公共资源时，该问题称为<strong>竞争状态</strong>。如果一个类的对象在多线程程序中没有导致竞争状态，则称这样的类是<strong>线程安全的</strong>。</p>
<p>为了避免竞争状态，应该防止多个线程同时进入程序的某一特定部分，这部分称为<strong>临界区</strong>。通过使用关键字 <strong>synchronized</strong> 来同步方法，以便一次只有一个线程可以访问该方法。如：<code>public synchronized void deposit(double amount)</code>。</p>
<p>一个同步方法在执行之前需要加锁；调用一个对象的同步实例方法要求给该对象加锁；调用一个类的同步静态方法要求对该类加锁。如果一个线程调用一个对象上的同步实例方法（静态方法），首先给该对象（类）加锁，然后执行该方法，最后解锁。在解锁之前，另一个调用该对象（类）中该方法的线程将会被阻塞。</p>
<h2 id="同步语句"><a href="#同步语句" class="headerlink" title="同步语句"></a>同步语句</h2><p>当执行方法中某一个代码块时，同步语句不仅可用于对 this 对象加锁，而且可用于对任何对象加锁。这个代码块称为“同步块”。由于同步语句允许设置同步方法中的部分代码而不必是整个方法，从而大大增强了程序的并发能力。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(expr)&#123;</span><br><span class="line">	statements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表达式 expr 必须求出对象的引用。若对象已经被另一个线程锁定，则在解锁之前，该线程将被阻塞。当获准对一个对象加锁时，该线程执行同步块中语句，然后解除给对象加的锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*  任何同步实例方法可转换为同步语句。</span><br><span class="line">    以下两个实例方法是等价的。 */</span><br><span class="line">public synchronized void xMethod()&#123;</span><br><span class="line">	// method body</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void xMethod()&#123;</span><br><span class="line">	synchronized(this)&#123;</span><br><span class="line">		// method body</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="利用加锁同步"><a href="#利用加锁同步" class="headerlink" title="利用加锁同步"></a>利用加锁同步</h1><p>同步的实例方法在执行方法之前都隐式地加锁，而 Java 也可以显式地加锁。</p>
<p>一个锁是一个 Lock 接口的实例，它定义了加锁和释放锁的方法。<strong>ReentrantLock</strong> 类是为创建互斥锁的 Lock 的具体实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.*</span><br><span class="line"></span><br><span class="line">public class Account&#123;</span><br><span class="line">    	private static Lock lock = new ReentrantLock();</span><br><span class="line">    	private int balance = 0;</span><br><span class="line">    	</span><br><span class="line">    	public int getBalancs()&#123;</span><br><span class="line">    		return this.balance;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	public void deposit(int amount)&#123;</span><br><span class="line">    		lock.lock(); // 加锁</span><br><span class="line">    		try&#123;</span><br><span class="line">    			int newBalance = balance + amount;</span><br><span class="line">    			Thread.sleep(5);</span><br><span class="line">    			balance = newBalance;</span><br><span class="line">    		&#125;</span><br><span class="line">    		catch(InterruptedException ex)&#123;   			</span><br><span class="line">    		&#125;</span><br><span class="line">    		finally&#123;</span><br><span class="line">    			lock.unlock(); // 解锁</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="Volatile-关键字"><a href="#Volatile-关键字" class="headerlink" title="Volatile 关键字"></a>Volatile 关键字</h1><p>Java 提供了一种稍弱的同步机制，即 volatile 变量，用来确保将变量的更新操作立刻对其他线程可见。当把变量声明为 volatile 类型后，编译器与 JVM 都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序，也不会使该变量被线程缓存。因此在读取 volatile 类型的变量时总会返回最新写入的值。volatile 修饰的变量<strong>不允许被线程缓存和重排序</strong>（不被缓存即直接修改内存），因此对其他线程实现了可见性。</p>
<blockquote>
<p><strong>指令重排序</strong>是编译器或运行时环境为了优化程序性能而采取的对指令进行重新排序执行的一种手段，因此多线程下指令执行的顺序可能是无法预测的。<strong>指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性</strong>。</p>
</blockquote>
<p>在访问 volatile 变量时不会执行加锁操作，也就不会使执行线程阻塞。因此 <strong>volatile 变量是一种比 sychronized 关键字更轻量级的同步机制</strong>。</p>
<p><img src="http://images2015.cnblogs.com/blog/731716/201607/731716-20160708224602686-2141387366.png" alt="enter image description here"></p>
<blockquote>
<p>读写非 volatile 变量时，每个线程先从内存拷贝变量到 CPU 缓存中。如果计算机有多个 CPU ，每个线程可能在不同的 CPU 上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。</p>
</blockquote>
<blockquote>
<p>注意：volatile 只能让其所修饰的变量具有可见性（即更新后的操作会立即对其他线程可见），但不能保证具有原子性，因此也会有线程安全的问题。</p>
</blockquote>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>synchronized 关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而 volatile 关键字在某些情况下性能要优于 synchronized ，但要注意 volatile 关键字是无法替代 synchronized 关键字的，因为 volatile 关键字无法保证操作的原子性。</p>
<p>通常来说，使用 volatile 必须具备以下条件：</p>
<ol>
<li>对变量的写操作不依赖于当前值</li>
<li>该变量没有包含在具有其他变量的不变式中</li>
</ol>
<p>这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p>
<p><a href="http://blog.csdn.net/libing13820393394/article/details/48582999" target="_blank" rel="noopener">volatile 详解</a></p>
<h1 id="线程间协作"><a href="#线程间协作" class="headerlink" title="线程间协作"></a>线程间协作</h1><p>通过保证在临界区上多个线程的相互排斥，线程同步完全可以避免竞争状态的发生，但是有时还需要线程之间的相互协作。Java 中使用<strong>条件</strong>来便于线程间通信，一个线程可以指定在某种条件下该做什么。</p>
<p><strong>条件</strong>是通过调用 Lock 对象的 newCondition() 方法而创建的对象，一旦创建了条件，就可以使用 await()、signal()、signalAll() 方法来实现线程间的互相通信：</p>
<ul>
<li>await()：让当前线程处于等待状态，直到被唤醒</li>
<li>signal()：唤醒一个等待的线程</li>
<li>signalAll()：唤醒所有等待的线程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.*;</span><br><span class="line">import java.util.concurrent.locks.*;</span><br><span class="line"></span><br><span class="line">public class TestLockCondition &#123;</span><br><span class="line"></span><br><span class="line">	private static Account account = new Account();</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		System.out.println(&quot;Thread 1\t\tThread 2\t\tBalance&quot;);</span><br><span class="line">		</span><br><span class="line">		ExecutorService executor = Executors.newFixedThreadPool(2);</span><br><span class="line">		executor.execute(new DepositTask());</span><br><span class="line">		executor.execute(new SubstactTask());</span><br><span class="line">		executor.shutdown();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static class DepositTask implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public void run() &#123;</span><br><span class="line">			try&#123;</span><br><span class="line">				while(true)&#123;</span><br><span class="line">					account.deposit((int)(Math.random() * 10) + 2);</span><br><span class="line">					Thread.sleep(2000);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			catch(Exception e)&#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static class SubstactTask implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public void run() &#123;</span><br><span class="line">			while(true)&#123;</span><br><span class="line">				account.substract((int)(Math.random() * 10)+1);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static class Account&#123;</span><br><span class="line">		</span><br><span class="line">		private int balance = 0;</span><br><span class="line">		private Lock lock = new ReentrantLock();</span><br><span class="line">		private Condition condition = lock.newCondition();</span><br><span class="line">		</span><br><span class="line">		public int getBalance()&#123;</span><br><span class="line">			return balance;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		public void substract(int amount)&#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			try&#123;</span><br><span class="line">				while(amount &gt; balance)&#123;</span><br><span class="line">					System.out.println(&quot;\t\t\twait for a deposit&quot;);</span><br><span class="line">					condition.await();</span><br><span class="line">				&#125;</span><br><span class="line">				balance -= amount;</span><br><span class="line">				System.out.println(&quot;\t\t\tSubstract &quot; + amount +&quot;\t\t&quot; + getBalance());</span><br><span class="line">			&#125;</span><br><span class="line">			catch(Exception e)&#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			finally&#123;</span><br><span class="line">				lock.unlock();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		public void deposit(int amount)&#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			try&#123;</span><br><span class="line">				balance += amount;</span><br><span class="line">				System.out.println(&quot;Deposit &quot; + amount +&quot;\t\t\t\t\t&quot; + getBalance());</span><br><span class="line">				condition.signalAll();</span><br><span class="line">			&#125;</span><br><span class="line">			finally&#123;</span><br><span class="line">				lock.unlock();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一旦线程调用条件上的 await()，线程就进入等待状态，等待恢复的信号。如果忘记调用 signal()、signalAll() ，那么线程将永久等待下去。</p>
</blockquote>
<blockquote>
<p>条件由 Lock 对象所创建，为了调用 await()、signal()、signalAll() 等方法，必须首先获取该条件对应的锁。如果没有获取锁就调用这些方法就会抛出异常。</p>
</blockquote>
<h1 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h1><p>有时两个或多个线程需要在几个共享对象上获取锁，可能会导致死锁，即：每个线程已经锁定一个对象，而且正在等待锁定另一个对象。</p>
<p>使用<strong>资源排序</strong>可以轻易地避免死锁的发生。该技术是给每一个需要锁的对象指定一个顺序，确保每个线程都按照这个顺序来获得锁。</p>
<hr>
<ul>
<li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p>
</li>
<li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p>
</li>
</ul>
<h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p>
<blockquote>
<p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p>
</blockquote>
<blockquote>
<p>体育&amp;户外用品推荐</p>
</blockquote>
<div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/se-notes/Java基础/多线程/../../../more/ads/amazon.gif" width="100%"></a> </div>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/se-notes/Java基础/多线程/">
    <time datetime="2019-01-03T13:49:30.000Z" class="entry-date">
        1月 3 2019
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/编程语言/">编程语言</a>, <a class="article-category-link" href="/categories/编程语言/java/">java</a>
  </div>

    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java基础/">java基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java语法/">java语法</a></li></ul>

    </footer>
</article>






  
    <article id="post-se-notes/Java基础/JVM基础" class="post-se-notes/Java基础/JVM基础 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/se-notes/Java基础/JVM基础/">JVM基础</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://wnhby.github.io/se-notes/Java基础/JVM基础/" data-id="cjsbez09b002uczs6s7th9meh" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <!-- TOC -->
<ul>
<li><a href="#jvm基础">JVM基础</a><ul>
<li><a href="#类加载器classloader">类加载器(classloader)</a><ul>
<li><a href="#双亲委托机制">双亲委托机制</a></li>
</ul>
</li>
<li><a href="#执行引擎execution-engine">执行引擎(execution engine)</a></li>
<li><a href="#运行时数据区域jvm-runtime-area">运行时数据区域(JVM Runtime Area)</a></li>
</ul>
</li>
<li><a href="#gc">GC</a><ul>
<li><a href="#找出需要回收的对象">找出需要回收的对象</a></li>
<li><a href="#垃圾回收算法">垃圾回收算法</a><ul>
<li><a href="#标记-清除算法">标记-清除算法</a></li>
<li><a href="#标记-整理算法">标记-整理算法</a></li>
<li><a href="#复制算法">复制算法</a></li>
<li><a href="#分代收集算法结合以上三种算法">分代收集算法（结合以上三种算法）</a></li>
</ul>
</li>
<li><a href="#heap-的组成">heap 的组成</a></li>
<li><a href="#\对象引用类型">*对象引用类型</a><ul>
<li><a href="#ads">Ads</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h1 id="JVM基础"><a href="#JVM基础" class="headerlink" title="JVM基础"></a>JVM基础</h1><p> Java 虚拟机（Java virtual machine，JVM）是运行 Java 程序必不可少的机制。JVM 实现了 Java 最重要的特征：平台无关性。</p>
<p>原理：编译后的 Java 程序指令并不直接在硬件系统的 CPU 上执行，而是由 JVM 执行。JVM 屏蔽了与具体平台相关的信息，使 Java 语言编译程序只需要生成在 JVM 上运行的目标字节码（.class），就可以在多种平台上不加修改地运行。Java 虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行，由此实现平台无关性。</p>
<p><img src="https://segmentfault.com/img/bVkZat" alt="JVM模型"></p>
<p>JVM = 类加载器(classloader) + 执行引擎(execution engine) + 运行时数据区(runtime data area)</p>
<h2 id="类加载器-classloader"><a href="#类加载器-classloader" class="headerlink" title="类加载器(classloader)"></a>类加载器(classloader)</h2><p>类加载器用于装载 .class 文件到 JVM 中，有两种装载 class 的方式 ：</p>
<ul>
<li>隐式：运行过程中，碰到 new 方式生成对象时，隐式调用 classLoader 到 JVM</li>
<li>显式：通过 Class.forname() 动态加载</li>
</ul>
<h3 id="双亲委托机制"><a href="#双亲委托机制" class="headerlink" title="双亲委托机制"></a>双亲委托机制</h3><p>类的加载过程采用<strong>双亲委托机制</strong>，这种机制能更好的保证 Java 平台的安全。</p>
<p>该模型要求除了顶层的 Bootstrap class loader 启动类加载器外，其余的类加载器都应当有自己的父类加载器。子类加载器和父类加载器不是以继承（Inheritance）的关系来实现，而是通过组合（Composition）关系来复用父加载器的代码。每个类加载器都有自己的命名空间。</p>
<p>双亲委托机制的工作过程如下：</p>
<ol>
<li>当前 classLoader 首先从自己已经加载的类中查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。（每个类加载器都有自己的加载缓存，当一个类被加载了以后就会放入缓存，<br>等下次加载的时候就可以直接返回）</li>
<li>当前 classLoader 的缓存中没有找到被加载的类的时候，委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到 bootstrap ClassLoader 。（当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回）</li>
</ol>
<p>类加载器 classloader 是具有层次结构的，也就是父子关系。其中 Bootstrap 是所有类加载器的父亲。</p>
<p><img src="https://segmentfault.com/img/bVk0W2" alt="类加载器层次结构"></p>
<p>使用双亲委托机制的目的在于：</p>
<ol>
<li>安全性考虑：为了安全性，避免用户自己编写的类动态替换 Java 的一些核心类，比如 String。</li>
<li>避免重复加载：JVM 中区分不同类，不仅仅是根据类名。相同的 class 文件被不同的 ClassLoader 加载就是不同的两个类，如果相互转型的话会抛 java.lang.ClassCaseException。</li>
</ol>
<h2 id="执行引擎-execution-engine"><a href="#执行引擎-execution-engine" class="headerlink" title="执行引擎(execution engine)"></a>执行引擎(execution engine)</h2><p>执行引擎用于执行字节码或者本地方法。</p>
<h2 id="运行时数据区域-JVM-Runtime-Area"><a href="#运行时数据区域-JVM-Runtime-Area" class="headerlink" title="运行时数据区域(JVM Runtime Area)"></a>运行时数据区域(JVM Runtime Area)</h2><p>JVM 运行时数据区 (JVM Runtime Area) 是 JVM 在运行期间，其对 JVM 内存空间的划分和分配。JVM 在运行时将数据划分为了多个区域来存储。</p>
<p>程序员写的 Java 程序都被加载到运行时数据区域中，按不同类别存放在堆（Heap）、方法区（Method Area）、虚拟机栈（VM Stack）、程序计数器（PC）中。</p>
<p><img src="http://img.blog.csdn.net/20140218172737265?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2hhb2ZhbndlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="Java内存结构"></p>
<ul>
<li><p><strong>程序计数器</strong>：线程私有。当前线程所执行的字节码的指令计数器，存储每个线程下一步将执行的 JVM 指令。</p>
</li>
<li><p><strong>JVM栈</strong>：线程私有。与线程同时创建，生命周期与线程相同。每个方法被执行的时候都会同时创建一个<strong>栈帧</strong>（Stack Frame）用于存储局部变量、操作数栈等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
</li>
</ul>
<p><img src="https://segmentfault.com/img/bVmxl8" alt="JVM栈"></p>
<ul>
<li><p><strong>Native 方法栈</strong>：线程私有。类似于 JVM 栈，但虚拟机栈用于为虚拟机执行 java 方法，而本地方法栈则用于为虚拟机执行 native 方法。（native 方法是原生函数，是用 C/C++ 语言实现的，并且被编译成了 DLL，由 java 去调用）</p>
</li>
<li><p><strong>Java 堆</strong>：被所有线程共享的存储区域，在虚拟机启动时创建。它是 JVM 用于存储对象实例和数组的区域，Java 中所有通过 new 创建的对象的内存都在此分配。（这些对象被 GC 自动管理，无需也无法显式被销毁）</p>
<ul>
<li>内存分配方式：<strong>指针碰撞</strong>（用一个指针指向内存已用区和空闲区的分界点）和<strong>空闲列表</strong>（用一个列表记录哪些内存块可用）。</li>
<li>指针碰撞的分配方式明显要优于空闲列表的方式，但是使用哪种方式取决于堆内存是否规整，而堆内存是否规整则由使用的垃圾收集算法决定。</li>
<li>堆在 JVM 是所有线程共享的，因此在其上进行对象内存的分配均需要进行加锁，这也是 new 开销比较大的原因。</li>
<li>鉴于上面的原因，Sun Hotspot JVM 为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间，这块空间又称为 TLAB。</li>
</ul>
</li>
<li><p><strong>方法区</strong>：被所有线程共享的内存区域，在虚拟机启动时创建，它用于存储已被虚拟机加载的类信息、常量、静态变量等数据。<strong>JVM 用持久代（Permanet Generation）来存放方法区</strong>。</p>
<ul>
<li>运行时常量池：方法区的一部分，存放的为类中固定的常量信息、方法和域的引用信息。</li>
</ul>
</li>
</ul>
<h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><p>垃圾回收机制是由垃圾收集器 Garbage Collection（GC）来实现的，GC 是后台的守护进程。它是一个低优先级进程，但是可以根据内存的使用情况动态的调整它的优先级。因此，它在内存可用量低到一定限度时才会自动运行，从而实现对内存的回收。这就是垃圾回收的时间不确定的原因。</p>
<p>程序运行期间，所有对象实例存储在运行时数据区域的 heap 中，当一个对象不再被引用（使用），它就需要被收回。在 GC 过程中，这些不再被使用的对象从 heap 中收回，这样就会有内存空间被循环利用。</p>
<p>由于 GC 要消耗一些资源和时间，Java 在对对象的生命周期特征（eden or survivor）进行分析之后，采用了分代的方式进行对象的收集，以缩短 GC 对应用造成的暂停。</p>
<p>在垃圾回收器回收内存之前，还需要一些清理工作。<br>因为 GC 只能回收通过 new 申请的内存（在堆上），但是堆上的内存并不完全是通过 new 申请分配的。还有一些本地方法（一般是调用的 C 方法）。这部分特殊内存如果不手动释放，就会导致内存泄露，而 GC 是无法回收这部分内存的。<br>所以需要在 finalize 中用本地方法(native method)如 free 操作等，再使用 gc 方法。显式的 GC 方法是 system.gc() 。</p>
<h2 id="找出需要回收的对象"><a href="#找出需要回收的对象" class="headerlink" title="找出需要回收的对象"></a>找出需要回收的对象</h2><ul>
<li>引用计数法：给对象添加一个引用计数器，计数器的值代表着这个对象被引用的次数，当计数器的值为0的时候，就代表没有引用指向这个对象，所以就可以对它进行回收。但无法解决对象循环引用的问题。（即多个对象互相循环引用，但没有其他对象持有这些对象的引用，从而是一个孤立的系统）</li>
<li>可达性分析：从一些顶点开始，对有向图中的每个顶点进行可达性分析，就可以把不可达的对象找出来。这些起始对象被称为 GC Roots。可以作为 GC Roots 的对象有：栈区中引用的对象、 方法区中静态属性或常量引用的对象。</li>
</ul>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>找到需要回收的对象后，即可进行回收。JVM 中的 GC 是”自适应”的垃圾回收器，它会根据不同的环境和需要选择不同的处理方式。</p>
<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>通过可达性分析算法找到可以回收的对象后，对这些对象进行标记，代表它可以被回收。标记完成之后就统一回收所有被标记的对象。但是这种方式会产生大量的内存碎片，导致可用内存不规整，于是分配新的内存时就需要采用空闲列表的方法。如果没有找到足够大的空间，那么就要提前触发下一次垃圾收集。</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>标记的过程和标记-清除算法一样，但是标记完成之后，让所有存活的对象都向堆内存的一端移动，最后直接清除掉边界以外的内存。这样对内存进行回收之后，内存是规整的，于是可以使用指针碰撞的方式分配新的内存。</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>标记-清除算法和标记-整理算法都使用先标记的方式，但当对象数量很多时，这种算法的效率并不高。</p>
<p>复制算法将可用内存分成两个部分，每次只使用其中的一部分，当其中一块用完时，就将仍然存活的对象复制到另外一块上，再把原来的那一块内存清理掉。这样回收的结果同样能得到规整的剩余空间，但是会浪费一部分内存。</p>
<p>可将新生代划分为三个部分，分别为Eden、Survivor from、Survivor to，大小比例为8：1：1。每次只使用 Eden 和其中的一块 Survivor，回收时将存活的对象复制到另一块 Survivor 中，这样就只有10%的内存被浪费，但是如果存活的对象总大小超过了 Survivor 的大小，那么就把多出的对象放入老年代中。</p>
<h3 id="分代收集算法（结合以上三种算法）"><a href="#分代收集算法（结合以上三种算法）" class="headerlink" title="分代收集算法（结合以上三种算法）"></a>分代收集算法（结合以上三种算法）</h3><p>把 Java堆分成新生代和老年代，新生代使用复制算法，老年代使用标记-清理或标记-整理算法。这样可以根据各个代自己的特点，选用合适的收集算法，提高内存收集的效率。在新生代中长期存活的对象会逐渐向老年代过渡，新生代中的对象每经历一次 GC，年龄就增加一岁，当年龄超过一定值时，就会被移动到旧生代。</p>
<h2 id="heap-的组成"><a href="#heap-的组成" class="headerlink" title="heap 的组成"></a>heap 的组成</h2><p>由于 GC 需要消耗一些资源和时间的，Java 在对对象的生命周期特征进行分析后，采用了分代的方式来进行对象的收集，即按照新生代、旧生代的方式来对对象进行收集，以尽可能的缩短 GC 对应用造成的暂停。</p>
<p>heap 的组成有三区域/世代：(可以理解随着时间，对象实例不断变换 heap 中的等级)</p>
<ul>
<li>新生代（Young Generation）<ul>
<li>Eden Space：任何新进入运行时数据区域的实例都会存放在此</li>
<li>S0 Suvivor Space：存在时间较长，经过垃圾回收没有被清除的实例，就从Eden 搬到了S0</li>
<li>S1 Survivor Space：存在时间更长的实例，就从S0 搬到了S1</li>
</ul>
</li>
<li>旧生代（Old Generation/tenured）：存在时间更长的对象，多次 GC 没被清除，就从 S1 搬到了 tenured</li>
<li>持久代：存放运行时数据区的方法区</li>
</ul>
<p><img src="https://segmentfault.com/img/bVkZav" alt="分区"></p>
<p>Java 对新生代和旧生代使用不同的 GC 算法。新生代做“复制收集”，旧生代做“标记压缩收集”。</p>
<blockquote>
<p>PS：搬运工作都由 GC 完成。GC 负责在 heap 中搬运实例，以及收回存储空间。</p>
</blockquote>
<h2 id="对象引用类型"><a href="#对象引用类型" class="headerlink" title="*对象引用类型"></a>*对象引用类型</h2><p>JVM 中将对象的引用分为了四种类型，不同的对象引用类型会造成 GC 采用不同的方法进行回收： </p>
<ol>
<li>强引用：默认情况下，对象采用的均为强引用。（GC 不会回收）</li>
<li>软引用：软引用是 Java 中提供的一种比较适合于缓存场景的应用。（只有在内存不够用的情况下才会被GC）</li>
<li>弱引用：在GC时一定会被GC回收 </li>
<li>虚引用：在GC时一定会被GC回</li>
</ol>
<hr>
<ul>
<li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p>
</li>
<li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p>
</li>
</ul>
<h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p>
<blockquote>
<p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p>
</blockquote>
<blockquote>
<p>体育&amp;户外用品推荐</p>
</blockquote>
<p><div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/se-notes/Java基础/JVM基础/../../../more/ads/amazon.gif" width="100%"></a> </div>收</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/se-notes/Java基础/JVM基础/">
    <time datetime="2019-01-03T13:49:30.000Z" class="entry-date">
        1月 3 2019
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/编程语言/">编程语言</a>, <a class="article-category-link" href="/categories/编程语言/java/">java</a>
  </div>

    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java基础/">java基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java语法/">java语法</a></li></ul>

    </footer>
</article>






  
    <article id="post-se-notes/Java基础/Java基础知识" class="post-se-notes/Java基础/Java基础知识 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/se-notes/Java基础/Java基础知识/">Java基础知识</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://wnhby.github.io/se-notes/Java基础/Java基础知识/" data-id="cjsbez09j0030czs6msr6r69q" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <!-- TOC -->
<ul>
<li><a href="#java-基础">Java 基础</a><ul>
<li><a href="#面向对象的特征有哪些方面">面向对象的特征有哪些方面？</a></li>
<li><a href="#访问修饰符publicprivateprotected以及不写默认时的区别">访问修饰符public,private,protected,以及不写（默认）时的区别？</a></li>
<li><a href="#string-是最基本的数据类型吗">String 是最基本的数据类型吗？</a></li>
<li><a href="#float-f34是否正确">float f=3.4;是否正确？</a></li>
<li><a href="#short-s1--1-s1--s1--1有错吗-short-s1--1-s1--1有错吗">short s1 = 1; s1 = s1 + 1;有错吗? short s1 = 1; s1 += 1;有错吗？</a></li>
<li><a href="#int和integer有什么区别">int和Integer有什么区别？</a></li>
<li><a href="#解释内存中的栈stack堆heap和方法区method-area的用法">解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法</a></li>
<li><a href="#mathround115-等于多少mathround-115等于多少">Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？</a></li>
<li><a href="#switch-是否能作用在-byte-上是否能作用在-long-上是否能作用在-string-上">switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上？</a></li>
<li><a href="#用最有效率的方法计算2乘以8">用最有效率的方法计算2乘以8？</a></li>
<li><a href="#构造器constructor是否可被重写override">构造器（constructor）是否可被重写（override）？</a></li>
<li><a href="#两个对象值相同xequalsy--true但却可有不同的hash-code这句话对不对">两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？</a></li>
<li><a href="#string-和-stringbuilderstringbuffer-的区别">String 和 StringBuilder、StringBuffer 的区别？</a></li>
<li><a href="#是否可以继承string类">是否可以继承String类？</a></li>
<li><a href="#重载overload和重写override的区别重载的方法能否根据返回类型进行区分">重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</a></li>
<li><a href="#char-型变量中能不能存贮一个中文汉字">char 型变量中能不能存贮一个中文汉字？</a></li>
<li><a href="#抽象类abstract-class和接口interface有什么异同">抽象类（abstract class）和接口（interface）有什么异同？</a></li>
<li><a href="#-静态嵌套类static-nested-class和内部类inner-class的不同">* 静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？</a></li>
<li><a href="#java-中会存在内存泄漏吗请简单描述">Java 中会存在内存泄漏吗，请简单描述。</a></li>
<li><a href="#-抽象的abstract方法是否可同时是静态的static是否可同时是本地方法native是否可同时被-synchronized-修饰">* 抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被 synchronized 修饰？</a></li>
<li><a href="#-如何实现对象克隆">* 如何实现对象克隆？</a></li>
<li><a href="#gc是什么为什么要有gc">GC是什么？为什么要有GC？</a></li>
<li><a href="#string-s--new-stringxyz创建了几个字符串对象">String s = new String(“xyz”);创建了几个字符串对象？</a></li>
<li><a href="#接口是否可继承extends接口抽象类是否可实现implements接口抽象类是否可继承具体类concrete-class">接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？</a></li>
<li><a href="#一个java源文件中是否可以包含多个类不是内部类有什么限制">一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？</a></li>
<li><a href="#anonymous-inner-class匿名内部类是否可以继承其它类是否可以实现接口">Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？</a></li>
<li><a href="#-内部类可以引用它的包含类外部类的成员吗有没有什么限制">* 内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？</a></li>
<li><a href="#java-中的-final-关键字有哪些用法">Java 中的 final 关键字有哪些用法？</a></li>
<li><a href="#-指出下面程序的运行结果">* 指出下面程序的运行结果</a></li>
<li><a href="#数据类型之间的转换">数据类型之间的转换</a></li>
<li><a href="#error和exception有什么区别">Error和Exception有什么区别？</a></li>
<li><a href="#try里有一个return语句那么紧跟在这个try后的finally里的代码会不会被执行什么时候被执行在return前还是后">try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后?</a></li>
<li><a href="#java语言如何进行异常处理关键字throwsthrowtrycatchfinally-分别如何使用">Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally 分别如何使用？</a></li>
<li><a href="#运行时异常与受检必检异常有何异同">运行时异常与受检（必检）异常有何异同？</a></li>
<li><a href="#阐述finalfinallyfinalize的区别">阐述final、finally、finalize的区别</a></li>
<li><a href="#listsetmap是否继承自collection接口">List、Set、Map是否继承自Collection接口？</a></li>
<li><a href="#阐述-arraylistvectorlinkedlist-的存储性能和特性">阐述 ArrayList、Vector、LinkedList 的存储性能和特性</a></li>
<li><a href="#collection-和-collections-的区别">Collection 和 Collections 的区别？</a></li>
<li><a href="#listmapset-三个接口存取元素时各有什么特点">List、Map、Set 三个接口存取元素时，各有什么特点？</a></li>
<li><a href="#treemap-和-treeset-在排序时如何比较元素collections工具类中的sort方法如何比较元素">TreeMap 和 TreeSet 在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？</a></li>
<li><a href="#thread类的sleep方法和对象的wait方法都可以让线程暂停执行它们有什么区别">Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?</a></li>
<li><a href="#线程的sleep方法和yield方法有什么区别">线程的sleep()方法和yield()方法有什么区别？</a></li>
<li><a href="#当一个线程进入一个对象的synchronized方法a之后其它线程是否可进入此对象的synchronized方法b">当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？</a></li>
<li><a href="#请说出与线程同步以及线程调度相关的方法">请说出与线程同步以及线程调度相关的方法。</a></li>
<li><a href="#编写多线程程序有几种实现方式">编写多线程程序有几种实现方式？</a></li>
<li><a href="#举例说明同步和异步">举例说明同步和异步</a></li>
<li><a href="#什么是线程池thread-pool">什么是线程池（thread pool）？</a></li>
<li><a href="#线程的基本状态以及状态之间的关系">线程的基本状态以及状态之间的关系？</a></li>
<li><a href="#java中如何实现序列化有什么意义">Java中如何实现序列化，有什么意义？</a></li>
<li><a href="#interge的线程安全容器是">Interge的线程安全容器是？</a></li>
<li><a href="#线程安全的集合对象">线程安全的集合对象</a></li>
<li><a href="#托管代码与非托管代码的区别">托管代码与非托管代码的区别</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h1 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h1><h2 id="面向对象的特征有哪些方面？"><a href="#面向对象的特征有哪些方面？" class="headerlink" title="面向对象的特征有哪些方面？"></a>面向对象的特征有哪些方面？</h2><ul>
<li>抽象：抽象是将一类对象的共同特征总结出来构造类的过程。</li>
<li>继承：继承是从已有类得到继承信息创建新类的过程。</li>
<li>封装：把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。</li>
<li>多态：允许不同子类型的对象对同一消息作出不同的响应。</li>
</ul>
<h2 id="访问修饰符public-private-protected-以及不写（默认）时的区别？"><a href="#访问修饰符public-private-protected-以及不写（默认）时的区别？" class="headerlink" title="访问修饰符public,private,protected,以及不写（默认）时的区别？"></a>访问修饰符public,private,protected,以及不写（默认）时的区别？</h2><p><img src="https://cloud.githubusercontent.com/assets/22606175/24081050/2e06c76e-0ce6-11e7-9439-3582c5b3ed04.jpg" alt="1489928029 1"></p>
<p>注意：protected 修饰的数据域和方法可被同包访问</p>
<h2 id="String-是最基本的数据类型吗？"><a href="#String-是最基本的数据类型吗？" class="headerlink" title="String 是最基本的数据类型吗？"></a>String 是最基本的数据类型吗？</h2><p>Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型，剩下的都是引用类型。</p>
<h2 id="float-f-3-4-是否正确？"><a href="#float-f-3-4-是否正确？" class="headerlink" title="float f=3.4;是否正确？"></a>float f=3.4;是否正确？</h2><p>3.4 是双精度数，3.4f 才是单精度数。Java 中默认小数为双精度数。</p>
<h2 id="short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗？"><a href="#short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗？" class="headerlink" title="short s1 = 1; s1 = s1 + 1;有错吗? short s1 = 1; s1 += 1;有错吗？"></a>short s1 = 1; s1 = s1 + 1;有错吗? short s1 = 1; s1 += 1;有错吗？</h2><p>对于<code>short s1 = 1; s1 = s1 + 1;</code>，由于 1 是 int 类型，因此 <code>s1 + 1</code> 运算结果也是 int 型，需要强制转换类型才能赋值给 short 型。</p>
<p>对于<code>short s1 = 1; s1 += 1;</code>，可以正确编译，因为<code>s1 += 1;</code>相当于<code>s1 = (short)(s1 + 1);</code>其中有<strong>隐含的强制类型转换</strong>。</p>
<h2 id="int和Integer有什么区别？"><a href="#int和Integer有什么区别？" class="headerlink" title="int和Integer有什么区别？"></a>int和Integer有什么区别？</h2><p>Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。 </p>
<h2 id="解释内存中的栈-stack-、堆-heap-和方法区-method-area-的用法"><a href="#解释内存中的栈-stack-、堆-heap-和方法区-method-area-的用法" class="headerlink" title="解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法"></a>解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法</h2><ul>
<li>通常定义一个基本数据类型的变量、一个对象的引用、以及函数调用的现场保存都使用 JVM 中的栈空间</li>
<li>而通过 new 关键字和构造器创建的对象则放在堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为Eden、Survivor（又可分为From Survivor和To Survivor）、Tenured；</li>
<li>方法区和堆都是各个线程共享的内存区域，用于存储已经被 JVM 加载的类信息、常量、静态变量、即时编译（JIT）编译器编译后的代码等</li>
<li>程序中的字面量（literal）如直接书写的100、”hello”和常量都是放在运行时常量池中，运行时常量池是方法区的一部分。</li>
<li>栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过 JVM 的启动参数来进行调整，栈空间用光了会引发 StackOverflowError ，而堆和常量池空间不足则会引发 OutOfMemoryError 。</li>
</ul>
<p><code>String str = new String(&quot;hello&quot;);</code></p>
<p>上面的语句中变量 str 放在栈上，用 new 创建出来的字符串对象放在堆上，而”hello”这个字面量是放在方法区的。</p>
<h2 id="Math-round-11-5-等于多少？Math-round-11-5-等于多少？"><a href="#Math-round-11-5-等于多少？Math-round-11-5-等于多少？" class="headerlink" title="Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？"></a>Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？</h2><p>12；-11；四舍五入的原理是在参数上加0.5然后进行下取整。</p>
<h2 id="switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上？"><a href="#switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上？" class="headerlink" title="switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上？"></a>switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上？</h2><p>byte、short、char、int 和 String 类型可以。就是 long 型不可以。</p>
<h2 id="用最有效率的方法计算2乘以8？"><a href="#用最有效率的方法计算2乘以8？" class="headerlink" title="用最有效率的方法计算2乘以8？"></a>用最有效率的方法计算2乘以8？</h2><p> 2 &lt;&lt; 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。</p>
<h2 id="构造器（constructor）是否可被重写（override）？"><a href="#构造器（constructor）是否可被重写（override）？" class="headerlink" title="构造器（constructor）是否可被重写（override）？"></a>构造器（constructor）是否可被重写（override）？</h2><p>构造器不能被继承，因此不能被重写，但可以被重载。</p>
<h2 id="两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？"><a href="#两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？" class="headerlink" title="两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？"></a>两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？</h2><p>不对，如果两个对象 x 和 y 满足<code>x.equals(y) == true</code>，它们的哈希码（hash code）应当相同。</p>
<p>Java 对于 eqauls 方法和 hashCode 方法是这样规定的：</p>
<ol>
<li>如果两个对象相同（equals 方法返回 true），那么它们的hashCode值一定要相同</li>
<li>如果两个对象的 hashCode 相同，它们并不一定相同</li>
</ol>
<blockquote>
<p>当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）</p>
</blockquote>
<h2 id="String-和-StringBuilder、StringBuffer-的区别？"><a href="#String-和-StringBuilder、StringBuffer-的区别？" class="headerlink" title="String 和 StringBuilder、StringBuffer 的区别？"></a>String 和 StringBuilder、StringBuffer 的区别？</h2><p>答：Java 平台提供了两种类型的字符串：String 和 StringBuffer/StringBuilder，它们可以储存和操作字符串。其中 String 是只读字符串，也就意味着 String 引用的字符串内容是不能被改变的。而 StringBuffer/StringBuilder 类表示的字符串对象可以直接进行修改。StringBuilder 是 Java 5 中引入的，它和 StringBuffer 的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被 synchronized 修饰，因此它的效率也比 StringBuffer 要高。</p>
<h2 id="是否可以继承String类？"><a href="#是否可以继承String类？" class="headerlink" title="是否可以继承String类？"></a>是否可以继承String类？</h2><p>String 类是 final 类，不可以被继承。</p>
<h2 id="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><a href="#重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？" class="headerlink" title="重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"></a>重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</h2><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p>
<ul>
<li>重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同）则视为重载；重载对返回类型没有特殊的要求</li>
<li>重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，不能比父类被重写方法声明更多的异常（里氏代换原则）</li>
</ul>
<h2 id="char-型变量中能不能存贮一个中文汉字？"><a href="#char-型变量中能不能存贮一个中文汉字？" class="headerlink" title="char 型变量中能不能存贮一个中文汉字？"></a>char 型变量中能不能存贮一个中文汉字？</h2><p>char 类型可以存储一个中文汉字，因为 Java 中使用的编码是 Unicode 。而一个 char 类型占2个字节。</p>
<h2 id="抽象类（abstract-class）和接口（interface）有什么异同？"><a href="#抽象类（abstract-class）和接口（interface）有什么异同？" class="headerlink" title="抽象类（abstract class）和接口（interface）有什么异同？"></a>抽象类（abstract class）和接口（interface）有什么异同？</h2><p>相同点： 都不可实例化，但可以定义抽象类和接口类型的引用</p>
<p>不同点：</p>
<ul>
<li>抽象类有构造器，允许有抽象方法和具体方法；接口没有构造器，且方法必须是抽象方法；</li>
<li>接口中成员全是 static public 类型</li>
<li>接口可以多继承</li>
</ul>
<h2 id="静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同？"><a href="#静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同？" class="headerlink" title="* 静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？"></a>* 静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？</h2><p>Static Nested Class 是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化。</p>
<p>思考： 下面那些语句会有编译错误？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Outer &#123;</span><br><span class="line"></span><br><span class="line">    class Inner &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static void foo() &#123; new Inner(); &#125; // error</span><br><span class="line"></span><br><span class="line">    public void bar() &#123; new Inner(); &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;  // error</span><br><span class="line">        new Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Java-中会存在内存泄漏吗，请简单描述。"><a href="#Java-中会存在内存泄漏吗，请简单描述。" class="headerlink" title="Java 中会存在内存泄漏吗，请简单描述。"></a>Java 中会存在内存泄漏吗，请简单描述。</h2><p>理论上 Java 因为有垃圾回收机制（GC）不会存在内存泄露问题；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被 GC 回收，因此也会导致内存泄露的发生（比如当一个栈中出栈元素时，只是把栈的计数减一）。此外，Native 方法由于是用非 Java 语言写的，所以也可能导致内存泄露。</p>
<h2 id="抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被-synchronized-修饰？"><a href="#抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被-synchronized-修饰？" class="headerlink" title="* 抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被 synchronized 修饰？"></a>* 抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被 synchronized 修饰？</h2><p>都不能。</p>
<p>抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。</p>
<p>本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。</p>
<p>synchronized 和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。</p>
<h2 id="如何实现对象克隆？"><a href="#如何实现对象克隆？" class="headerlink" title="* 如何实现对象克隆？"></a>* 如何实现对象克隆？</h2><p>有两种方式：<br>  1). 实现 Cloneable 接口并重写 Object 类中的 clone() 方法<br>  2). 实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆</p>
<blockquote>
<p>注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露出来总是好过把问题留到运行时。</p>
</blockquote>
<h2 id="GC是什么？为什么要有GC？"><a href="#GC是什么？为什么要有GC？" class="headerlink" title="GC是什么？为什么要有GC？"></a>GC是什么？为什么要有GC？</h2><p>GC 是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。Java 程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或 Runtime.getRuntime().gc() ，但 JVM 可以屏蔽掉显式的垃圾回收调用。 </p>
<p>垃圾回收可以有效的防止内存泄露，有效使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在 Java 诞生初期，垃圾回收是 Java 最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今 Java 的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得 iOS 的系统比 Android 系统有更好的用户体验，其中一个深层次的原因就在于Android系统中垃圾回收的不可预知性。</p>
<blockquote>
<p>补充：垃圾回收机制有很多种，包括：分代复制垃圾回收、标记垃圾回收、增量垃圾回收等方式。标准的Java进程既有栈又有堆。栈保存了原始型局部变量，堆保存了要创建的对象。Java 平台对堆内存回收和再利用的基本算法被称为标记和清除，但是 Java 对其进行了改进，采用“分代式垃圾收集”。这种方法会跟 Java 对象的生命周期将堆内存划分为不同的区域，在垃圾收集过程中，可能会将对象移动到不同区域： </p>
<ul>
<li>伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。 </li>
<li>幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。 </li>
<li>终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。</li>
</ul>
</blockquote>
<h2 id="String-s-new-String-“xyz”-创建了几个字符串对象？"><a href="#String-s-new-String-“xyz”-创建了几个字符串对象？" class="headerlink" title="String s = new String(“xyz”);创建了几个字符串对象？"></a>String s = new String(“xyz”);创建了几个字符串对象？</h2><p>两个对象，一个是静态区的”xyz”，一个是用 new 创建在堆上的对象。</p>
<h2 id="接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete-class）？"><a href="#接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete-class）？" class="headerlink" title="接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？"></a>接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？</h2><p>接口可以继承接口，而且支持多重继承。抽象类可以实现(implements)接口，抽象类可继承具体类也可以继承抽象类。</p>
<h2 id="一个”-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"><a href="#一个”-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？" class="headerlink" title="一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"></a>一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？</h2><p>可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和公开类的类名完全保持一致。</p>
<h2 id="Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以实现接口？"><a href="#Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以实现接口？" class="headerlink" title="Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？"></a>Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？</h2><p>可以继承其他类或实现其他接口，在 Swing 编程和 Android 开发中常用此方式来实现事件监听和回调。</p>
<h2 id="内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"><a href="#内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？" class="headerlink" title="* 内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"></a>* 内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？</h2><p>一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。</p>
<h2 id="Java-中的-final-关键字有哪些用法？"><a href="#Java-中的-final-关键字有哪些用法？" class="headerlink" title="Java 中的 final 关键字有哪些用法？"></a>Java 中的 final 关键字有哪些用法？</h2><ul>
<li>修饰类：表示该类不能被继承</li>
<li>修饰方法：表示方法不能被重写</li>
<li>修饰变量：表示变量只能一次赋值以后值不能被修改（常量）</li>
</ul>
<h2 id="指出下面程序的运行结果"><a href="#指出下面程序的运行结果" class="headerlink" title="* 指出下面程序的运行结果"></a>* 指出下面程序的运行结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.print(&quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public A() &#123;</span><br><span class="line">        System.out.print(&quot;2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A&#123;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.print(&quot;a&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public B() &#123;</span><br><span class="line">        System.out.print(&quot;b&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Hello &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        A ab = new B();</span><br><span class="line">        ab = new B();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：1a2b2b。创建对象时构造器的调用顺序是：先初始化静态成员，然后调用父类构造器，再初始化非静态成员，最后调用自身构造器。</p>
<h2 id="数据类型之间的转换"><a href="#数据类型之间的转换" class="headerlink" title="数据类型之间的转换"></a>数据类型之间的转换</h2><p>问： </p>
<ul>
<li>如何将字符串转换为基本数据类型？ </li>
<li>如何将基本数据类型转换为字符串？ </li>
</ul>
<p>答： </p>
<ul>
<li>调用基本数据类型对应的包装类中的方法 parseXXX(String) 或 valueOf(String) 即可返回相应基本类型； </li>
<li>一种方法是将基本数据类型与空字符串（””）连接（+）即可获得其所对应的字符串；另一种方法是调用String 类中的 valueOf() 方法返回相应字符串</li>
</ul>
<h2 id="Error和Exception有什么区别？"><a href="#Error和Exception有什么区别？" class="headerlink" title="Error和Exception有什么区别？"></a>Error和Exception有什么区别？</h2><p>Error 表示系统级的错误和程序不必处理的异常，是恢复很困难的情况下的一种严重问题（比如内存溢出，不可能指望程序能处理这样的情况）；Exception 表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题。</p>
<p>常见的几种异常如下：</p>
<ul>
<li>NullPointerException - <strong>空指针引用异常</strong></li>
<li>ClassCastException - <strong>类型强制转换异常</strong></li>
<li>IllegalArgumentException - 传递非法参数异常</li>
<li>ArithmeticException - <strong>算术运算异常</strong></li>
<li>ArrayStoreException - 向数组中存放与声明类型不兼容对象异常</li>
<li>IndexOutOfBoundsException - <strong>下标越界异常</strong></li>
<li>NegativeArraySizeException - 创建一个大小为负数的数组错误异常</li>
<li>UnsupportedOperationException - <strong>不支持的操作异常</strong></li>
<li>FileNotFoundException - <strong>文件未找到异常</strong></li>
<li>IOException - 输入输出异常</li>
<li>NoSuchMethodException - 方法未找到异常</li>
<li>ClassNotFoundException - 类定义未找到异常</li>
<li>IllegalMonitorStateException - 当wait() 方法未在同步块中使用</li>
</ul>
<blockquote>
<p>java.lang.UnsupportedOperationException 是指请求的方法不被支持的异常。在从 Arrays.asList() 转化过来的 List 的不支持 add() 和 remove() 方法，这是由于从 Arrays.asList() 返回的是返回 java.util.Arrays\$ArrayList ，而不是 ArrayList 。 Arrays\$ArrayList 和 ArrayList 都是继承 AbstractList ，add() 和 remove() 等方法在 AbstractList 中默认 throw UnsupportedOperationException 而不做任何操作。 ArrayList 重写这些方法对 List 进行操作，而 Arrays\$ArrayList 却没有重写 add() 和 remove() 等方法，所以对从 Arrays.asList() 转化过来的 List 进行 add() 和 remove() 会出现 UnsupportedOperationException 异常</p>
</blockquote>
<h2 id="try-里有一个return语句，那么紧跟在这个try后的finally-里的代码会不会被执行，什么时候被执行，在return前还是后"><a href="#try-里有一个return语句，那么紧跟在这个try后的finally-里的代码会不会被执行，什么时候被执行，在return前还是后" class="headerlink" title="try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后?"></a>try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后?</h2><p>会执行，在方法返回调用者前执行。</p>
<blockquote>
<p>注意：在 finally 中改变返回值的做法是不好的，因为如果存在 finally 代码块，try 中的 return 语句不会立马返回调用者，而是记录下返回值待 finally 代码块执行完毕之后再向调用者返回其值。如果在finally中修改了返回值，就会返回修改后的值。显然，在finally中返回或者修改返回值会对程序造成很大的困扰，Java 中可以通过提升编译器的语法检查级别来产生警告或错误。</p>
</blockquote>
<h2 id="Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally-分别如何使用？"><a href="#Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally-分别如何使用？" class="headerlink" title="Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally 分别如何使用？"></a>Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally 分别如何使用？</h2><p>Java 通过面向对象的方法进行异常处理，每个异常都是一个对象，它是 Throwable 类或其子类的实例。当一个方法出现异常后便抛出一个异常对象（该对象中包含有异常信息），调用这个对象的方法可以捕获到这个异常并可以对其进行处理。</p>
<p>Java 的异常处理是通过5个关键词来实现的：try、catch、throw、throws 和 finally 。</p>
<ul>
<li>try 用于指定一块预防所有异常的程序，如果系统会抛出（throw）一个异常对象，可以通过它的类型来捕获（catch）它，或通过总是执行代码块（finally）来处理；</li>
<li>catch 子句紧跟在 try 块后面，用来指定你想要捕获的异常的类型；</li>
<li>throws 用来声明一个方法可能抛出的各种异常（当然声明异常时允许无病呻吟）；</li>
<li>finally 为确保一段代码不管发生什么异常状况都要被执行；</li>
<li>try 语句可以嵌套，每当遇到一个 try 语句，异常的结构就会被放入异常栈中，直到所有的try语句都完成。如果下一级的 try 语句没有对某种异常进行处理，异常栈就会执行出栈操作，直到遇到有处理这种异常的 try 语句或者最终将异常抛给 JVM 。</li>
</ul>
<h2 id="运行时异常与受检（必检）异常有何异同？"><a href="#运行时异常与受检（必检）异常有何异同？" class="headerlink" title="运行时异常与受检（必检）异常有何异同？"></a>运行时异常与受检（必检）异常有何异同？</h2><p>RuntimeException、Error 以及它们的子类都被称为免检异常（unchecked Exception）。所有其他异常都称为必检异常（checked Exception），意思是指编译器会强制程序员检查并处理它们。</p>
<p>异常表示程序运行过程中可能出现的非正常状态。运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。</p>
<h2 id="阐述final、finally、finalize的区别"><a href="#阐述final、finally、finalize的区别" class="headerlink" title="阐述final、finally、finalize的区别"></a>阐述final、finally、finalize的区别</h2><ul>
<li>final：<ul>
<li>如果一个类被声明为final，意味着它不能再派生出新的子类，即不能被继承，因此它和 abstract 是反义词。</li>
<li>将变量声明为 final，可以保证它们在使用中不被改变，被声明为 final 的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改。</li>
<li>被声明为 final 的方法也同样只能使用，不能在子类中被重写。 </li>
</ul>
</li>
<li>finally：通常放在 try…catch… 的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要 JVM 不关闭都能执行，可以将释放外部资源的代码写在 finally 块中。 </li>
<li>finalize：Object 类中定义的方法，Java 中允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写 finalize() 方法可以整理系统资源或者执行其他清理工作。</li>
</ul>
<h2 id="List、Set、Map是否继承自Collection接口？"><a href="#List、Set、Map是否继承自Collection接口？" class="headerlink" title="List、Set、Map是否继承自Collection接口？"></a>List、Set、Map是否继承自Collection接口？</h2><p>List、Set 是，Map 不是。Map是键值对映射容器，与 List 和 Set 有明显的区别，而 Set 存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List 是线性结构的容器，适用于按数值索引访问元素的情形。</p>
<h2 id="阐述-ArrayList、Vector、LinkedList-的存储性能和特性"><a href="#阐述-ArrayList、Vector、LinkedList-的存储性能和特性" class="headerlink" title="阐述 ArrayList、Vector、LinkedList 的存储性能和特性"></a>阐述 ArrayList、Vector、LinkedList 的存储性能和特性</h2><p>ArrayList 和 Vector 都是使用数组方式存储数据，数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector 中的方法由于添加了 synchronized 修饰，因此 Vector 是线程安全的容器，但性能上较 ArrayList 差，因此已经是 Java 中的遗留容器。</p>
<p>LinkedList 使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。</p>
<p>Vector 属于遗留容器，已经不推荐使用，但是由于 ArrayList 和 LinkedListed 都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类 Collections 中的 synchronizedList 方法将其转换成线程安全的容器后再使用。</p>
<h2 id="Collection-和-Collections-的区别？"><a href="#Collection-和-Collections-的区别？" class="headerlink" title="Collection 和 Collections 的区别？"></a>Collection 和 Collections 的区别？</h2><p>Collection 是一个接口，它是 Set、List 等容器的父接口；Collections 是个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。</p>
<h2 id="List、Map、Set-三个接口存取元素时，各有什么特点？"><a href="#List、Map、Set-三个接口存取元素时，各有什么特点？" class="headerlink" title="List、Map、Set 三个接口存取元素时，各有什么特点？"></a>List、Map、Set 三个接口存取元素时，各有什么特点？</h2><p>List 以特定索引来存取元素，可以有重复元素。Set 不能存放重复元素（用对象的 equals() 方法来区分元素是否重复）。Map 保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。Set 和 Map 容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。</p>
<h2 id="TreeMap-和-TreeSet-在排序时如何比较元素？Collections工具类中的sort-方法如何比较元素？"><a href="#TreeMap-和-TreeSet-在排序时如何比较元素？Collections工具类中的sort-方法如何比较元素？" class="headerlink" title="TreeMap 和 TreeSet 在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？"></a>TreeMap 和 TreeSet 在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？</h2><p>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo() 方法，当插入元素时会回调该方法比较元素的大小。TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进行排序。</p>
<p>Collections 工具类的 sort 方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现Comparable 接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是 Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小。 </p>
<h2 id="Thread类的sleep-方法和对象的wait-方法都可以让线程暂停执行，它们有什么区别"><a href="#Thread类的sleep-方法和对象的wait-方法都可以让线程暂停执行，它们有什么区别" class="headerlink" title="Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?"></a>Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?</h2><p>sleep() 方法是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态）。</p>
<p>wait() 是 Object 类的方法，调用对象的 wait() 方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的 notify() 方法（或 notifyAll() 方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。</p>
<blockquote>
<p>注意：对象等待池和等锁池是两个不同的概念</p>
</blockquote>
<p>总结如下：</p>
<ul>
<li>wait() 方法会释放锁，而 sleep() 方法不会释放锁。</li>
<li>进入 wait 状态的线程能够被 notify 和 notifyAll 唤醒，但是进入 sleeping 状态的线程只能到了规定的时间再自动苏醒。</li>
<li>Java 中的 wait() 方法只能在同步代码块中调用，但是 sleep() 方法不需要。</li>
</ul>
<blockquote>
<p>补充：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位；线程是进程的一个实体，是 CPU 调度和分派的基本单位，是比进程更小的能独立运行的基本单位。线程的划分尺度小于进程，这使得多线程程序的并发性高；进程在执行时通常拥有独立的内存单元，而线程之间可以共享内存。使用多线程的编程通常能够带来更好的性能和用户体验，但是多线程的程序对于其他程序是不友好的，因为它可能占用了更多的 CPU 资源。当然，也不是线程越多，程序的性能就越好，因为线程之间的调度和切换也会浪费 CPU 时间。</p>
</blockquote>
<h2 id="线程的sleep-方法和yield-方法有什么区别？"><a href="#线程的sleep-方法和yield-方法有什么区别？" class="headerlink" title="线程的sleep()方法和yield()方法有什么区别？"></a>线程的sleep()方法和yield()方法有什么区别？</h2><ul>
<li>sleep() 方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield() 方法只会给相同优先级或更高优先级的线程以运行的机会</li>
<li>线程执行 sleep() 方法后转入阻塞（blocked）状态，而执行 yield() 方法后转入就绪（ready）状态</li>
<li>sleep() 方法声明抛出 InterruptedException，而 yield() 方法没有声明任何异常</li>
<li>sleep() 方法比 yield() 方法（跟操作系统 CPU 调度相关）具有更好的可移植性</li>
</ul>
<h2 id="当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？"><a href="#当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？" class="headerlink" title="当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？"></a>当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？</h2><p>不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的 synchronized 修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（注意不是等待池）中等待对象的锁。</p>
<h2 id="请说出与线程同步以及线程调度相关的方法。"><a href="#请说出与线程同步以及线程调度相关的方法。" class="headerlink" title="请说出与线程同步以及线程调度相关的方法。"></a>请说出与线程同步以及线程调度相关的方法。</h2><ul>
<li>wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁</li>
<li>sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理 InterruptedException 异常</li>
<li>notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关</li>
<li>notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态</li>
</ul>
<blockquote>
<p>Java 5通过 Lock 接口提供了显式的锁机制（explicit lock），增强了灵活性以及对线程的协调。Lock 接口中定义了加锁（lock()）和解锁（unlock()）的方法，同时还提供了 newCondition() 方法来产生用于线程之间通信的Condition对象；此外，Java 5还提供了信号量机制（semaphore），信号量可以用来限制对某个共享资源进行访问的线程的数量。在对资源进行访问之前，线程必须得到信号量的许可（调用Semaphore对象的acquire()方法）；在完成对资源的访问后，线程必须向信号量归还许可（调用Semaphore对象的release()方法）。</p>
</blockquote>
<h2 id="编写多线程程序有几种实现方式？"><a href="#编写多线程程序有几种实现方式？" class="headerlink" title="编写多线程程序有几种实现方式？"></a>编写多线程程序有几种实现方式？</h2><p>Java 5 以前实现多线程有两种实现方法：一种是继承 Thread 类；另一种是实现 Runnable 接口。两种方式都要通过重写 run() 方法来定义线程的行为。</p>
<p>推荐使用后者，因为 Java 中的继承是单继承，一个类有一个父类，如果继承了 Thread 类就无法再继承其他类了，显然使用 Runnable 接口更为灵活。此外更重要的是，可以把线程逻辑从线程的执行中分离出来。</p>
<h2 id="举例说明同步和异步"><a href="#举例说明同步和异步" class="headerlink" title="举例说明同步和异步"></a>举例说明同步和异步</h2><p>如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），那么这些数据就必须进行同步存取（如数据库操作中的排他锁）。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作，而异步就是非阻塞式操作。</p>
<h2 id="什么是线程池（thread-pool）？"><a href="#什么是线程池（thread-pool）？" class="headerlink" title="什么是线程池（thread pool）？"></a>什么是线程池（thread pool）？</h2><p>在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在 Java 中，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是<strong>池化资源</strong>技术产生的原因。</p>
<p>线程池就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。Java 提供 Executor 接口来执行线程池中的任务，提供 ExecutoeService 接口来管理和控制任务。</p>
<h2 id="线程的基本状态以及状态之间的关系？"><a href="#线程的基本状态以及状态之间的关系？" class="headerlink" title="线程的基本状态以及状态之间的关系？"></a>线程的基本状态以及状态之间的关系？</h2><p><img src="http://img.blog.csdn.net/20150408002007838" alt="enter image description here"></p>
<h2 id="Java中如何实现序列化，有什么意义？"><a href="#Java中如何实现序列化，有什么意义？" class="headerlink" title="Java中如何实现序列化，有什么意义？"></a>Java中如何实现序列化，有什么意义？</h2><p>序列化是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。 </p>
<p>要实现序列化，需要让一个类实现 Serializable 接口，该接口是一个标识性接口，标注该类对象是可被序列化的。然后使用一个输出流来构造一个对象输出流并通过 writeObject(Object) 方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过 readObject 方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆。</p>
<h2 id="Interge的线程安全容器是？"><a href="#Interge的线程安全容器是？" class="headerlink" title="Interge的线程安全容器是？"></a>Interge的线程安全容器是？</h2><p><a href="http://www.jianshu.com/p/509aca840f6d" target="_blank" rel="noopener">Java 原子操作 AtomicInteger 的用法</a></p>
<h2 id="线程安全的集合对象"><a href="#线程安全的集合对象" class="headerlink" title="线程安全的集合对象"></a>线程安全的集合对象</h2><ul>
<li>ArrayList 线程不安全，Vector 线程安全；</li>
<li>HashMap 线程不安全，HashTable 线程安全；</li>
<li>StringBuilder 线程不安全，StringBuffer 线程安全。</li>
</ul>
<p><a href="http://wiki.jikexueyuan.com/project/java-collection/" target="_blank" rel="noopener">Java 集合的实现原理</a></p>
<h2 id="托管代码与非托管代码的区别"><a href="#托管代码与非托管代码的区别" class="headerlink" title="托管代码与非托管代码的区别"></a>托管代码与非托管代码的区别</h2><ul>
<li>托管代码是一种中间语言，运行在 CLR（公共语言运行库）上；非托管代码被编译为机器码，运行在机器上。</li>
<li>托管代码独立于平台和语言，能更好的实现不同语言平台之间的兼容；非托管代码依赖于平台和语言。</li>
<li>托管代码可享受 CLR 提供的服务（如安全检测、垃圾回收等），不需要自己完成这些操作；非托管代码需要自己提供安全检测、垃圾回收等操作。</li>
</ul>
<p><a href="http://gauyanm.blog.51cto.com/629619/581107" target="_blank" rel="noopener">托管代码与非托管代码</a></p>
<hr>
<ul>
<li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p>
</li>
<li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p>
</li>
</ul>
<h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p>
<blockquote>
<p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p>
</blockquote>
<blockquote>
<p>体育&amp;户外用品推荐</p>
</blockquote>
<div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/se-notes/Java基础/Java基础知识/../../../more/ads/amazon.gif" width="100%"></a> </div>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/se-notes/Java基础/Java基础知识/">
    <time datetime="2019-01-03T13:49:30.000Z" class="entry-date">
        1月 3 2019
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/编程语言/">编程语言</a>, <a class="article-category-link" href="/categories/编程语言/java/">java</a>
  </div>

    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java基础/">java基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java语法/">java语法</a></li></ul>

    </footer>
</article>






  
    <article id="post-se-notes/Java基础/README" class="post-se-notes/Java基础/README post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/se-notes/Java基础/README/">Java基础-README</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://wnhby.github.io/se-notes/Java基础/README/" data-id="cjsbez09l0032czs613hwoi2e" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <!-- TOC -->
<ul>
<li><a href="#java-特性与-c-比较">Java 特性（与 C++ 比较）</a></li>
<li><a href="#java-数据类型">Java 数据类型</a></li>
<li><a href="#方法调用过程">方法调用过程</a></li>
<li><a href="#数组的复制">数组的复制</a></li>
<li><a href="#基本类型变量和引用类型变量">基本类型变量和引用类型变量</a></li>
<li><a href="#类的静态变量与方法">类的静态变量与方法</a></li>
<li><a href="#不可变对象和类">不可变对象和类</a></li>
<li><a href="#this引用">this引用</a></li>
<li><a href="#多态与动态绑定">多态与动态绑定</a></li>
<li><a href="#异常处理">异常处理</a></li>
<li><a href="#文本io与二进制io">文本IO与二进制IO</a><pre><code>- [Ads](#ads)
</code></pre></li>
</ul>
<!-- /TOC -->
<h1 id="Java-特性（与-C-比较）"><a href="#Java-特性（与-C-比较）" class="headerlink" title="Java 特性（与 C++ 比较）"></a>Java 特性（与 C++ 比较）</h1><p>核心特性：</p>
<ul>
<li><strong>跨平台性</strong>：Java 一次编译可到处运行</li>
<li><strong>自动内存管理</strong>：Java 没有指针，内存管理依靠垃圾自动回收</li>
<li><strong>完全面向对象</strong>：所有函数和变量必须是类的一部分</li>
</ul>
<p>其他特性：</p>
<ul>
<li>强制异常规约</li>
<li>内置字符串：Java 有内置类型</li>
<li>操作符重载：不支持操作符重载</li>
<li>执行速度慢</li>
<li>不支持多重继承</li>
<li>不支持默认函数参数</li>
<li>不支持 goto 语句</li>
</ul>
<h1 id="Java-数据类型"><a href="#Java-数据类型" class="headerlink" title="Java 数据类型"></a>Java 数据类型</h1><p>JAVA 有八种基础的数据类型：</p>
<ul>
<li>整数型：byte(8 bits)、short(16 bits)、int(32 bits)、long(64 bits)</li>
<li>浮点型：float(32 bits)、double(64 bits)</li>
<li>字符型：char(16 bits)</li>
<li>布尔型：boolean</li>
</ul>
<p><img src="https://cloud.githubusercontent.com/assets/22606175/24044502/7e59520e-0b56-11e7-83d8-b1b2988d2a62.jpg" alt="1489756357 1"></p>
<h1 id="方法调用过程"><a href="#方法调用过程" class="headerlink" title="方法调用过程"></a>方法调用过程</h1><p>当调用一个方法时，系统将参数和局部变量存储在一个称为<strong>堆栈</strong>的内存区域中；当一个方法调用另一个方法时，调用者的堆栈保持不动，新开辟的堆栈处理新方法的调用；当一个方法结束返回到调用者时，其相应空间被释放。</p>
<h1 id="数组的复制"><a href="#数组的复制" class="headerlink" title="数组的复制"></a>数组的复制</h1><p>复制数组一般有三种方法：</p>
<ol>
<li>使用循环语句逐个复制数组的元素</li>
<li>使用 System 类的静态方法 arraycopy</li>
<li>使用 clone 方法复制数组</li>
</ol>
<p>浅拷贝：使用一个已知实例对新创建实例的成员变量逐个赋值，这个方式被称为浅拷贝。</p>
<p>深拷贝：当一个类的拷贝构造方法，不仅要复制对象的所有非引用成员变量值，还要为引用类型的成员变量创建新的实例，并且初始化为形参实例的值。这个方式称为深拷贝。</p>
<h1 id="基本类型变量和引用类型变量"><a href="#基本类型变量和引用类型变量" class="headerlink" title="基本类型变量和引用类型变量"></a>基本类型变量和引用类型变量</h1><p>每个变量都代表一个存储值的内存位置，声明一个变量时就是在告诉编译器该变量存储何种类型的值。</p>
<p>对基本类型变量而言，存储值是基本类型，对引用类型变量而言，对应内存所存储值是一个对象的引用，即对象的存储地址。</p>
<p>当一个变量赋值给另一个变量时，对基本类型变量而言，就是将一个变量的实际值赋给了另一个变量；对引用类型变量而言，是将一个变量的引用赋给了另一个变量。</p>
<p><img src="https://cloud.githubusercontent.com/assets/22606175/24067589/c2dde04e-0bb9-11e7-944e-0a2fafcbe3f0.jpg" alt="1489799001 1"></p>
<h1 id="类的静态变量与方法"><a href="#类的静态变量与方法" class="headerlink" title="类的静态变量与方法"></a>类的静态变量与方法</h1><ul>
<li>类的静态变量被同一个类的所有实例所共享。</li>
<li>可以在不使用实例的情况下调用静态方法。（一般通过类名.方法名调用，无须创建对象）</li>
<li>类的每一个实例都能访问该类的静态变量与静态方法。</li>
<li>实例变量与实例方法只能在实例方法中使用，不能在静态方法中使用。</li>
</ul>
<h1 id="不可变对象和类"><a href="#不可变对象和类" class="headerlink" title="不可变对象和类"></a>不可变对象和类</h1><p>通常创建一个对象后，其内容是允许随后改变的。但是有时也需要创建一个一旦创建，其内容就不能再改变的对象。这种对象称为<strong>不可变对象</strong>，而它的类成为<strong>不可变类</strong>。</p>
<p>要使一个类成为不可变的，必须满足如下要求：</p>
<ol>
<li>所有数据域都是私有的。</li>
<li>没有修改器方法。</li>
<li>没有一个访问器方法，它会返回一个指向可变数据域的引用。</li>
</ol>
<h1 id="this引用"><a href="#this引用" class="headerlink" title="this引用"></a>this引用</h1><p>关键字 this 指向调用对象本身的引用名，有两种常用的使用场景：</p>
<ol>
<li>在 set 方法中引用隐藏数据域（如<code>this.name = name</code>）</li>
<li>让构造方法调用同一个类的另外一个构造方法</li>
</ol>
<h1 id="多态与动态绑定"><a href="#多态与动态绑定" class="headerlink" title="多态与动态绑定"></a>多态与动态绑定</h1><p>多态的定义：父类型的变量可以引用子类型的对象</p>
<p>声明类型：引用变量在声明时的类型</p>
<p>实际类型：引用变量所指向的对象的实际类</p>
<p>当从引用变量调用实例方法时，由该引用变量的<strong>实际类型</strong>在<strong>运行时</strong>决定使用该方法的哪个实现；当引用变量访问数据域和静态方法时，由该引用变量的<strong>声明类型</strong>在<strong>编译时</strong>决定使用哪个方法。</p>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>异常处理的优势在于把“检测错误”从“处理错误”中分离出来。</p>
<ul>
<li>免检异常：RuntimeException、Error 以及其子类都是免检异常，通常反映程序中不可恢复的逻辑错误</li>
<li>必检异常：除免检异常外的所有异常称为“必检异常”，编译器强制要求程序员处理的异常。</li>
</ul>
<p>常见的几种异常如下：</p>
<ul>
<li>NullPointerException - 空指针引用异常</li>
<li>ClassCastException - 类型强制转换异常。</li>
<li>IllegalArgumentException - 传递非法参数异常。</li>
<li>ArithmeticException - 算术运算异常</li>
<li>ArrayStoreException - 向数组中存放与声明类型不兼容对象异常</li>
<li>IndexOutOfBoundsException - 下标越界异常</li>
<li>NegativeArraySizeException - 创建一个大小为负数的数组错误异常</li>
<li>UnsupportedOperationException - 不支持的操作异常</li>
</ul>
<h1 id="文本IO与二进制IO"><a href="#文本IO与二进制IO" class="headerlink" title="文本IO与二进制IO"></a>文本IO与二进制IO</h1><p>IO类分为文本IO与二进制IO，前者将数据解释成字符序列，后者将数据解释成原始的二进制数值。</p>
<p>文本IO建立在二进制IO的基础之上，提供字符层面的编解码的抽象。当文本IO向文件写入一个字符时，JVM会自动把统一码转为文件指定的编码，而读取字符时把文件指定的编码转换为统一码。</p>
<p>二进制IO不需要转换编码，当二进制IO向文件写入一个数值，就是将内存中的确切值复制到文件中。</p>
<p><img src="https://cloud.githubusercontent.com/assets/22606175/24069192/e5da3f8e-0bdc-11e7-995c-f499aaa189cf.jpg" alt="1489814095 1"></p>
<hr>
<ul>
<li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p>
</li>
<li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p>
</li>
</ul>
<h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p>
<blockquote>
<p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p>
</blockquote>
<blockquote>
<p>体育&amp;户外用品推荐</p>
</blockquote>
<div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/se-notes/Java基础/README/../../../more/ads/amazon.gif" width="100%"></a> </div>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/se-notes/Java基础/README/">
    <time datetime="2019-01-03T13:49:30.000Z" class="entry-date">
        1月 3 2019
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/编程语言/">编程语言</a>, <a class="article-category-link" href="/categories/编程语言/java/">java</a>
  </div>

    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java基础/">java基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java语法/">java语法</a></li></ul>

    </footer>
</article>






  
    <article id="post-se-notes/Java基础/Spring基础装配" class="post-se-notes/Java基础/Spring基础装配 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/se-notes/Java基础/Spring基础装配/">Spring基础装配</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://wnhby.github.io/se-notes/Java基础/Spring基础装配/" data-id="cjsbez09p0036czs6oi1vthyd" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <!-- TOC -->
<ul>
<li><a href="#自动化装配">自动化装配</a></li>
<li><a href="#使用-java-代码装配-bean">使用 Java 代码装配 bean</a><pre><code>- [1. 创建配置类](#1-创建配置类)
- [2. 声明简单的 bean](#2-声明简单的-bean)
- [3. 借助 JavaConfig 实现注入](#3-借助-javaconfig-实现注入)
</code></pre></li>
<li><a href="#通过-xml-装配-bean">通过 XML 装配 bean</a><ul>
<li><a href="#1-创建xml装配规范">1. 创建XML装配规范</a></li>
<li><a href="#2-声明一个简单的-bean">2. 声明一个简单的 bean</a></li>
<li><a href="#3-借助构造器注入初始化-bean">3. 借助构造器注入初始化 bean</a><ul>
<li><a href="#使用constructor-arg声明">使用<code>&lt;constructor-arg&gt;</code>声明</a></li>
<li><a href="#使用c-命名空间">使用c-命名空间</a></li>
</ul>
</li>
<li><a href="#4-属性注入">4. 属性注入</a><ul>
<li><a href="#p-命名空间">p-命名空间</a></li>
<li><a href="#ads">Ads</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /TOC -->
<p>Spring 提供了三种主要的装配机制来描述对 bean 的装配：</p>
<ul>
<li>在 XML 中进行显式配置</li>
<li>在 Java 中进行显式配置</li>
<li>隐式的 bean 发现机制和自动装配</li>
</ul>
<h1 id="自动化装配"><a href="#自动化装配" class="headerlink" title="自动化装配"></a>自动化装配</h1><p>Spring 从两个角度实现自动化装配：</p>
<ul>
<li>组件扫描：Spring 会自动发现应用上下文中所创建的 bean</li>
<li>自动装配：Spring 自动满足 bean 之间的依赖</li>
</ul>
<p>以下以 CD 播放器为例阐述如何进行自动化装配：首先创建 CD 类，让 Spring 将其自动创建为 bean，然后创建一个 CDPlayer 类，让 Spring 把 CD bean 注入进来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* 创建CD类并声明为bean */</span><br><span class="line">package main;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component // 该注解把该类声明为bean,也可以用Component(&quot;name&quot;)形式进行命名</span><br><span class="line">public class CD &#123;</span><br><span class="line">    private String message = &quot;this is my cd&quot;;</span><br><span class="line">    public void play()&#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但组件扫描是默认不启用的，因此还需要显式配置 Spring 从而让其寻找带有 @Component 注解的类并为其创建 bean。类 CDPlayerConfig 通过 Java 代码而非配置文件来定义了装配规则（虽然为空），并使用了 @ComponentScan 注解启用了组件扫描。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package main;</span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@ComponentScan</span><br><span class="line">public class CDPlayerConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>@ComponentScan 默认会以配置类所在的包作为基础包来扫描组件。若想扫描多个基础包，则可以设置注解的属性如<code>@ComponentScan(basePackages={&quot;soundsystem&quot;,&quot;video&quot;})</code></p>
</blockquote>
<p>创建了这两个类后，现在我们可以对功能进行测试，观察 bean 是否注入成功。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.test.context.ContextConfiguration;</span><br><span class="line">import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line">import static org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(classes = CDPlayerConfig.class) // 该注解指定从哪个配置类加载配置</span><br><span class="line">public class CDPlayerTest &#123;</span><br><span class="line">	// 使用 Autowird 自动装配；该注解可适用于类的任何方法上</span><br><span class="line">	// 若有且只有一个bean匹配依赖需求的话，则spring会加载这个bean；否则会抛出异常</span><br><span class="line">    @Autowired </span><br><span class="line">    private CD cd;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void myTest()&#123;</span><br><span class="line">        assertNotNull(cd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="使用-Java-代码装配-bean"><a href="#使用-Java-代码装配-bean" class="headerlink" title="使用 Java 代码装配 bean"></a>使用 Java 代码装配 bean</h1><p>虽然很多场景下通过组件扫描和自动装配实现 Spring 的自动化配置是更为推荐的方式，但有时自动化配置的方案行不通，因此需要显式地配置 Spring。显式配置有两种方案：Java 和 XML，其中 JavaConfig 由于更为强大、类型安全以及对重构友好，因此是较好的方案。</p>
<h3 id="1-创建配置类"><a href="#1-创建配置类" class="headerlink" title="1. 创建配置类"></a>1. 创建配置类</h3><p>创建 JavaConfig 类的关键在于为其添加 @Configuration 注解，表明该类是一个配置类，该类应该包含<strong>在 Spring 应用上下文中如何创建 bean</strong> 的细节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class CDPlayerConfig&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-声明简单的-bean"><a href="#2-声明简单的-bean" class="headerlink" title="2. 声明简单的 bean"></a>2. 声明简单的 bean</h3><p>在 JavaConfig 中声明 bean，需要编写一个方法，该方法会创建所需类型的实例，然后为这个方法添加 @Bean 注解。@Bean 注解会告诉 Spring 这个方法会返回一个对象，该对象注册为 Spring 应用上下文中的 bean。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个返回CD类型的实例的bean</span><br><span class="line">@Bean</span><br><span class="line">public CD sgtPeppers()&#123;</span><br><span class="line">	return new SgtPeppers(); //此处SgtPeppers是CD的子类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下 bean 的 ID 与带有 @Bean 注解的方法名是一样的，也可以通过 @Bean(name=”name”) 的形式为其命名。</p>
<h3 id="3-借助-JavaConfig-实现注入"><a href="#3-借助-JavaConfig-实现注入" class="headerlink" title="3. 借助 JavaConfig 实现注入"></a>3. 借助 JavaConfig 实现注入</h3><p>在配置中，我们往往需要声明一个依赖于其他 bean 的 bean，因此在声明一个复杂的 bean 时往往也需要同时注入其他的 bean。</p>
<p>装配 bean 的最简单方式是引用创建 bean 的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean // 带有@Bean注解的方法可以采用任何必要的Java功能来产生bean实例</span><br><span class="line">public CDPlayer cdPlayer()&#123;</span><br><span class="line">	return new CDPlayer(sgtPeppers());// sgtPeppers()是已经声明的、被@Bean所注解的方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>看起来 CD 是通过 sgtPeppers() 得到的，但实际上，由于 sgtPeppers() 方法上添加了 @Bean 注解，Spring 会拦截所有对它的调用，确保直接返回该方法的 bean，而不是每次都进行实际的调用。<strong>默认情况下，Spirng 中的 bean 都是单例</strong>。</p>
</blockquote>
<p>但也可用以下更容易理解的方式来装配 bean：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public CDPlayer cdPlayer(CD cd)&#123;</span><br><span class="line">	CDPlayer cdPlayer = new CDPlayer(cd);</span><br><span class="line">	cdPlayer.setCD(cd);</span><br><span class="line">	return cdPlayer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处 cdPlayer() 方法请求一个 CD 实例作为参数，当 Spring 调用 cdPlayer() 创建  CDPlayer bean 时，它会自动装配一个 CD bean 到配置方法中，而无需明确引用 CD 的 @Bean 方法。通过该方式引用其它的 bean 是最佳选择（因为它不会要求将 CD bean 声明到同一个配置类中，这样可以实现分散配置文件）。  </p>
<h1 id="通过-XML-装配-bean"><a href="#通过-XML-装配-bean" class="headerlink" title="通过 XML 装配 bean"></a>通过 XML 装配 bean</h1><p>Spring 目前有了强大的自动化配置和基于 Java 的配置，XML不再是第一选择了。但是鉴于已经存在那么多基于 XML 的 Spring 配置，因此理解如何在 Spring 中使用 XML 还是很重要的。</p>
<h2 id="1-创建XML装配规范"><a href="#1-创建XML装配规范" class="headerlink" title="1. 创建XML装配规范"></a>1. 创建XML装配规范</h2><p>最简单的 XML 配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans </span><br><span class="line">       http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</span><br><span class="line">       http://www.springframework.org/schema/context&quot;&gt;</span><br><span class="line">       </span><br><span class="line">	&lt;!-- configuration details go here --&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>用于装配 bean 的最基本的 XML 元素包含在 spring-beans 模式中，它被定义为根命名空间。<code>&lt;beans&gt;</code> 是该模式中的一个元素，是所有 Spring 配置文件的根元素。</p>
<h2 id="2-声明一个简单的-bean"><a href="#2-声明一个简单的-bean" class="headerlink" title="2. 声明一个简单的 bean"></a>2. 声明一个简单的 bean</h2><p>使用<code>&lt;bean&gt;</code>元素声明一个 bean，并设置 id 进行命名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;cd1&quot; class=&quot;soundSystem.SgtPeppers&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-借助构造器注入初始化-bean"><a href="#3-借助构造器注入初始化-bean" class="headerlink" title="3. 借助构造器注入初始化 bean"></a>3. 借助构造器注入初始化 bean</h2><p>使用构造器注入 bean 引用时，有两种基本配置方案可选择：</p>
<ul>
<li><code>&lt;constructor-arg&gt;</code> 元素，特点是配置比较冗长</li>
<li>使用 Spring 3 所引入的 c-命名空间，特点是配置比较简练，但无法装配<code>集合</code></li>
</ul>
<h3 id="使用-lt-constructor-arg-gt-声明"><a href="#使用-lt-constructor-arg-gt-声明" class="headerlink" title="使用&lt;constructor-arg&gt;声明"></a>使用<code>&lt;constructor-arg&gt;</code>声明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* 声明CDPlayer并通过id引用已有的SgtPerpers bean*/</span><br><span class="line">&lt;bean id=“cdPlayer” class=&quot;soundSystem.CDPlayer&quot;&gt;</span><br><span class="line">	&lt;constructor-arg ref=&quot;sgtPerpers&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>当 Spring 遇到<code>&lt;bean&gt;</code>元素时，会创建一个 CDPlayer 实例，<code>&lt;constructor-arg&gt;</code> 元素表明要将一个 id 为 sgtPerpers 的 bean 引用传递到 CDPlayer 的构造器中。</p>
<p>当把字面量注入构造器而不是引用时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=“cdPlayer” class=&quot;soundSystem.CDPlayer&quot;&gt;</span><br><span class="line">	&lt;constructor-arg value=&quot;The Love&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h3 id="使用c-命名空间"><a href="#使用c-命名空间" class="headerlink" title="使用c-命名空间"></a>使用c-命名空间</h3><p>在 XML 顶部声明其模式：<code>xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</code>，就可用其来声明构造器参数了。</p>
<p>一个典型的示例是 <code>c:cd-ref=&quot;compactDisc&quot;</code>，属性名以 <code>c:</code> 开头，即命名空间前缀，接下来是要装配的构造器参数名，之后是<code>-ref</code>，表示装配的是一个 bean 的引用，这个 bean 的 ID 为 <code>compactDisc</code>。</p>
<p>也可使用参数索引替代直接使用参数名的方案，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 由于xml不允许数字作为属性的首字符，因此添加一个下划线作后缀 --&gt;</span><br><span class="line">&lt;bean id=“cdPlayer” class=&quot;soundSystem.CDPlayer&quot; c:_0-ref=&quot;compactDisc&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>也可以根本不标示参数（前提是只有一个构造器参数），如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=“cdPlayer” class=&quot;soundSystem.CDPlayer&quot; c:_-ref=&quot;compactDisc&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>当需要注入字面量而不是 bean 引用时：</p>
<ul>
<li><p>方案一：引用构造器参数的名字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=“cdPlayer” class=&quot;soundSystem.CDPlayer&quot;</span><br><span class="line">	c:_title=&quot;My Love&quot;</span><br><span class="line">	c:_artist=&quot;ZZP&quot;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方案二：使用参数索引</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=“cdPlayer” class=&quot;soundSystem.CDPlayer&quot;</span><br><span class="line">	c:_0=&quot;My Love&quot;</span><br><span class="line">	c:_1=&quot;ZZP&quot;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="4-属性注入"><a href="#4-属性注入" class="headerlink" title="4. 属性注入"></a>4. 属性注入</h2><p>假设需要属性注入的 CDPlayer 如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class CDPlayer &#123;</span><br><span class="line">	private CD cd;</span><br><span class="line">	</span><br><span class="line">	@Autowired</span><br><span class="line">	pulic setCd(CD cd)&#123;</span><br><span class="line">		this.cd = cd;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>声明为一个 bean：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=“cdPlayer” class=&quot;soundSystem.CDPlayer&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;cd&quot; ref=&quot;cd&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>&lt;property&gt;</code>元素为属性的 Setter 方法所提供的功能与 <code>&lt;constructor-arg&gt;</code> 提供的功能是一样的。本例中它引用了 ID 为 <code>CD</code> 的 bean（通过 ref 属性），并将其注入到 <code>cd</code> 属性中（通过 setCD() 方法）。</p>
<h3 id="p-命名空间"><a href="#p-命名空间" class="headerlink" title="p-命名空间"></a>p-命名空间</h3><p> p-命名空间是作为<code>&lt;property&gt;</code>元素的替代方案，使用时需在 XML 顶部声明其模式：<code>xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=“cdPlayer” </span><br><span class="line">	class=&quot;soundSystem.CDPlayer&quot; </span><br><span class="line">	p:cd-ref=&quot;cd&quot;/&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">	首先属性的名字使用了&quot;p:&quot;前缀，表面设置的是一个属性；接下来是要注入的属性名，最后属性名称以&quot;-ref&quot;结尾，表明装配的是一个引用而非字面量。</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure>
<p>当需要注入字面量时，区别在于是否带有”-ref”后缀：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=“cdPlayer” </span><br><span class="line">	class=&quot;soundSystem.CDPlayer&quot; </span><br><span class="line">	p:title=&quot;My Love&quot;</span><br><span class="line">	p:artist=&quot;ZZP&quot;/&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：p-命名空间同样无法装配集合，但可以通过 util-命名空间（用于创建集合类型的bean）辅助实现装配集合的功能。</p>
</blockquote>
<hr>
<ul>
<li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p>
</li>
<li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p>
</li>
</ul>
<h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p>
<blockquote>
<p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p>
</blockquote>
<blockquote>
<p>体育&amp;户外用品推荐</p>
</blockquote>
<div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/se-notes/Java基础/Spring基础装配/../../../more/ads/amazon.gif" width="100%"></a> </div>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/se-notes/Java基础/Spring基础装配/">
    <time datetime="2019-01-03T13:49:30.000Z" class="entry-date">
        1月 3 2019
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/编程语言/">编程语言</a>, <a class="article-category-link" href="/categories/编程语言/java/">java</a>
  </div>

    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java基础/">java基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java语法/">java语法</a></li></ul>

    </footer>
</article>






  
    <article id="post-se-notes/Java基础/Spring概述" class="post-se-notes/Java基础/Spring概述 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/se-notes/Java基础/Spring概述/">Spring概述</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://wnhby.github.io/se-notes/Java基础/Spring概述/" data-id="cjsbez09r0038czs60ox6c1jv" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <!-- TOC -->
<ul>
<li><a href="#概述">概述</a></li>
<li><a href="#依赖注入di">依赖注入（DI）</a></li>
<li><a href="#面向切面编程aop">面向切面编程（AOP）</a></li>
<li><a href="#spring-容器">Spring 容器</a><ul>
<li><a href="#应用上下文">应用上下文</a></li>
<li><a href="#bean-的生命周期">bean 的生命周期</a></li>
</ul>
</li>
<li><a href="#spring-其他模块">Spring 其他模块</a><pre><code>- [Spring 容器](#spring-容器-1)
- [AOP 模块](#aop-模块)
- [数据访问和集成](#数据访问和集成)
- [Web 与远程调用](#web-与远程调用)
- [测试](#测试)
- [Ads](#ads)
</code></pre></li>
</ul>
<!-- /TOC -->
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Spring 是一个为了解决企业级应用开发的复杂性而创建的开源框架。Spring 不仅仅局限于服务器端开发，任何 Java 应用都能在简单性、可测试性和松耦合等方面从 Spring 中获益。<strong>简化 Java 开发是 Spring 最根本的使命</strong>。</p>
<p>为了降低 Java 开发的复杂性，Spring 采取了以下策略：</p>
<ul>
<li>基于 POJO 的轻量级和最小侵入性编程（侵入性：强迫应用继承框架的类或接口从而和框架绑死）</li>
<li>通过依赖注入和面向接口实现松耦合</li>
<li>基于切面和惯例进行声明式编程</li>
<li>通过切面和模板减少样板式代码</li>
</ul>
<h1 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h1><p>任何一个有实际意义的应用都由两个以上的类组成，这些类互相协作来完成特定的业务逻辑。但如果按照传统的做法，让每个对象负责管理与自己相互协作的对象（即所依赖的对象）的引用，将会导致高度耦合和难以测试的代码。</p>
<blockquote>
<p>耦合具有两面性：一方面紧密耦合的代码难以测试与复用，另一方面一定程度的耦合是必须的——完全没有耦合的代码什么也做不了。因此耦合是必须的，但应当谨慎管理。</p>
</blockquote>
<p>通过依赖注入（DI），对象的依赖关系将由系统中负责协调各对象的第三方组件在创建对象的时候进行设定，对象无需自行创建或管理它们的依赖关系，从而实现<strong>松耦合</strong>。而且如果一个对象只通过接口（而非具体实现）来表明依赖关系，则这种依赖就能在对象本身无感知的情况下，用不同的具体实现进行替换。</p>
<p>创建应用组件之间协作的行为称为<strong>装配</strong>。Spring 有多种装配 bean 的方式，其中使用 XML 配置文件是一种常见的装配方式。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- knignt.xml  --&gt;</span></span><br><span class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> </span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans-4.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注入Quest bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"knight"</span> <span class="attr">class</span>=<span class="string">"com.war.knights.BravaKnight"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"quest"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 创建SavaGirlQuest bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"quest"</span> <span class="attr">class</span>=<span class="string">"com.war.knights.SavaGirlQuest"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"Mary"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Spring 也支持使用 <strong>Java 注解</strong> 来描述配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">import com.war.knights.Knight;</span><br><span class="line">import com.war.knights.BraveKnight;</span><br><span class="line">import com.war.knights.Quest;</span><br><span class="line">import com.war.knights.SaveGirlQuest;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class KnightConfig&#123;</span><br><span class="line">	@Bean</span><br><span class="line">	public Knight knight()&#123;</span><br><span class="line">		return new BraveKnignt(quest());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Bean</span><br><span class="line">	public Quest quest()&#123;</span><br><span class="line">		return new SaveGirlQuest(&quot;Mary&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Spring 通过应用上下文（Application Context）装载 bean 的定义并把它们组装起来。Spring 有多种应用上下文的实现，主要区别在于用何种方式加载配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 使用上下文加载配置文件并读取bean</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">public class KnightMain&#123;</span><br><span class="line">	public static void main(String[] args) throws Exception&#123;</span><br><span class="line">		// 加载上下文</span><br><span class="line">		ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;META-INF/spring/knight.xml&quot;);</span><br><span class="line">		// 获取 knight bean</span><br><span class="line">		Knight knight = context.getBean(Knight.class);</span><br><span class="line">		// 使用 knight</span><br><span class="line">		knight.embarkOnQuest();</span><br><span class="line">		context.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main() 方法基于 knight.xml 文件创建了 Spring 应用上下文，并调用上下文获取了 ID 为 knight 的 bean。注意：该类完全不知道骑士接受何种探险任务，而且完全没有意识到是由 BraveKnight 来执行的，只有 knight.xml 知道哪个骑士执行哪种探险任务。</p>
<h1 id="面向切面编程（AOP）"><a href="#面向切面编程（AOP）" class="headerlink" title="面向切面编程（AOP）"></a>面向切面编程（AOP）</h1><p>DI 能够让相互协作的软件实体保持松耦合，而 AOP 则允许把遍布应用组件各处的系统职责从组件中分离出来。</p>
<p>系统由不同组件组成，每个组件负责一块特定功能。除了实现自身核心的功能外，这些组件还经常承担着额外职责（诸如日志、事务管理、安全等，这些额外的职责经常融入到自身具有核心业务逻辑的组件中去）。<br>这些需额外承担的系统服务被称为<strong>横切关注点</strong>，因为它们会跨越系统的多个组件。</p>
<p>如果按照传统方式把这些关注点分散到多个组件中去，则代码会有双重的复杂性：</p>
<ul>
<li>实现系统关注点功能的代码重复出现在多个组件中（即使把关注点抽象为了一个独立模块，其他模块只是调用其方法，但方法的调用还是会重复出现在各个模块中）。</li>
<li>组件会因为那些与自身核心业务逻辑无关的代码而变得混乱。</li>
</ul>
<p>AOP 能够使这些服务模块化，并以声明的方式把它们应用到它们需要影响的组件中去。这样做的好处在于：这些组件会具有更高的内聚性与简单性（组件甚至不知道系统服务的存在）。</p>
<p>下列 xml 文件使用了 Spring 的 aop 配置把 minstrel bean 声明为一个切面，以及声明 minstrel bean 的 embarkOnQuest 方法作为切点，并声明了切点执行时的前置方法与后置方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; </span><br><span class="line">	xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; </span><br><span class="line">	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans </span><br><span class="line">       http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</span><br><span class="line">       http://www.springframework.org/schema/aop</span><br><span class="line">       http://www.springframework.org/schema/aop/spring-aop-4.0.xsd&quot;&gt;</span><br><span class="line">&lt;!-- 声明 minstrel --&gt;</span><br><span class="line">&lt;bean id=&quot;minstrel&quot; class=&quot;com.war.knights.Minstrel&quot;&gt;</span><br><span class="line">	&lt;constructor-arg ref=&quot;a common minstrel&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">	&lt;aop:aspect ref=&quot;minstrel&quot;&gt;</span><br><span class="line">		&lt;!-- 定义切点 --&gt;</span><br><span class="line">		&lt;aop:pointcut id=&quot;embark&quot; expression=&quot;execution(* *.embarkOnQuest(..))&quot;/&gt;</span><br><span class="line">		&lt;!-- 声明前置通知 --&gt;</span><br><span class="line">		&lt;aop:before pointcut-ref=&quot;embark&quot; method=&quot;singBeforeQuest&quot;/&gt;</span><br><span class="line">		&lt;!-- 声明后置通知 --&gt;</span><br><span class="line">		&lt;aop:after pointcut-ref=&quot;embark&quot; method=&quot;singAfterQuest&quot;/&gt;</span><br><span class="line">	&lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<h1 id="Spring-容器"><a href="#Spring-容器" class="headerlink" title="Spring 容器"></a>Spring 容器</h1><p>在基于 Spring 的应用中，应用对象生存于 Spring 容器中。Spring 容器负责创建、装配和配置对象，并管理它们的整个生命周期。Spring 容器使用 DI 管理构成应用的组件，它会创建相互协作的组件之间的关联。</p>
<p>Spring 自带了两种类型的容器实现：</p>
<ul>
<li>BeanFactory（bean 工厂）：最简单的容器，提供基本的 DI 支持。</li>
<li>Application Context（应用上下文）：基于 BeanFactory 构建，并提供应用框架级别的服务。开发者一般使用应用上下文而非底层的 bean 工厂。</li>
</ul>
<h2 id="应用上下文"><a href="#应用上下文" class="headerlink" title="应用上下文"></a>应用上下文</h2><p>Spring 自带了多种类型的应用上下文：</p>
<ul>
<li>AnnotationConfigApplicationContext：从一个或多个基于 Java 的配置类中加载 Spring 应用上下文</li>
<li>AnnotationConfigWebApplicationContext：从一个或多个基于 Java 的配置类中加载 Spring Web 应用上下文</li>
<li>ClassPathXmlApplicationContext：从类路径下的一个或多个 XML 配置文件中加载上下文定义</li>
<li>FileSystemXmlapplicationcontext：从文件系统下一个或多个 XML 配置文件加载上下文定义</li>
<li>XmlWebApplicationContext：从 Web 应用下的一个或多个 XML 配置文件加载上下文定义</li>
</ul>
<p>上下文加载完毕后，就可以调用上下文的 getBean() 方法从 Spring 容器中获取 bean。</p>
<h2 id="bean-的生命周期"><a href="#bean-的生命周期" class="headerlink" title="bean 的生命周期"></a>bean 的生命周期</h2><p><img src="http://upload-images.jianshu.io/upload_images/3131012-0fdb736b21c8cc31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="bean 的生命周期"></p>
<p><strong>ApplicationContext 容器中</strong>，Bean 的生命周期流程如上图所示，流程大致如下：</p>
<ol>
<li>容器启动，对 scope 为 singleton 且非懒加载的 bean 进行实例化</li>
<li>按照 Bean 定义信息配置信息，注入所有的属性</li>
<li>如果 Bean 实现了 BeanNameAware 接口，会回调该接口的 setBeanName() 方法，传入该 Bean 的 id ，此时该 Bean 就获得了自己在配置文件中的 id</li>
<li>如果 Bean 实现了 BeanFactoryAware 接口,会回调该接口的 setBeanFactory() 方法，传入该 Bean 的 BeanFactory ，这样该 Bean 就获得了自己所在的 BeanFactory</li>
<li>如果 Bean 实现了 ApplicationContextAware 接口,会回调该接口的 setApplicationContext() 方法，传入该 Bean 的 ApplicationContext，这样该 Bean 就获得了自己所在的 ApplicationContext</li>
<li>如果 Bean 实现了 BeanPostProcessor 接口，则会回调该接口的 postProcessBeforeInitialzation() 方法</li>
<li>如果 Bean 实现了 InitializingBean 接口，则会回调该接口的 afterPropertiesSet() 方法</li>
<li>如果 Bean 配置了 init-method 方法，则会执行 init-method 配置的方法</li>
<li>如果 Bean 实现了 BeanPostProcessor 接口，则会回调该接口的 postProcessAfterInitialization() 方法</li>
<li>经过流程9之后，就可以正式使用该 Bean 了。对于 scope 为 singleton 的 Bean，Spring 的 IOC 容器中会缓存一份该 bean 的实例，而对于 scope 为 prototype 的 Bean，每次被调用都会 new 一个新的对象，其生命周期就交给调用方管理了，不再由 Spring 容器进行管理了</li>
<li>容器关闭后，如果 Bean 实现了 DisposableBean 接口，则会回调该接口的 destroy() 方法</li>
<li>如果 Bean 配置了 destroy-method 方法，则会执行 destroy-method 配置的方法。至此，整个Bean的生命周期结束</li>
</ol>
<h1 id="Spring-其他模块"><a href="#Spring-其他模块" class="headerlink" title="Spring 其他模块"></a>Spring 其他模块</h1><p>Spring 框架除了 DI 与 AOP 以外还有着其他大量模块，所有模块共同组成了一个构建在 Spring 核心框架之上的庞大生态圈。这些模块依据其所属功能可划分为六类。</p>
<h3 id="Spring-容器-1"><a href="#Spring-容器-1" class="headerlink" title="Spring 容器"></a>Spring 容器</h3><p>容器是 Spring 框架最核心的部分，用于执行 bean 的创建、配置与管理。该模块包括了 bean 工厂，它为 Spring 提供了 DI 的功能。基于 bean 工厂，还有多种 Spring 应用上下文的实现，每一种都提供了配置 Spring 的不同方式。</p>
<h3 id="AOP-模块"><a href="#AOP-模块" class="headerlink" title="AOP 模块"></a>AOP 模块</h3><p>AOP 可以把遍布系统的关注点（如事务和安全）从它们所应用的对象中解耦出来。</p>
<h3 id="数据访问和集成"><a href="#数据访问和集成" class="headerlink" title="数据访问和集成"></a>数据访问和集成</h3><p>提供了模板化的 JDBC，并在多种数据库服务的错误信息上构建了语义丰富的异常层。以及允许使用 ORM 框架。</p>
<h3 id="Web-与远程调用"><a href="#Web-与远程调用" class="headerlink" title="Web 与远程调用"></a>Web 与远程调用</h3><p>Web 与远程调用模块提供了自带的 MVC 框架，此外还提供了多种构建与其他应用交互的远程调用方案，以及对 REST API 的良好支持。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>提供了自带的测试模块（如一系列的 mock 对象实现）</p>
<hr>
<ul>
<li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p>
</li>
<li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p>
</li>
</ul>
<h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p>
<blockquote>
<p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p>
</blockquote>
<blockquote>
<p>体育&amp;户外用品推荐</p>
</blockquote>
<div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/se-notes/Java基础/Spring概述/../../../more/ads/amazon.gif" width="100%"></a> </div>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/se-notes/Java基础/Spring概述/">
    <time datetime="2019-01-03T13:49:30.000Z" class="entry-date">
        1月 3 2019
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/编程语言/">编程语言</a>, <a class="article-category-link" href="/categories/编程语言/java/">java</a>
  </div>

    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java基础/">java基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java语法/">java语法</a></li></ul>

    </footer>
</article>






  
    <article id="post-se-notes/Java基础/Java-Servlet" class="post-se-notes/Java基础/Java-Servlet post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/se-notes/Java基础/Java-Servlet/">Java-Servlet</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://wnhby.github.io/se-notes/Java基础/Java-Servlet/" data-id="cjsbez09f002wczs6rl8du2ib" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <!-- TOC -->
<ul>
<li><a href="#简介">简介</a></li>
<li><a href="#生命周期">生命周期</a><pre><code>- [init() 方法](#init-方法)
- [service() 方法](#service-方法)
- [destroy() 方法](#destroy-方法)
- [一个典型的 Servlet 生命周期图](#一个典型的-servlet-生命周期图)
</code></pre></li>
<li><a href="#面试题">面试题</a><pre><code>- [Servlet 和 GCI 的区别](#servlet-和-gci-的区别)
- [Servlet 生命周期](#servlet-生命周期)
- [Servle 和 JSP 的区别](#servle-和-jsp-的区别)
- [JSP有哪些内置对象？作用是什么？](#jsp有哪些内置对象作用是什么)
- [JSP有哪些基本动作？作用是什么？](#jsp有哪些基本动作作用是什么)
- [JSP 中动态 INCLUDE 与静态 INCLUDE 的区别？](#jsp-中动态-include-与静态-include-的区别)
- [四种会话跟踪技术作用域](#四种会话跟踪技术作用域)
</code></pre></li>
<li><a href="#参考文档">参考文档</a><pre><code>- [Ads](#ads)
</code></pre></li>
</ul>
<!-- /TOC -->
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Java Servlet 是运行在 Web 服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。</p>
<p>Servlet 架构如下所示：</p>
<p><img src="http://www.runoob.com/wp-content/uploads/2014/07/servlet-arch.jpg" alt="Servlet架构"></p>
<p>Servlet 执行以下主要任务：</p>
<ul>
<li>读取客户端（浏览器）发送的数据</li>
<li>处理数据并生成响应结果（该过程可能需要访问数据库等操作）</li>
<li>发送响应数据到客户端（浏览器）</li>
</ul>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>Servlet 生命周期可被定义为从创建直到毁灭的整个过程：</p>
<ul>
<li>Servlet 通过调用 init () 方法进行初始化。</li>
<li>Servlet 调用 service() 方法来处理客户端的请求。</li>
<li>Servlet 通过调用 destroy() 方法终止。</li>
<li>Servlet 最后由 JVM 的垃圾回收器进行垃圾回收。</li>
</ul>
<h3 id="init-方法"><a href="#init-方法" class="headerlink" title="init() 方法"></a>init() 方法</h3><p>init 方法只能调用一次。它在第一次创建 Servlet 时被调用，在后续每次用户请求时不再调用。当用户调用一个 Servlet 时，就会创建一个 Servlet 实例，每一个用户请求都会产生一个新的线程，适当的时候移交给 doGet 或 doPost 方法。</p>
<blockquote>
<p>init() 方法简单地创建或加载一些数据，这些数据将被用于 Servlet 的整个生命周期。</p>
</blockquote>
<h3 id="service-方法"><a href="#service-方法" class="headerlink" title="service() 方法"></a>service() 方法</h3><p>service() 方法是执行实际任务的主要方法。Servlet 容器（即 Web 服务器）调用 service() 方法来处理来自客户端（浏览器）的请求，并把格式化的响应写回给客户端。</p>
<p>每次服务器接收到一个 Servlet 请求时，服务器会产生一个新的线程并调用服务。service() 方法检查 HTTP 请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用 doGet、doPost、doPut，doDelete 等方法。</p>
<blockquote>
<p>service() 方法由容器调用，service 方法在适当的时候调用 doGet、doPost、doPut、doDelete 等方法。所以，开发者一般不用对 service() 方法做任何动作，只需要根据来自客户端的请求类型来重写 doGet() 或 doPost() 即可。</p>
</blockquote>
<h3 id="destroy-方法"><a href="#destroy-方法" class="headerlink" title="destroy() 方法"></a>destroy() 方法</h3><p>destroy() 方法只会被调用一次，在 Servlet 生命周期结束时被调用。destroy() 方法可以让 Servlet 关闭数据库连接、停止后台线程等清理活动。</p>
<h3 id="一个典型的-Servlet-生命周期图"><a href="#一个典型的-Servlet-生命周期图" class="headerlink" title="一个典型的 Servlet 生命周期图"></a>一个典型的 Servlet 生命周期图</h3><p><img src="http://www.runoob.com/wp-content/uploads/2014/07/Servlet-LifeCycle.jpg" alt="生命周期图"></p>
<ul>
<li>第一个到达服务器的 HTTP 请求被委派到 Servlet 容器。</li>
<li>Servlet 容器在调用 service() 方法之前加载 Servlet。</li>
<li>然后 Servlet 容器处理由多个线程产生的多个请求，每个线程执行一个单一的 Servlet 实例的 service() 方法。</li>
</ul>
<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h3 id="Servlet-和-GCI-的区别"><a href="#Servlet-和-GCI-的区别" class="headerlink" title="Servlet 和 GCI 的区别"></a>Servlet 和 GCI 的区别</h3><p>Servlet 是基于 Java 编写的，处于服务器进程中，它能够通过多线程方式运行 service() 方法，一个实例可以服务于多个请求，而且一般不会销毁；而 CGI 对每个请求都生产新的进程，服务完成后销毁，所以从效率上低于 Servlet。</p>
<h3 id="Servlet-生命周期"><a href="#Servlet-生命周期" class="headerlink" title="Servlet 生命周期"></a>Servlet 生命周期</h3><p>Servlet生命周期包括三部分：</p>
<ul>
<li>初始化：Web 容器加载 servlet，调用 init() 方法</li>
<li>处理请求：当请求到达时，运行其 service() 方法。service() 自动派遣运行与请求相对应的 doXXX（doGet 或者 doPost）方法。</li>
<li>销毁：服务结束，Web 容器会调用 servlet 的 distroy() 方法销毁 servlet。</li>
</ul>
<h3 id="Servle-和-JSP-的区别"><a href="#Servle-和-JSP-的区别" class="headerlink" title="Servle 和 JSP 的区别"></a>Servle 和 JSP 的区别</h3><p>服务器端有一个 JSP 容器，主要处理 JSP 页面请求，容器首先把 JSP 转成一个 Servlet，所有的 JSP 元素都会被转换为 Java 代码，然后编译这个 Servlet 类。</p>
<p>Servlet 和 JSP 最主要的不同点在于，Servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 HTML 里分离开来。而 JSP 的情况是 Java 和 HTML 可以组合成一个扩展名为 .jsp 的文件。JSP 侧重于视图，Servlet 主要用于控制逻辑。</p>
<h3 id="JSP有哪些内置对象？作用是什么？"><a href="#JSP有哪些内置对象？作用是什么？" class="headerlink" title="JSP有哪些内置对象？作用是什么？"></a>JSP有哪些内置对象？作用是什么？</h3><p>JSP 共有以下 9 种基本内置组件：</p>
<table>
<thead>
<tr>
<th></th>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>request</td>
<td>包含用户端请求的信息</td>
<td></td>
</tr>
<tr>
<td></td>
<td>response</td>
<td>包含服务器传回客户端的响应信息</td>
<td></td>
</tr>
<tr>
<td></td>
<td>page</td>
<td>网页本身</td>
<td></td>
</tr>
<tr>
<td></td>
<td>pageContext</td>
<td>管理网页属性</td>
<td></td>
</tr>
<tr>
<td></td>
<td>session</td>
<td>与请求有关的会话</td>
<td></td>
</tr>
<tr>
<td></td>
<td>application</td>
<td>伴随服务器的生命周期，为多个应用程序保存信息</td>
<td></td>
</tr>
<tr>
<td></td>
<td>out</td>
<td>向客户端输出数据</td>
<td></td>
</tr>
<tr>
<td></td>
<td>config</td>
<td>servlet的架构部件</td>
<td></td>
</tr>
<tr>
<td></td>
<td>exception</td>
<td>针对错误页面才可使用</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="JSP有哪些基本动作？作用是什么？"><a href="#JSP有哪些基本动作？作用是什么？" class="headerlink" title="JSP有哪些基本动作？作用是什么？"></a>JSP有哪些基本动作？作用是什么？</h3><ul>
<li>jsp:include：在页面被请求的时候引入一个文件。 </li>
<li>jsp:useBean：寻找或者实例化一个JavaBean。 </li>
<li>jsp:setProperty：设置 JavaBean 的属性。</li>
<li>jsp:getProperty：输出某个 JavaBean 的属性。 </li>
<li>jsp:forward：把请求转到一个新的页面。</li>
<li>jsp:plugin：根据浏览器类型为 Java 插件生成 OBJECT 或 EMBED 标记</li>
</ul>
<h3 id="JSP-中动态-INCLUDE-与静态-INCLUDE-的区别？"><a href="#JSP-中动态-INCLUDE-与静态-INCLUDE-的区别？" class="headerlink" title="JSP 中动态 INCLUDE 与静态 INCLUDE 的区别？"></a>JSP 中动态 INCLUDE 与静态 INCLUDE 的区别？</h3><p>动态 INCLUDE 用 jsp:include 动作实现，它总是会检查所含文件中的变化，适合用于包含动态页面，并且可以带参数；静态 INCLUDE 用 include 伪码实现，不会检查所含文件的变化，适用于包含静态页面。</p>
<h3 id="四种会话跟踪技术作用域"><a href="#四种会话跟踪技术作用域" class="headerlink" title="四种会话跟踪技术作用域"></a>四种会话跟踪技术作用域</h3><ul>
<li>page：一个页面</li>
<li>request：：一次请求，一个请求可能跨越多个 page</li>
<li>session：一次会话，一个会话可能跨越多个 request</li>
<li>application：代表与整个 Web 应用程序相关的对象和属性，跨越了整个 Web 应用程序。</li>
</ul>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="http://www.runoob.com/servlet/servlet-tutorial.html" target="_blank" rel="noopener">Servlet 教程</a></p>
<hr>
<ul>
<li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p>
</li>
<li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p>
</li>
</ul>
<h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p>
<blockquote>
<p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p>
</blockquote>
<blockquote>
<p>体育&amp;户外用品推荐</p>
</blockquote>
<div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/se-notes/Java基础/Java-Servlet/../../../more/ads/amazon.gif" width="100%"></a> </div>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/se-notes/Java基础/Java-Servlet/">
    <time datetime="2019-01-03T13:49:30.000Z" class="entry-date">
        1月 3 2019
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/编程语言/">编程语言</a>, <a class="article-category-link" href="/categories/编程语言/java/">java</a>
  </div>

    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java基础/">java基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java语法/">java语法</a></li></ul>

    </footer>
</article>






  
    <article id="post-se-notes/Java基础/泛型" class="post-se-notes/Java基础/泛型 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/se-notes/Java基础/泛型/">泛型</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://wnhby.github.io/se-notes/Java基础/泛型/" data-id="cjsbez09v003eczs6xt2kcom9" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <!-- TOC -->
<ul>
<li><a href="#泛型">泛型</a><ul>
<li><a href="#泛型类和泛型方法">泛型类和泛型方法</a></li>
<li><a href="#原始类型和向后兼容">原始类型和向后兼容</a></li>
<li><a href="#通配泛型">通配泛型</a></li>
<li><a href="#消除泛型与使用泛型的限制">消除泛型与使用泛型的限制</a></li>
<li><a href="#备注">备注</a><ul>
<li><a href="#ads">Ads</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>泛型是指参数化类型的能力。定义了带泛型类型的类或方法，在编译过程中编译器会用具体类型替换它。主要优点在于能够在编译时而不是在运行时检测出错误。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 使用泛型前 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(object o)</span></span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用泛型后 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型类和泛型方法"><a href="#泛型类和泛型方法" class="headerlink" title="泛型类和泛型方法"></a>泛型类和泛型方法</h2><ul>
<li>为了定义一个类为泛型类型，需要将泛型类型放在类名之后，如：<code>GenericStack&lt;E&gt;</code>。</li>
<li>受限泛型类型：可将泛型制定为另外一种类型的子类型。如：<code>&lt;E extends GeometricObject&gt;</code>。</li>
<li>为了定义一个方法为泛型类型，需要把泛型类型放在方法返回类型之前，如<code>&lt;E&gt; void max(E o1,E o2)</code>。</li>
<li>为了调用泛型方法，需要将实际类型放在尖括号内作为方法名的前缀，如<code>GenericStack.&lt;String&gt;print(strings)</code>。</li>
</ul>
<h2 id="原始类型和向后兼容"><a href="#原始类型和向后兼容" class="headerlink" title="原始类型和向后兼容"></a>原始类型和向后兼容</h2><ul>
<li><strong>使用</strong>泛型类时可以无需指定具体类型，如：<code>GenericStack stack = new GenericStack();</code>，其大体等价于<code>GenericStack&lt;Object&gt; stack = new GenericStack&lt;Object&gt;();</code>。</li>
<li>像 GenericStack 和 ArrayList 这样不使用类型参数的泛型类称为”原始类型“。</li>
<li>原始类型并不安全，但使用原始类型是为了向后兼容 JDK 较早的版本。</li>
</ul>
<h2 id="通配泛型"><a href="#通配泛型" class="headerlink" title="通配泛型"></a>通配泛型</h2><ul>
<li>尽管 Integer 是 Number 的子类型，但是 <code>GenericStack&lt;Interger&gt;</code>并不是<code>GenericStack&lt;Number&gt;</code>的子类型。为了避免该问题，可以使用通配泛型类型。</li>
<li>通配泛型有三种形式<code>?</code>、<code>? extends T</code>和<code>? super T</code>（此处的T代表某个泛型类型）：<ul>
<li><code>?</code>：称为非受限通配，等价于<code>? extends Object</code>。</li>
<li><code>? extends T</code>：称为受限通配，代表T的一个未知子类型。</li>
<li><code>? super T</code>：称为下限通配，表示T的一个未知父类型。</li>
</ul>
</li>
</ul>
<h2 id="消除泛型与使用泛型的限制"><a href="#消除泛型与使用泛型的限制" class="headerlink" title="消除泛型与使用泛型的限制"></a>消除泛型与使用泛型的限制</h2><p>泛型是使用一种称为类型消除的方法来实现的：在编译时一旦编译器确认泛型类型是安全的，就会将它转换为原始类型。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*编译器转换前*/</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"Trump"</span>);</span><br><span class="line">String state = list.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*编译器转换后*/</span></span><br><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">"Trump"</span>);</span><br><span class="line">String state = (String)(list.get(<span class="number">0</span>));</span><br></pre></td></tr></table></figure></p>
<p>由于泛型在运行时已被消除，因此对于如何使用泛型类型是有一些限制的：</p>
<ul>
<li>不能使用<code>new E()</code>。</li>
<li>不能使用<code>new E[]</code>。</li>
<li>在静态环境下不允许类的参数是泛型类型。</li>
<li>异常类不能是泛型的。</li>
</ul>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><ul>
<li>泛型类型必须是引用类型</li>
<li>尽管在编译时<code>ArrayList&lt;String&gt;</code>与<code>ArrayList&lt;Integer&gt;</code>是两种类型，但是在运行时只有一个 ArrayList 类会被加载到 JVM 中</li>
</ul>
<hr>
<ul>
<li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p>
</li>
<li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p>
</li>
</ul>
<h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p>
<blockquote>
<p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p>
</blockquote>
<blockquote>
<p>体育&amp;户外用品推荐</p>
</blockquote>
<div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/se-notes/Java基础/泛型/../../../more/ads/amazon.gif" width="100%"></a> </div>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/se-notes/Java基础/泛型/">
    <time datetime="2019-01-03T13:49:30.000Z" class="entry-date">
        1月 3 2019
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/编程语言/">编程语言</a>, <a class="article-category-link" href="/categories/编程语言/java/">java</a>
  </div>

    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java基础/">java基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java语法/">java语法</a></li></ul>

    </footer>
</article>






  
    <article id="post-se-notes/Java基础/设计模式——单例模式" class="post-se-notes/Java基础/设计模式——单例模式 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/se-notes/Java基础/设计模式——单例模式/">设计模式——单例模式</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://wnhby.github.io/se-notes/Java基础/设计模式——单例模式/" data-id="cjsbez09y003iczs6wzq3xpwl" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <!-- TOC -->
<ul>
<li><a href="#单例模式">单例模式</a><ul>
<li><a href="#遇到的问题">遇到的问题</a></li>
<li><a href="#饿汉式单例">饿汉式单例</a></li>
<li><a href="#懒汉式单例">懒汉式单例</a></li>
<li><a href="#两种单例实现方式比较">两种单例实现方式比较</a></li>
<li><a href="#一种更好的单例实现方法iodh">一种更好的单例实现方法——IoDH</a></li>
<li><a href="#单例模式总结">单例模式总结</a><ul>
<li><a href="#ads">Ads</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>在实际开发中，我们经常遇到这种情况：为了节约系统资源，有时需要确保系统中某个类只有唯一一个实例，当这个唯一实例创建成功之后，我们无法再创建一个同类型的其他对象，所有的操作都只能基于这个唯一实例。为了确保对象的唯一性，我们可以通过单例模式来实现。</p>
<p>单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，则这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。</p>
<p><img src="http://my.csdn.net/uploads/201204/02/1333305124_9327.gif" alt="单例模式结构图"></p>
<p>单例模式结构图中只包含一个单例角色：</p>
<ul>
<li>Singleton（单例）：在单例类的内部实现只生成一个实例，同时它提供一个静态的 getInstance() 工厂方法，让客户可以访问它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有；在单例类内部定义了一个 Singleton 类型的静态对象，作为外部共享的唯一实例。</li>
</ul>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>一个负载均衡器作为单例设计如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;  </span><br><span class="line"></span><br><span class="line">//负载均衡器LoadBalancer：单例类，真实环境下该类将非常复杂，包括大量初始化的工作和业务方法，考虑到代码的可读性和易理解性，只列出部分与模式相关的核心代码  </span><br><span class="line">class LoadBalancer &#123;  </span><br><span class="line">    //私有静态成员变量，存储唯一实例  </span><br><span class="line">    private static LoadBalancer instance = null;  </span><br><span class="line">    //服务器集合  </span><br><span class="line">    private List serverList = null;  </span><br><span class="line"></span><br><span class="line">    //私有构造函数  </span><br><span class="line">    private LoadBalancer() &#123;  </span><br><span class="line">        serverList = new ArrayList();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    //公有静态成员方法，返回唯一实例  </span><br><span class="line">    public static LoadBalancer getLoadBalancer() &#123;  </span><br><span class="line">        if (instance == null) &#123;  </span><br><span class="line">            instance = new LoadBalancer();  </span><br><span class="line">        &#125;  </span><br><span class="line">        return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    //增加服务器  </span><br><span class="line">    public void addServer(String server) &#123;  </span><br><span class="line">        serverList.add(server);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    //删除服务器  </span><br><span class="line">    public void removeServer(String server) &#123;  </span><br><span class="line">        serverList.remove(server);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    //使用Random类随机获取服务器  </span><br><span class="line">    public String getServer() &#123;  </span><br><span class="line">        Random random = new Random();  </span><br><span class="line">        int i = random.nextInt(serverList.size());  </span><br><span class="line">        return (String)serverList.get(i);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用单例模式实现了如上的负载均衡器的设计，但是在实际使用中出现了一个非常严重的问题，当负载均衡器在启动过程中用户再次启动该负载均衡器时，系统无任何异常，但当客户端提交请求时出现请求分发失败，通过仔细分析发现原来系统中还是存在多个负载均衡器对象，导致分发时目标服务器不一致，从而产生冲突。</p>
<p>现在我们对负载均衡器的实现代码进行再次分析，当第一次调用 getLoadBalancer() 方法创建并启动负载均衡器时，instance 对象为 null 值，因此系统将执行代码 instance= new LoadBalancer()，在此过程中，由于要对 LoadBalancer 进行大量初始化工作，需要一段时间来创建 LoadBalancer 对象。而在此时，如果再一次调用 getLoadBalancer() 方法（通常发生在多线程环境中），由于 instance 尚未创建成功，仍为 null 值，判断条件 (instance== null) 为真值，因此代码 instance= new LoadBalancer() 将再次执行，导致最终创建了多个 instance 对象，这违背了单例模式的初衷，也导致系统运行发生错误。</p>
<h2 id="饿汉式单例"><a href="#饿汉式单例" class="headerlink" title="饿汉式单例"></a>饿汉式单例</h2><p><img src="http://my.csdn.net/uploads/201204/02/1333305889_1823.gif" alt="enter image description here"></p>
<p>在定义静态变量的时候实例化单例类，因此在类加载的时候就已经创建了单例对象，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class EagerSingleton &#123;   </span><br><span class="line">    private static final EagerSingleton instance = new EagerSingleton();   </span><br><span class="line">    private EagerSingleton() &#123; &#125;   </span><br><span class="line"></span><br><span class="line">    public static EagerSingleton getInstance() &#123;  </span><br><span class="line">        return instance;   </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当类被加载时，静态变量 instance 会被初始化，此时类的私有构造函数会被调用，单例类的唯一实例将被创建。如果使用饿汉式单例来实现负载均衡器 LoadBalancer 类的设计，则不会出现创建多个单例对象的情况，可确保单例对象的唯一性。</p>
<h2 id="懒汉式单例"><a href="#懒汉式单例" class="headerlink" title="懒汉式单例"></a>懒汉式单例</h2><p><img src="http://my.csdn.net/uploads/201204/02/1333305983_8045.gif" alt="enter image description here"></p>
<p>懒汉式单例在第一次调用 getInstance() 方法时实例化，在类加载时并不自行实例化，这种技术又称为延迟加载(Lazy Load)技术，即需要的时候再加载实例。为了避免多个线程同时调用 getInstance() 方法，我们可以使用关键字 synchronized ，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class LazySingleton &#123;   </span><br><span class="line">    private static LazySingleton instance = null;   </span><br><span class="line"></span><br><span class="line">    private LazySingleton() &#123; &#125;   </span><br><span class="line"></span><br><span class="line">    synchronized public static LazySingleton getInstance() &#123;   </span><br><span class="line">        if (instance == null) &#123;  </span><br><span class="line">            instance = new LazySingleton();   </span><br><span class="line">        &#125;  </span><br><span class="line">        return instance;   </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该懒汉式单例类在 getInstance() 方法前面增加了关键字 synchronized 进行线程锁，以处理多个线程同时访问的问题。上述代码虽然解决了线程安全问题，但是每次调用 getInstance() 时都需要进行线程锁定判断，在多线程高并发访问环境中，将会导致系统性能大大降低。如何既解决线程安全问题又不影响系统性能呢？我们继续对懒汉式单例进行改进。事实上，我们无须对整个 getInstance() 方法进行锁定，只需对其中的代码 “instance = new LazySingleton();” 进行锁定即可。因此 getInstance() 方法可以进行如下改进：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static LazySingleton getInstance() &#123;   </span><br><span class="line">    if (instance == null) &#123;  </span><br><span class="line">        synchronized (LazySingleton.class) &#123;  </span><br><span class="line">            instance = new LazySingleton();   </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return instance;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题貌似得以解决，事实并非如此。如果使用以上代码来实现单例，还是会存在单例对象不唯一。原因如下：</p>
<p>假如在某一瞬间线程A和线程B都在调用 getInstance() 方法，此时 instance 对象为 null 值，均能通过 instance == null 的判断。由于实现了 synchronized 加锁机制，线程A进入 synchronized 锁定的代码中执行实例创建代码，线程B处于排队等待状态，必须等待线程A执行完毕后才可以进入 synchronized 锁定代码。但当A执行完毕时，线程B并不知道实例已经创建，将继续创建新的实例，导致产生多个单例对象，违背单例模式的设计思想。因此需要进行进一步改进，在 synchronized 中再进行一次 (instance == null) 判断，这种方式称为双重检查锁定(Double-Check Locking)。使用双重检查锁定实现的懒汉式单例类完整代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class LazySingleton &#123;   </span><br><span class="line">    private volatile static LazySingleton instance = null;   </span><br><span class="line"></span><br><span class="line">    private LazySingleton() &#123; &#125;   </span><br><span class="line"></span><br><span class="line">    public static LazySingleton getInstance() &#123;   </span><br><span class="line">        //第一重判断  </span><br><span class="line">        if (instance == null) &#123;  </span><br><span class="line">            //锁定代码块  </span><br><span class="line">            synchronized (LazySingleton.class) &#123;  </span><br><span class="line">                //第二重判断  </span><br><span class="line">                if (instance == null) &#123;  </span><br><span class="line">                    instance = new LazySingleton(); //创建单例实例  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return instance;   </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，如果使用双重检查锁定来实现懒汉式单例类，需要在静态成员变量 instance 之前增加修饰符 volatile ，被 volatile 修饰的成员变量可以确保多个线程都能够正确处理，且该代码只能在 JDK 1.5 及以上版本中才能正确执行。由于 volatile 关键字会屏蔽 JVM 所做的一些代码优化，可能会导致系统运行效率降低，因此即使使用双重检查锁定来实现单例模式也不是一种完美的实现方式。</p>
</blockquote>
<h2 id="两种单例实现方式比较"><a href="#两种单例实现方式比较" class="headerlink" title="两种单例实现方式比较"></a>两种单例实现方式比较</h2><p>饿汉式单例类在类被加载时就将自己实例化，它的优点在于无须考虑多线程访问问题，可以确保实例的唯一性；从调用速度和反应时间角度来讲，由于单例对象一开始就得以创建，因此要优于懒汉式单例。但是无论系统在运行时是否需要使用该单例对象，由于在类加载时该对象就需要创建，因此从资源利用效率角度来讲，饿汉式单例不及懒汉式单例，而且在系统加载时由于需要创建饿汉式单例对象，加载时间可能会比较长。</p>
<p>懒汉式单例类在第一次使用时创建，无须一直占用系统资源，实现了延迟加载，但是必须处理好多个线程同时访问的问题，特别是当单例类作为资源控制器，在实例化时必然涉及资源初始化，而资源初始化很有可能耗费大量时间，这意味着出现多线程同时首次引用此类的机率变得较大，需要通过双重检查锁定等机制进行控制，这将导致系统性能受到一定影响。</p>
<h2 id="一种更好的单例实现方法——IoDH"><a href="#一种更好的单例实现方法——IoDH" class="headerlink" title="一种更好的单例实现方法——IoDH"></a>一种更好的单例实现方法——IoDH</h2><p>饿汉式单例类不能实现延迟加载，不管将来用不用始终占据内存；懒汉式单例类线程安全控制烦琐，而且性能受影响。Initialization Demand Holder (IoDH) 可以克服这两个缺点。</p>
<p>在 IoDH 中，我们在单例类中增加一个静态内部类，在该内部类中创建单例对象，再将该单例对象通过 getInstance() 方法返回给外部使用，实现代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//Initialization on Demand Holder  </span><br><span class="line">class Singleton &#123;  </span><br><span class="line">    private Singleton() &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    private static class HolderClass &#123;  </span><br><span class="line">        private final static Singleton instance = new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;  </span><br><span class="line">        return HolderClass.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    public static void main(String args[]) &#123;  </span><br><span class="line">        Singleton s1, s2;   </span><br><span class="line">            s1 = Singleton.getInstance();  </span><br><span class="line">        s2 = Singleton.getInstance();  </span><br><span class="line">        System.out.println(s1==s2);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译并运行上述代码，运行结果为：true，即创建的单例对象 s1 和 s2 为同一对象。由于静态单例对象没有作为 Singleton 的成员变量直接实例化，因此类加载时不会实例化 Singleton ，第一次调用 getInstance() 时将加载内部类 HolderClass ，在该内部类中定义了一个 static 类型的变量 instance ，此时会首先初始化这个成员变量，由 Java 虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于 getInstance() 方法没有任何线程锁定，因此其性能不会造成任何影响。</p>
<p>通过使用 IoDH，我们既可以实现延迟加载，又可以保证线程安全，不影响系统性能，不失为一种最好的 Java 语言单例模式实现方式（其缺点是与编程语言本身的特性相关，很多面向对象语言不支持IoDH）。</p>
<h2 id="单例模式总结"><a href="#单例模式总结" class="headerlink" title="单例模式总结"></a>单例模式总结</h2><p>单例模式作为一种目标明确、结构简单、理解容易的设计模式，在软件开发中使用频率相当高，在很多应用软件和框架中都得以广泛应用。</p>
<p>单例模式的主要优点如下：</p>
<ul>
<li>单例模式提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它。</li>
<li>由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。</li>
<li>允许可变数目的实例。基于单例模式我们可以进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例，既节省系统资源，又解决了单例单例对象共享过多有损性能的问题。</li>
</ul>
<p>单例模式的主要缺点如下：</p>
<ul>
<li>由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。</li>
<li>单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。</li>
<li>现在很多面向对象语言(如 Java 、C# )的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的共享对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致共享的单例对象状态的丢失。</li>
</ul>
<p>在以下情况下可以考虑使用单例模式：</p>
<ul>
<li>系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象。</li>
<li>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。</li>
</ul>
<hr>
<ul>
<li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p>
</li>
<li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p>
</li>
</ul>
<h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p>
<blockquote>
<p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p>
</blockquote>
<blockquote>
<p>体育&amp;户外用品推荐</p>
</blockquote>
<div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/se-notes/Java基础/设计模式——单例模式/../../../more/ads/amazon.gif" width="100%"></a> </div>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/se-notes/Java基础/设计模式——单例模式/">
    <time datetime="2019-01-03T13:49:30.000Z" class="entry-date">
        1月 3 2019
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/编程语言/">编程语言</a>, <a class="article-category-link" href="/categories/编程语言/java/">java</a>
  </div>

    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java基础/">java基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java语法/">java语法</a></li></ul>

    </footer>
</article>






  
    <article id="post-se-notes/Java基础/设计模式——工厂模式" class="post-se-notes/Java基础/设计模式——工厂模式 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/se-notes/Java基础/设计模式——工厂模式/">设计模式——工厂模式</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://wnhby.github.io/se-notes/Java基础/设计模式——工厂模式/" data-id="cjsbez0a0003kczs61y8ulayc" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <!-- TOC -->
<ul>
<li><a href="#简单工厂模式">简单工厂模式</a><pre><code>- [简单工厂模式总结](#简单工厂模式总结)
- [相关阅读](#相关阅读)
</code></pre></li>
<li><a href="#工厂方法模式">工厂方法模式</a><pre><code>- [工厂方法模式总结](#工厂方法模式总结)
</code></pre></li>
<li><a href="#抽象工厂模式">抽象工厂模式</a><pre><code>- [抽象工厂模式总结](#抽象工厂模式总结)
- [Ads](#ads)
</code></pre></li>
</ul>
<!-- /TOC -->
<h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p>简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。在简单工厂模式中用于创建实例的方法是静态方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。</p>
<p><img src="http://img.blog.csdn.net/20130711143612921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUxpb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="简单工厂模式结构图"></p>
<p>在简单工厂模式结构图中包含如下几个角色：</p>
<ul>
<li>Factory（工厂角色）：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法 factoryMethod()，它的返回类型为抽象产品类型 Product 。</li>
<li>Product（抽象产品角色）：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。</li>
<li>ConcreteProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。</li>
</ul>
<h3 id="简单工厂模式总结"><a href="#简单工厂模式总结" class="headerlink" title="简单工厂模式总结"></a>简单工厂模式总结</h3><p>简单工厂模式提供了专门的工厂类用于创建对象，将对象的创建和对象的使用分离开。它作为一种最简单的工厂模式在软件开发中得到了较为广泛的应用。</p>
<p>简单工厂模式的主要优点如下：</p>
<ul>
<li>实现了对象创建和使用的分离，从而让客户端可以免除直接创建产品对象的职责。这样的好处在于：<ul>
<li>降低因为产品或工厂类改变所造成的维护工作量</li>
<li>系统更加符合“单一职责原则”，防止了使用对象时的代码冗余，有利于功能复用和系统维护</li>
</ul>
</li>
<li>简化操作。客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数。</li>
<li>通过引入配置文件，可以在不修改客户端代码的情况下使用或更换已有的具体产品类，提高系统灵活性。</li>
</ul>
<p>简单工厂模式的主要缺点如下：</p>
<ul>
<li>由于工厂类集中了所有产品的创建逻辑，一旦不能正常工作，整个系统都要受到影响。</li>
<li>使用简单工厂模式会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度。</li>
<li>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，违反了<strong>开闭原则</strong>。</li>
<li>简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</li>
</ul>
<p>以下情况可以考虑使用简单工厂模式：</p>
<ul>
<li>工厂类负责创建的对象比较少，不会造成工厂方法中的业务逻辑太过复杂。</li>
<li>客户端只知道传入工厂类的参数，对于如何创建对象并不关心。</li>
</ul>
<h3 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h3><p><a href="http://blog.csdn.net/lovelion/article/details/7523392" target="_blank" rel="noopener">为何要使用工厂模式</a></p>
<h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><p>简单工厂模式存在一个很严重的问题，当系统中需要引入新产品时，由于静态工厂方法通过所传入参数的不同来创建不同的产品，这必定要修改工厂类的源代码，将违背<strong>开闭原则</strong>。因此在工厂方法模式中，不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构。</p>
<p>工厂方法模式(Factory Method Pattern)：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，是一种类创建型模式。</p>
<p><img src="http://img.blog.csdn.net/20130712101002890?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUxpb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="enter image description here"></p>
<p>在工厂方法模式结构图中包含如下几个角色：</p>
<ul>
<li>Product（抽象产品）：它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。</li>
<li>ConcreteProduct（具体产品）：它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。</li>
<li>Factory（抽象工厂）：在抽象工厂类中，声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。</li>
<li>ConcreteFactory（具体工厂）：它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。</li>
</ul>
<h3 id="工厂方法模式总结"><a href="#工厂方法模式总结" class="headerlink" title="工厂方法模式总结"></a>工厂方法模式总结</h3><p>工厂方法模式是简单工厂模式的延伸，它继承了简单工厂模式的优点，同时还弥补了简单工厂模式的不足。它是使用频率最高的设计模式之一，是很多开源框架和 API 类库的核心模式。</p>
<p>工厂方法模式的主要优点如下：</p>
<ul>
<li>在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</li>
<li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，就正是因为所有的具体工厂类都具有同一抽象父类。</li>
<li>在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样系统的可扩展性也就变得非常好，完全符合“开闭原则”。</li>
</ul>
<p>工厂方法模式的主要缺点如下：</p>
<ul>
<li>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度；有更多的类需要编译和运行，会给系统带来一些额外的开销。</li>
<li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度；且在实现时可能需要用到 DOM 、反射等技术，增加了系统的实现难度。</li>
</ul>
<p>在以下情况下可以考虑使用工厂方法模式：</p>
<ul>
<li>客户端不知道它所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建，可将具体工厂类的类名存储在配置文件或数据库中。</li>
<li>抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li>
</ul>
<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>工厂方法模式通过引入工厂等级结构，解决了简单工厂模式中工厂类职责太重的问题，但由于工厂方法模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。此时，我们可以考虑将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产。</p>
<p> 抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。</p>
<p><img src="http://img.blog.csdn.net/20130713163800203?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUxpb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="抽象工厂模式结构图"></p>
<p>在抽象工厂模式结构图中包含如下几个角色：</p>
<ul>
<li>AbstractFactory（抽象工厂）：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。</li>
<li>ConcreteFactory（具体工厂）：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。</li>
<li>AbstractProduct（抽象产品）：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。</li>
<li>ConcreteProduct（具体产品）：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。</li>
</ul>
<p>为了更好地理解抽象工厂模式，需要引入两个概念：</p>
<ul>
<li><strong>产品等级结构</strong>：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。</li>
<li><strong>产品族</strong>：产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品。如海尔电器工厂生产的海尔电视机、海尔电冰箱：海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中，海尔电视机、海尔电冰箱构成了一个产品族。</li>
</ul>
<p><img src="http://img.blog.csdn.net/20130713162941328?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUxpb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="产品族和产品等级结构"></p>
<p>当系统所提供的工厂生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构、属于不同类型的具体产品时，就可以使用抽象工厂模式。抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形式。抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、更有效率。</p>
<h3 id="抽象工厂模式总结"><a href="#抽象工厂模式总结" class="headerlink" title="抽象工厂模式总结"></a>抽象工厂模式总结</h3><p>抽象工厂模式是工厂方法模式的进一步延伸，由于它提供了功能更为强大的工厂类并且具备较好的可扩展性，在软件开发中得以广泛应用，尤其是在一些框架和API类库的设计中，例如在Java语言的AWT（抽象窗口工具包）中就使用了抽象工厂模式，它使用抽象工厂模式来实现在不同的操作系统中应用程序呈现与所在操作系统一致的外观界面。抽象工厂模式也是在软件开发中最常用的设计模式之一。</p>
<p>抽象工厂模式的主要优点如下：</p>
<ul>
<li>抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。</li>
<li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。</li>
<li>增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。</li>
</ul>
<p>抽象工厂模式的主要缺点如下：</p>
<ul>
<li>增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”。</li>
</ul>
<blockquote>
<p>在抽象工厂模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为<strong>开闭原则的倾斜性</strong>。</p>
</blockquote>
<p>在以下情况下可以考虑使用抽象工厂模式：</p>
<ul>
<li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建和使用解耦。</li>
<li>系统中有多于一个的产品族，而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族。</li>
<li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束，如同一操作系统下的按钮和文本框，按钮与文本框之间没有直接关系，但它们都是属于某一操作系统的，此时具有一个共同的约束条件：操作系统的类型。</li>
<li>产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。</li>
</ul>
<hr>
<ul>
<li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p>
</li>
<li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p>
</li>
</ul>
<h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p>
<blockquote>
<p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p>
</blockquote>
<blockquote>
<p>体育&amp;户外用品推荐</p>
</blockquote>
<div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/se-notes/Java基础/设计模式——工厂模式/../../../more/ads/amazon.gif" width="100%"></a> </div>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/se-notes/Java基础/设计模式——工厂模式/">
    <time datetime="2019-01-03T13:49:30.000Z" class="entry-date">
        1月 3 2019
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/编程语言/">编程语言</a>, <a class="article-category-link" href="/categories/编程语言/java/">java</a>
  </div>

    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java基础/">java基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java语法/">java语法</a></li></ul>

    </footer>
</article>






  
  
    <nav id="pagination">
      <nav id="page-nav">
        <span class="page-number current">1</span><a class="page-number" href="/categories/编程语言/page/2/">2</a><a class="extend next" rel="next" href="/categories/编程语言/page/2/">下一页 &raquo;</a>
      </nav>
    </nav>
  

</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="q">
        <input type="submit" id="searchsubmit" value="google搜索">
    </div>
</form></aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/系统剩余空间查看/">系统剩余空间查看</a>
          </li>
        
          <li>
            <a href="/数据库分类/">数据库分类</a>
          </li>
        
          <li>
            <a href="/se-notes/Java基础/集合框架/">集合框架</a>
          </li>
        
          <li>
            <a href="/se-notes/云计算实践/集群高可用方案/Heartbeat双机热备方案/">Heartbeat双机热备方案</a>
          </li>
        
          <li>
            <a href="/se-notes/云计算实践/集群高可用方案/HAProxy+Keepalived高可用方案/">HAProxy+Keepalived高可用方案</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Archives</h3>
    <div class="widget-content">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a><span class="archive-list-count">56</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">一月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">十一月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">一月 2014</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-content">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Graphics/">Graphics</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">7</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/Shell/">Shell</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/linux基础/">linux基础</a><span class="category-list-count">6</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/协议证书/">协议证书</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/协议证书/openssl/">openssl</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">4</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/数据库基础/">数据库基础</a><span class="category-list-count">3</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/框架/">框架</a><span class="category-list-count">9</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/框架/python-web应用框架/">python-web应用框架</a><span class="category-list-count">9</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/框架/python-web应用框架/flask/">flask</a><span class="category-list-count">9</span></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/版本控制/">版本控制</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/版本控制/Git/">Git</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程语言/">编程语言</a><span class="category-list-count">13</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/编程语言/java/">java</a><span class="category-list-count">13</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络通讯/">网络通讯</a><span class="category-list-count">11</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/网络通讯/大小端/">大小端</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络通讯/计算机网络基础/">计算机网络基础</a><span class="category-list-count">10</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/路由器/">路由器</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/路由器/openwrt/">openwrt</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/通用技术/">通用技术</a><span class="category-list-count">13</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/通用技术/Docker/">Docker</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/通用技术/云计算实践/">云计算实践</a><span class="category-list-count">11</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/通用技术/云计算实践/kubernetes部署/">kubernetes部署</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/通用技术/云计算实践/区块链/">区块链</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/通用技术/云计算实践/集群高可用方案/">集群高可用方案</a><span class="category-list-count">4</span></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/默认/">默认</a><span class="category-list-count">1</span></li></ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-content">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CS-Notes/">CS-Notes</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PEM证书/">PEM证书</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell/">Shell</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cron/">cron</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/database/">database</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/diagrams/">diagrams</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker-qq/">docker-qq</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flask/">flask</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/graphics/">graphics</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/informationisbeautiful/">informationisbeautiful</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java基础/">java基础</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java语法/">java语法</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kubernetes/">kubernetes</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network/">network</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/openssl/">openssl</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/openwrt/">openwrt</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/p12/">p12</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pfx/">pfx</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tcp-ip/">tcp/ip</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web开发/">web开发</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/云计算/">云计算</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/区块链/">区块链</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/大小端/">大小端</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/系统管理/">系统管理</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机网络/">计算机网络</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/集群/">集群</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/默认/">默认</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-content tagcloud">
      <a href="/tags/CS-Notes/" style="font-size: 10px;">CS-Notes</a> <a href="/tags/PEM证书/" style="font-size: 10px;">PEM证书</a> <a href="/tags/Shell/" style="font-size: 10px;">Shell</a> <a href="/tags/cron/" style="font-size: 10px;">cron</a> <a href="/tags/database/" style="font-size: 10px;">database</a> <a href="/tags/diagrams/" style="font-size: 10px;">diagrams</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/docker-qq/" style="font-size: 10px;">docker-qq</a> <a href="/tags/flask/" style="font-size: 16.25px;">flask</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/graphics/" style="font-size: 10px;">graphics</a> <a href="/tags/http/" style="font-size: 17.5px;">http</a> <a href="/tags/informationisbeautiful/" style="font-size: 10px;">informationisbeautiful</a> <a href="/tags/java基础/" style="font-size: 20px;">java基础</a> <a href="/tags/java语法/" style="font-size: 20px;">java语法</a> <a href="/tags/kubernetes/" style="font-size: 13.75px;">kubernetes</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/mysql/" style="font-size: 11.25px;">mysql</a> <a href="/tags/network/" style="font-size: 17.5px;">network</a> <a href="/tags/openssl/" style="font-size: 10px;">openssl</a> <a href="/tags/openwrt/" style="font-size: 10px;">openwrt</a> <a href="/tags/p12/" style="font-size: 10px;">p12</a> <a href="/tags/pfx/" style="font-size: 10px;">pfx</a> <a href="/tags/tcp-ip/" style="font-size: 17.5px;">tcp/ip</a> <a href="/tags/web开发/" style="font-size: 16.25px;">web开发</a> <a href="/tags/云计算/" style="font-size: 18.75px;">云计算</a> <a href="/tags/区块链/" style="font-size: 10px;">区块链</a> <a href="/tags/大小端/" style="font-size: 10px;">大小端</a> <a href="/tags/数据库/" style="font-size: 12.5px;">数据库</a> <a href="/tags/系统管理/" style="font-size: 15px;">系统管理</a> <a href="/tags/计算机网络/" style="font-size: 17.5px;">计算机网络</a> <a href="/tags/集群/" style="font-size: 13.75px;">集群</a> <a href="/tags/默认/" style="font-size: 10px;">默认</a>
    </div>
  </aside>

  
    <aside class="widget">
    <h3 class="widget-title">Links</h3>
    <div class="widget-content">
		<ul id="link-list">
		<!-- link begin -->

		<li><a href="https://www.google.com/">google</a></li>
		<li><a href="https://www.baidu.com/">baidu</a></li>
		
		<!-- link end -->
		</ul>
    </div>
</aside>

  
    <aside class="widget">
    <h3 class="widget-title">Ads</h3>
    <div class="widget-content">
	 
			* <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;">
			<br><br>
			* 体育&户外用品推荐>
			<div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5"><img src="/more/ads/amazon.gif" width="100%"></a> </div>

    </div>
</aside>

  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2019 momoda
    All rights reserved.</p>
    <p>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></p>
    <a href="javascript:scrollTo(0,0);">返回顶部</a>
</footer>

    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>

<script src="/js/jquery-2.0.3.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

<script src="/js/navigation.js"></script>


<script type="text/javascript" src="https://js.users.51.la/19862371.js"></script>
<div id="bg"></div>

  </div>
</body>
</html>