<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[系统剩余空间查看]]></title>
    <url>%2F%E7%B3%BB%E7%BB%9F%E5%89%A9%E4%BD%99%E7%A9%BA%E9%97%B4%E6%9F%A5%E7%9C%8B%2F</url>
    <content type="text"><![CDATA[code1234567891011121314151617181920#!/bin/bash# 系统剩余磁盘空间查看等报告echo report date = `date`echo -e "\n"echo "MEM INFO:"echo mem total = `free -g |grep 'Mem' |awk '&#123;print $2&#125;'`Gecho mem used = `free -g |grep 'Mem' |awk '&#123;print $3&#125;'`Gecho -e "\n" echo "PROCESS INFO:"echo process num = `ps -elf |wc -l`echo zombie process num =`ps -elf |awk '&#123;print $2&#125;'|grep 'Z' |wc -l`echo -e "\n"echo "DISK SPACE INFO:"echo root_space_total = `df -h |grep '/dev/sda' |awk '&#123;print $2&#125;'`echo root_space_used = `df -h |grep '/dev/sda' |awk '&#123;print $3&#125;'`echo root_space_avliable = `df -h |grep '/dev/sda' |awk '&#123;print $4&#125;'`echo root_space_used_percent = `df -h |grep '/dev/sda' |awk '&#123;print $5&#125;'` result 图1. 系统剩余空间查看示例— 我觉得帮助到我了, 支持你一下. If you think the article is helpful to you, you can reward me through paypal.### Ads这是小广告! 如果有需要, 不妨支持一下吧~&gt; 这些好书您看了吗?&gt; 体育&amp;户外用品推荐]]></content>
      <categories>
        <category>Linux</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库分类]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[数据库分类 我觉得帮助到我了, 支持你一下. If you think the article is helpful to you, you can reward me through paypal. Ads这是小广告! 如果有需要, 不妨支持一下吧~ 这些好书您看了吗? 体育&amp;户外用品推荐]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker-Notesby-CS-Notes.md]]></title>
    <url>%2FDocker-Notes-by-CS-Notes%2F</url>
    <content type="text"><![CDATA[一、解决的问题 二、与虚拟机的比较 三、优势 四、使用场景 五、镜像与容器 参考资料 一、解决的问题由于不同的机器有不同的操作系统，以及不同的库和组件，在将一个应用部署到多台机器上需要进行大量的环境配置操作。 Docker 主要解决环境配置问题，它是一种虚拟化技术，对进程进行隔离，被隔离的进程独立于宿主操作系统和其它隔离的进程。使用 Docker 可以不修改应用程序代码，不需要开发人员学习特定环境下的技术，就能够将现有的应用程序部署在其他机器中。 # 二、与虚拟机的比较虚拟机也是一种虚拟化技术，它与 Docker 最大的区别在于它是通过模拟硬件，并在硬件上安装操作系统来实现。 ## 启动速度启动虚拟机需要启动虚拟机的操作系统，再启动应用，这个过程非常慢；而启动 Docker 相当于启动宿主操作系统上的一个进程。## 占用资源虚拟机是一个完整的操作系统，需要占用大量的磁盘、内存和 CPU，一台机器只能开启几十个的虚拟机。而 Docker 只是一个进程，只需要将应用以及相关的组件打包，在运行时占用很少的资源，一台机器可以开启成千上万个 Docker。# 三、优势除了启动速度快以及占用资源少之外，Docker 具有以下优势：## 更容易迁移提供一致性的运行环境，可以在不同的机器上进行迁移，而不用担心环境变化导致无法运行。## 更容易维护使用分层技术和镜像，使得应用可以更容易复用重复部分。复用程度越高，维护工作也越容易。## 更容易扩展可以使用基础镜像进一步扩展得到新的镜像，并且官方和开源社区提供了大量的镜像，通过扩展这些镜像可以非常容易得到我们想要的镜像。# 四、使用场景## 持续集成持续集成指的是频繁地将代码集成到主干上，这样能够更快地发现错误。Docker 具有轻量级以及隔离性的特点，在将代码集成到一个 Docker 中不会对其它 Docker 产生影响。## 提供可伸缩的云服务根据应用的负载情况，可以很容易地增加或者减少 Docker。## 搭建微服务架构Docker 轻量级的特点使得它很适合用于部署、维护、组合微服务。# 五、镜像与容器镜像是一种静态的结构，可以看成面向对象里面的类，而容器是镜像的一个实例。镜像包含着容器运行时所需要的代码以及其它组件，它是一种分层结构，每一层都是只读的（read-only layers）。构建镜像时，会一层一层构建，前一层是后一层的基础。镜像的这种分层存储结构很适合镜像的复用以及定制。构建容器时，通过在镜像的基础上添加一个可写层（writable layer），用来保存着容器运行过程中的修改。 # 参考资料- DOCKER 101: INTRODUCTION TO DOCKER WEBINAR RECAP- Docker 入门教程- Docker container vs Virtual machine- How to Create Docker Container using Dockerfile- 理解 Docker（2）：Docker 镜像- 为什么要使用 Docker？- What is Docker- 持续集成是什么？[转自]: https://github.com/CyC2018/— 我觉得帮助到我了, 支持你一下. If you think the article is helpful to you, you can reward me through paypal.### Ads这是小广告! 如果有需要, 不妨支持一下吧~&gt; 这些好书您看了吗?&gt; 体育&amp;户外用品推荐]]></content>
      <categories>
        <category>通用技术</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>CS-Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[informationisbeautiful]]></title>
    <url>%2Finformationisbeautiful%2F</url>
    <content type="text"><![CDATA[informationisbeautiful About Home graffiti/doodle Ads informationisbeautifulAboutData, information, knowledge: we distil it into beautiful, useful graphics &amp; diagrams. Founded by David McCandless, author of two bestselling infographics books, Information is Beautiful is dedicated to helping you make clearer, more informed decisions about the world. All our visualizations are based on facts &amp; data: constantly updated, revised &amp; revisioned. Homehttps://informationisbeautiful.net/ graffiti/doodle informationisbeautiful1printf("informationisbeautiful!");informationisbeautiful informationisbeautiful1. informationisbeautiful1. informationisbeautiful1. informationisbeautiful- [ ] informationisbeautiful&gt; informationisbeautifulinformationisbeautiful———————-Name | Adress——- | ——-informationisbeautiful | https://informationisbeautiful.net/— 我觉得帮助到我了, 支持你一下.* If you think the article is helpful to you, you can reward me through paypal.### Ads这是小广告! 如果有需要, 不妨支持一下吧~&gt; 这些好书您看了吗?&gt; 体育&amp;户外用品推荐]]></content>
      <categories>
        <category>Graphics</category>
      </categories>
      <tags>
        <tag>informationisbeautiful</tag>
        <tag>graphics</tag>
        <tag>diagrams</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker-qq]]></title>
    <url>%2Fdocker-qq%2F</url>
    <content type="text"><![CDATA[Docker QQ repo home run command Ads Docker QQ ## repo homehttps://github.com/bestwu/docker-qq## run command12345678910111213141516171819$ docker run -d --name qq \ --init \ -m 384m --cpuset-cpus=2,3 \ --device /dev/snd \ -v /tmp/.X11-unix:/tmp/.X11-unix \ -v $&#123;XDG_RUNTIME_DIR&#125;/pulse/native:$&#123;XDG_RUNTIME_DIR&#125;/pulse/native \ -v $HOME/.qq:/TencentFiles \ -e DISPLAY=unix$DISPLAY \ -e XMODIFIERS=@im=fcitx \ -e QT_IM_MODULE=fcitx \ -e GTK_IM_MODULE=fcitx \ -e QT_X11_NO_MITSHM=1 \ -e PULSE_SERVER=unix:$&#123;XDG_RUNTIME_DIR&#125;/pulse/native \ -e XDG_RUNTIME_DIR=$&#123;XDG_RUNTIME_DIR&#125; \ -e AUDIO_GID=`getent group audio | cut -d: -f3` \ -e VIDEO_GID=`getent group video | cut -d: -f3` \ -e GID=`id -g` \ -e UID=`id -u` \ bestwu/qq:office — 我觉得帮助到我了, 支持你一下. If you think the article is helpful to you, you can reward me through paypal.### Ads这是小广告! 如果有需要, 不妨支持一下吧~&gt; 这些好书您看了吗?&gt; 体育&amp;户外用品推荐]]></content>
      <categories>
        <category>通用技术</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker-qq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将PEM证书转换为PFX,P12格式]]></title>
    <url>%2F%E5%B0%86PEM%E8%AF%81%E4%B9%A6%E8%BD%AC%E6%8D%A2%E4%B8%BAPFX%2CP12%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[场景PEM 证书不受支持，它们必须转换为 PKCS#12 (PFX/P12) 格式。 证书转换 转至 https://www.openssl.org/community/binaries.html 下载并安装openssl, 已经安装的则可直接使用openssl. 从 OpenSSL 安装 bin 文件夹运行以下命令格式。1# openssl pkcs12 -export -out Cert.p12 -in cert.pem -inkey key.pem -passin pass:root -passout pass:root [Reference]将 PEM 证书转换为 PFX/P12 格式https://www.ibm.com/support/knowledgecenter/zh/SSPH29_9.0.3/com.ibm.help.common.infocenter.aps/t_ConvertthepfxCertificatetopemFormat068.html 我觉得帮助到我了, 支持你一下. If you think the article is helpful to you, you can reward me through paypal. Ads这是小广告! 如果有需要, 不妨支持一下吧~ 这些好书您看了吗? 体育&amp;户外用品推荐]]></content>
      <categories>
        <category>协议证书</category>
        <category>openssl</category>
      </categories>
      <tags>
        <tag>PEM证书</tag>
        <tag>openssl</tag>
        <tag>pfx</tag>
        <tag>p12</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openwrt定时任务设置]]></title>
    <url>%2Fopenwrt%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[定时任务设置示例使用 crontab -e 编辑 Openwrt 的定时任务，添加如下12345# Reboot at 4:30am every day# Note: To avoid infinite reboot loop, wait 70 seconds# and touch a file in /etc so clock will be set# properly to 4:31 on reboot before cron starts.30 4 * * * sleep 70 &amp;&amp; touch /etc/banner &amp;&amp; reboot 这个 task 将在每天 4:30am 的时候重启路由器。 需要注意的是，一定要延迟重启，否则可能无限重启，官方给出的配置1中，在 sleep 70 秒之后，使用 touch 写文件，应为路由器如果没有及时联网从NTP服务器上获取到实践，那么路由器的系统时间和重启的系统时间便一样，如果修改过文件，Openwrt 开机后会把最后修改或者访问的文件时间作为默认系统时间。因此延迟1min重启，可以避免这个问题。 [Reference]Cron and crontabhttps://openwrt.org/docs/guide-user/base-system/cron 使用 Cron 定时重启 Openwrt 路由器http://einverne.github.io/post/2017/03/auto-reboot-openwrt.html LEDE/OpenWRT — Scheduling Taskshttps://medium.com/openwrt-iot/openwrt-scheduling-tasks-6e19d507ae45 System configurationhttps://oldwiki.archive.openwrt.org/doc/uci/system#time_zones 我觉得帮助到我了, 支持你一下. If you think the article is helpful to you, you can reward me through paypal. Ads这是小广告! 如果有需要, 不妨支持一下吧~ 这些好书您看了吗? 体育&amp;户外用品推荐]]></content>
      <categories>
        <category>路由器</category>
        <category>openwrt</category>
      </categories>
      <tags>
        <tag>openwrt</tag>
        <tag>cron</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git-rebase]]></title>
    <url>%2Fgit-rebase%2F</url>
    <content type="text"><![CDATA[简要介绍字面意思 re base, 变基.将所有要合并进来的commit在新的基础上重新提交一次.我们知道,还有个熟悉的命令: git merge, 每个commit都可以看到.git rebase相比git merge更”清爽”. git分支合并方法 git merge git rebase git cherry-pick git cherry-pick堪称”神器”,原因是灵活.想要合并某个commit, 直接cherry-pick过来即可. 需要注意, cherry-pick合入的不是分支,而是提交节点. git rebaserebase会将合入分支上超前的节点在待合入分支上重新提交一遍,换言之,git rebase 会计算当前分支和目标分支的最近共同祖先，然后将最近共同祖先与当前分支之间的所有commit都变基到目标分支上，使得提交历史变成一条直线。 merge与rebase后跟的分支名是不一样的。合并是合并进来，变基是变基过去.123C0 -- C1 -- C2 -- C3(master) \ C4 -- C5 -- C6(HEAD -&gt; dev)执行git rebase master123C0 -- C1 -- C2 -- C3(master) -- C4&apos; -- C5&apos; -- C6&apos;(HEAD -&gt; dev) \ C4 -- C5 -- C6最近共同祖先与当前分支之间的所有commit都被复制到master分支之后，并且将HEAD指针与当前分支指针切换过去。原来的commit还在吗？还在，如果你记得它的commit校验和，仍然可以切换过去，git会提示你当前处于detached HEAD状态下。只不过没有任何分支指针指向它们，它们已经被抛弃了，剩余的时光就是等待git垃圾回收命令清理它们。git rebase完并没有结束，因为我变基的目标分支是master，而当前分支是dev。我需要切换到master分支上，然后再合并一次。123$ git rebase master (当前分支是dev分支)$ git checkout master$ git merge dev注意: 这种合并是fast forward的，并不会生成一个新的合并commit。关于fast forward后面在对git merge进行说明时, 会讲到merge的三种方式.如果我要变基的本体分支不是当前分支行不行？也是可以的。在任何一个分支上，将dev分支变基到master分支上，变基完成当前分支会变成dev分支。1$ git rebase master dev## git merge### fast-forwar如果待合并的分支在当前分支的下游，也就是说没有分叉时，会发生快速合并，从test分支切换到master分支，然后合并test分支12$ git checkout master$ git merge test这种方法相当于直接把master分支移动到test分支所在的地方，并移动HEAD指针. ### no-ff如果我们不想要快速合并，那么我们可以强制指定为非快速合并，只需加上–no-ff参数12$ git checkout master$ git merge –no-ff test这种合并方法会在master分支上新建一个提交节点，从而完成合并 ### squashsvn的在合并分支时采用的就是这种方式，squash会在当前分支新建一个提交节点squash和no-ff非常类似，区别只有一点不会保留对合入分支的引用12$ git checkout master$ git merge –squash test — 我觉得帮助到我了, 支持你一下. If you think the article is helpful to you, you can reward me through paypal.### Ads这是小广告! 如果有需要, 不妨支持一下吧~&gt; 这些好书您看了吗?&gt; 体育&amp;户外用品推荐]]></content>
      <categories>
        <category>版本控制</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cpp-检测机器大端或者小端]]></title>
    <url>%2Fcpp-%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%99%A8%E5%A4%A7%E7%AB%AF%E6%88%96%E8%80%85%E5%B0%8F%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[今天在csdn上看到的 自己改进了一下发出来小端输出1 大端输出01234567union&#123; int i; char c[4];&#125; test;test.i = 1;cout &lt;&lt; int(test.c[0]) &lt;&lt; endl; [More Reference]大小端字节序存在的意义，为什么不用一个标准呢？https://www.zhihu.com/question/25311159 “字节序”是个什么鬼？https://zhuanlan.zhihu.com/p/21388517 大小端存储模式精解https://jocent.me/2017/07/25/big-little-endian.html 详解大端模式和小端模式https://blog.csdn.net/ce123_zhouwei/article/details/6971544 主机字节序与网络字节序https://blog.csdn.net/hou09tian/article/details/82759758 Linux程序设计学习笔记—-网络编程之网络数据包拆封包与字节顺序大小端https://blog.csdn.net/suool/article/details/38636993?utm_source=tuicool 我觉得帮助到我了, 支持你一下. If you think the article is helpful to you, you can reward me through paypal. Ads这是小广告! 如果有需要, 不妨支持一下吧~ 这些好书您看了吗? 体育&amp;户外用品推荐]]></content>
      <categories>
        <category>网络通讯</category>
        <category>大小端</category>
      </categories>
      <tags>
        <tag>大小端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简约不简单]]></title>
    <url>%2F%E7%AE%80%E7%BA%A6%E4%B8%8D%E7%AE%80%E5%8D%95%2F</url>
    <content type="text"><![CDATA[简约不简单Brief, but not simple. 我觉得帮助到我了, 支持你一下. If you think the article is helpful to you, you can reward me through paypal. Ads这是小广告! 如果有需要, 不妨支持一下吧~ 这些好书您看了吗? 体育&amp;户外用品推荐]]></content>
      <categories>
        <category>默认</category>
      </categories>
      <tags>
        <tag>默认</tag>
      </tags>
  </entry>
</search>
