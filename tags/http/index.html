<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  
  <meta name="description" content="momoda">
  

  
  <meta name="keywords" content="momoda">
  
  
  
  
  
  
  
  
  
  <title>Tag: http | Just another blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="momoda">
<meta name="keywords" content="momoda">
<meta property="og:type" content="website">
<meta property="og:title" content="Just another blog">
<meta property="og:url" content="https://wnhby.github.io/tags/http/index.html">
<meta property="og:site_name" content="Just another blog">
<meta property="og:description" content="momoda">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Just another blog">
<meta name="twitter:description" content="momoda">
  
    <link rel="alternative" href="/atom.xml" title="Just another blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  

  
  <!-- baidu webmaster push -->
  <script src="//push.zhanzhang.baidu.com/push.js"></script>
</head></html>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="Just another blog" rel="home">Just another blog</a>
      </h1>
      
        <h2 class="site-description">
          <a href="/" id="subtitle">momoda blog</a>
        </h2>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/atom.xml">RSS</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/sitemap.xml">Site map</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/more/share.html">Share</a></li>
                
                </ul>
            </div>
    </nav>
</header>

      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main">
  
    <article id="post-se-notes/计算机网络基础/README" class="post-se-notes/计算机网络基础/README post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/se-notes/计算机网络基础/README/">计算机网络基础-README</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://wnhby.github.io/se-notes/计算机网络基础/README/" data-id="cjsbbbeyc003oe9s67yawg317" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <!-- TOC -->
<ul>
<li><a href="#网络层">网络层</a><ul>
<li><a href="#icmp-协议">ICMP 协议</a></li>
<li><a href="#地址解析协议arp">地址解析协议（ARP）</a></li>
</ul>
</li>
<li><a href="#传输层">传输层</a><ul>
<li><a href="#tcp-协议">TCP 协议</a><ul>
<li><a href="#网络端口">网络端口</a></li>
<li><a href="#网络套接字">网络套接字</a></li>
</ul>
</li>
<li><a href="#tcpudp区别">TCP，UDP区别</a></li>
</ul>
</li>
<li><a href="#应用层">应用层</a><ul>
<li><a href="#http-协议">HTTP 协议</a></li>
</ul>
</li>
<li><a href="#其它">其它</a></li>
<li><a href="#更多阅读">更多阅读</a><pre><code>- [Ads](#ads)
</code></pre></li>
</ul>
<!-- /TOC -->
<p>网络本质上就是解决<strong>多台计算机之间如何互相通信</strong>这个问题，从最初的ARPANET(Advanced Research Projects Agency Network) 到现在的 TCP/IP，这个本质问题并没有变化，只是技术不断改进。</p>
<p>20世纪60年代以来，计算机网络得到了飞速增长。各大厂商为了在数据通信网络领域占据主导地位，纷纷推出了各自的网络架构体系和标准，如IBM公司的SNA，Apple公司的AppleTalk协议，以及广泛流行的TCP/IP协议。同时，各大厂商针对自己的协议生产出了不同的硬件和软件。由于多种协议的并存，使得网络变得越来越复杂；而且，厂商之间的网络设备大部分不能兼容，很难进行通信。</p>
<p>为了解决网络之间的兼容性问题，帮助各个厂商生产出可兼容的网络设备，国际标准化组织ISO于1984年提出了<code>OSI RM</code>（OpenSystem Interconnection Reference Model，开放式系统互联通信参考模型），OSI 参考模型很快成为计算机网络通信的基础模型。该体系结构定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层和应用层），在这一框架下进一步详细规定了每一层的功能，以实现开放系统环境中的互连性、互操作性和应用的可移植性。</p>
<p>由于OSI模型和协议比较复杂，所以并没有得到广泛的应用。而TCP/IP(transfer control protocol/internet protocol,传输控制协议/网际协议)模型因其开放性和易用性在实践中得到了广泛的应用，TCP/IP协议栈也成为互联网的主流协议。</p>
<p><img src="http://7xrlu9.com1.z0.glb.clouddn.com/Network_01.png" alt="TCP/IP"></p>
<p>更多内容参考 <a href="OSI_TCP_IP.md">OSI_TCP_IP</a></p>
<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>网络层(network layer)是实现互联网的最重要的一层。正是在网络层面上，各个局域网根据IP协议相互连接，最终构成覆盖全球的Internet。更高层的协议，无论是TCP还是UDP，必须通过网络层的IP数据包(datagram)来传递信息。</p>
<p>IP协议是TCP/IP协议的核心，所有的TCP，UDP，IMCP，IGCP的数据都以IP数据格式传输。要注意的是，IP不是可靠的协议，这是说，IP协议没有提供一种数据未传达以后的处理机制–这被认为是上层协议–TCP或UDP要做的事情。</p>
<p>更多内容参考 <a href="IP.md">IP</a></p>
<h2 id="ICMP-协议"><a href="#ICMP-协议" class="headerlink" title="ICMP 协议"></a>ICMP 协议</h2><p>ICMP 是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递<code>控制消息</code>。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。</p>
<p>ICMP基于IP协议，也就是说，一个ICMP包需要封装在IP包中，然后在互联网传送。ICMP是IP套装的必须部分，任何一个支持IP协议的计算机，都要同时实现ICMP。</p>
<p>ICMP传输的控制信息可以分为两大类：</p>
<ul>
<li><code>错误(error)信息</code>：这一类信息可用来诊断网络故障。IP协议的工作方式是“Best Effort”，如果IP包没有被传送到目的地，或者IP包发生错误，IP协议本身不会做进一步的努力。但上游发送IP包的主机和接力的路由器并不知道下游发生了错误和故障，它们可能继续发送IP包。通过ICMP包，下游的路由器和主机可以将错误信息汇报给上游，从而让上游的路由器和主机进行调整。</li>
<li><code>咨询(Informational)信息</code>：比如某台计算机询问路径上的每个路由器都是谁，然后各个路由器同样用ICMP包回答。</li>
</ul>
<p>ICMP包有Type, Code和Checksum三部分：</p>
<ul>
<li>类型：指明该数据包属于什么类型（大分类），长度1个字节。</li>
<li>代码：指明数据包属于大类里面的哪个小类，长度1个字节。类型字段与代码字段共同决定ICMP数据包类型，以及后续字段含义。</li>
<li>校验和： 指明该数据包的校验和，长度2个字节。该校验和覆盖整个ICMP数据包。</li>
</ul>
<p>ICMP数据包通过类型字段与代码字段来共同决定该数据包传达的控制信息。常见的ICMP包类型：</p>
<ul>
<li>0（Echo Reply）：属于咨询信息，ping命令就是利用了该类型的ICMP包。 </li>
<li>3（Destination Unreachable）属于错误信息。如果一个路由器接收到一个IP包，不知道下一步往哪里发送，就会向出发主机发送该类型的ICMP包。</li>
<li>11（Time Exceeded）属于错误信息。IPv4中的Time to Live(TTL)会随着经过的路由器而递减，当这个区域值减为0时，就认为该IP包超时(Time Exceeded)。traceroute就利用了这种类型的ICMP包，它向目的地发送IP包，第一次的时候，将TTL设置为1，引发第一个路由器的Time Exceeded错误。这样，第一个路由器回复ICMP包，从而让出发主机知道途径的第一个路由器的信息。随后TTL被设置为2、3、4，…，直到到达目的主机。这样，沿途的每个路由器都会向出发主机发送ICMP包来汇报错误。traceroute将ICMP包的信息打印在屏幕上，就是接力路径的信息了。</li>
</ul>
<h2 id="地址解析协议（ARP）"><a href="#地址解析协议（ARP）" class="headerlink" title="地址解析协议（ARP）"></a>地址解析协议（ARP）</h2><p>首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。</p>
<p>当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP地址。</p>
<p>当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。</p>
<p>源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。<code>广播发送ARP请求，单播发送ARP响应</code>。</p>
<p><code>RARP协议</code>：反向地址转换协议，允许局域网的物理机器从网关服务器的ARP表或者缓存上请求其IP地址。其因为较限于IP地址的运用以及其他的一些缺点，因此渐为更新的BOOTP或DHCP所取代。</p>
<p>工作流程：在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系。当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP地址装入响应报文中发回给请求者。因为需要广播请求报文，因此RARP只能用于具有广播能力的网络。</p>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h2><p>TCP(Transmission Control Protocol)为应用程序之间提供面向连接的可靠的字节流服务。TCP为全双工协议，提供流控制机制，即允许接收方控制发送方的发送速度，此外还提供拥塞控制功能。</p>
<p>［<a href="http://www.nowcoder.com/questionTerminal/7aa912d4886e45759698dd074521c726" target="_blank" rel="noopener">TCP 协议细节</a>］<br>［<a href="http://www.nowcoder.com/questionTerminal/3d9d35cc024840d2ae21929bcf868d53" target="_blank" rel="noopener">滑动窗口协议</a>］<br>［<a href="http://www.nowcoder.com/questionTerminal/787f0b432012420cb2918b7e1ca37ab2" target="_blank" rel="noopener">nagle算法</a>］<br>［<a href="http://www.nowcoder.com/questionTerminal/a2b95450f85c4855877a0c4f06c91a72" target="_blank" rel="noopener">拥塞控制算法</a>］<br>［<a href="http://www.nowcoder.com/questionTerminal/246945f0e26541b89f4735c79e3f16a2" target="_blank" rel="noopener">状态转换流程</a>］  </p>
<p>详细内容参见 <a href="TCP.md">TCP</a></p>
<h3 id="网络端口"><a href="#网络端口" class="headerlink" title="网络端口"></a>网络端口</h3><p>TCP 服务器由发送端和接收端创建一种称为<code>套接字</code>的端点来获得，每个套接字有一个套接字编号（地址），该编号由主机的 IP 地址以及一个本地的16位数值组成的。这个16位数值称为端口，所以一共有2^16 ＝ 65535个端口可用。</p>
<p>1024以下的（不0包括1024）的端口被保留，只能用作由特权用户（比如UNIX系统的 root）启动的标准服务，这些端口称为<code>知名端口</code>。一些知名的端口如下：</p>
<table>
<thead>
<tr>
<th>端口</th>
<th>协议</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>20，21</td>
<td>FTP</td>
<td>文件传输协议，21是控制端口，20是数据端口</td>
</tr>
<tr>
<td>22</td>
<td>SSH</td>
<td>远程登录，Telnet的替代</td>
</tr>
<tr>
<td>23</td>
<td>Telnet</td>
<td>TELNET 终端仿真服务</td>
</tr>
<tr>
<td>25</td>
<td>SMTP</td>
<td>简单邮件传输协议</td>
</tr>
<tr>
<td>53</td>
<td>DNS</td>
<td>域名解析服务</td>
</tr>
<tr>
<td>80</td>
<td>HTTP</td>
<td>万维网, 超文本传输服务</td>
</tr>
<tr>
<td>443</td>
<td>HTTPS</td>
<td>安全的 Web</td>
</tr>
</tbody>
</table>
<p>1024～49151 之间的的其它端口可以通过 IANA 注册，由非特权用户使用，但是应用程序可以选择自己的端口号。</p>
<h3 id="网络套接字"><a href="#网络套接字" class="headerlink" title="网络套接字"></a>网络套接字</h3><p>网络上不同的计算机之间进行 TCP、UDP通信需要使用网络套接字（socket）。socket是在不同计算机之间进行通信的一个抽象。他工作于TCP/IP协议中应用层和传输层之间的一个抽象。</p>
<p><img src="http://7xrlu9.com1.z0.glb.clouddn.com/Network_02.jpg" alt=""></p>
<p>socket起源于UNIX，在Unix<code>一切皆文件</code>哲学的思想下，socket是一种”打开—读/写—关闭”模式的实现，服务器和客户端各自维护一个”文件”，在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。</p>
<p>详细内容参见 <a href="Socket.md">Socket</a></p>
<h2 id="TCP，UDP区别"><a href="#TCP，UDP区别" class="headerlink" title="TCP，UDP区别"></a>TCP，UDP区别</h2><p>TCP协议和UDP协议特性区别，主要从连接性、可靠性、有序性、拥塞控制、传输速度、头部大小(Header size)等6个方面来讲。</p>
<ol>
<li>TCP是面向连接的协议，UDP是无连接协议。TCP用三次握手建立连接，UDP发送数据前不需要建立连接；</li>
<li>TCP可靠，UDP不可靠。TCP丢包会重传，并且有确认机制，UDP不会；</li>
<li>TCP有序，UDP无序。消息在传输过程中可能会乱序，后发送的消息可能会先到达，TCP会对其进行重排序，UDP不会；</li>
<li>TCP 必须对数据进行校验，而UDP的校验是可选的；</li>
<li>TCP有流量控制（滑动窗口）和拥塞控制，UDP没有；</li>
<li>TCP传输慢，UDP传输快。因为TCP需要建立连接、保证可靠性和有序性，所以比较耗时。</li>
<li>TCP要建立连接、保证可靠性和有序性，就会传输更多的信息，包头比较大（TCP头部至少需要20字节，UDP头部只要8个字节）。</li>
</ol>
<p>基于TCP的协议有：HTTP/HTTPS，Telnet，FTP，SMTP。<br>基于UDP的协议有：DHCP，DNS，SNMP，TFTP，BOOTP。</p>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h2><p>HTTP 是一个客户端终端（用户）和服务器端（网站）请求和应答的标准。通过使用Web浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80），我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如HTML文件和图像，我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。</p>
<p>HTTP是一个<code>无状态</code>的协议，也就是说服务器不会去维护与客户交互的相关信息，因此它对于事务处理没有记忆能力。为了解决HTTP无状态的问题，HTTP 引入了 Cookie 和 Session机制，用来保存客户端状态信息。</p>
<p>HTTP协议中，并没有规定它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP假定其下层协议提供可靠的传输，因此，任何能够提供这种保证的协议都可以被其使用，在TCP/IP协议族使用TCP作为其传输层。</p>
<p>HTTP 有两个主要的版本 HTTP 1.0 和 HTTP 1.1，1.1 版本在带宽优化，长连接，缓存，Host头域，错误提示等方面有一些改进。</p>
<p>详细内容参见 <a href="HTTP.md">HTTP</a></p>
<h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><p><a href="Questions.md">Questions</a> 里面是一些和网络场景有关的具体问题，比如：</p>
<ul>
<li>访问网页过程</li>
<li>Ping 过程</li>
<li>QQ 传输层 UDP</li>
</ul>
<p><a href="More.md">More</a> 里面是一些网络方面的零散概念，比如：</p>
<ul>
<li>网络延迟 </li>
<li>以太网工作模式</li>
<li>路由权</li>
<li>路由器与交换机区别</li>
</ul>
<h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><p><a href="http://www.cnblogs.com/vamei/archive/2012/12/05/2802811.html" target="_blank" rel="noopener">协议森林系列文章</a><br><a href="https://www.zhihu.com/question/19718686" target="_blank" rel="noopener">《计算机网络》这门课为何如此之难？</a><br><a href="http://liangjiabin.com/blog/2015/03/difference-between-tcp-vs-udp-protocol.html" target="_blank" rel="noopener">TCP和UDP的区别</a></p>
<hr>
<ul>
<li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p>
</li>
<li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p>
</li>
</ul>
<h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p>
<blockquote>
<p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p>
</blockquote>
<blockquote>
<p>体育&amp;户外用品推荐</p>
</blockquote>
<div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/se-notes/计算机网络基础/README/../more/ads/amazon.gif" width="100%"></a> </div>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/se-notes/计算机网络基础/README/">
    <time datetime="2019-01-03T13:49:30.000Z" class="entry-date">
        1月 3 2019
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/网络通讯/">网络通讯</a>, <a class="article-category-link" href="/categories/网络通讯/计算机网络基础/">计算机网络基础</a>
  </div>

    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/">http</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network/">network</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tcp-ip/">tcp/ip</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/计算机网络/">计算机网络</a></li></ul>

    </footer>
</article>






  
    <article id="post-se-notes/计算机网络基础/ch1-OSI参考模型" class="post-se-notes/计算机网络基础/ch1-OSI参考模型 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/se-notes/计算机网络基础/ch1-OSI参考模型/">ch1-OSI参考模型</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://wnhby.github.io/se-notes/计算机网络基础/ch1-OSI参考模型/" data-id="cjsbbbeyf003te9s6ey9avtgd" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <!-- TOC -->
<ul>
<li><a href="#osi-%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B">OSI 参考模型</a></li>
<li><a href="#tcpip-%E5%8D%8F%E8%AE%AE%E6%A0%88">TCP/IP 协议栈</a></li>
<li><a href="#%E6%9B%B4%E5%A4%9A%E9%98%85%E8%AF%BB">更多阅读</a><ul>
<li><a href="#ads">Ads</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<p>OSI 参考模型（Open System Interconnection Reference Model，开放式系统互联通信参考模型），是 ISO （国际标准化组织）组织在 1985 年研究的网络互联模型。该体系结构标准定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层和应用层），在这一框架下进一步详细规定了每一层的功能，以实现开放系统环境中的互连性、互操作性和应用的可移植性。</p>
<h1 id="OSI-参考模型"><a href="#OSI-参考模型" class="headerlink" title="OSI 参考模型"></a>OSI 参考模型</h1><p>ISO 通信功能七个层次的划分原则是：</p>
<ul>
<li>网路中各节点都有相同的层次；</li>
<li>不同节点的同等层具有相同的功能；</li>
<li>同一节点内相邻层之间通过接口通信；</li>
<li>每一层使用下层提供的服务，并向其上层提供服务；</li>
<li>不同节点的同等层按照协议实现对等层之间的通信。</li>
</ul>
<p>OSI参考模型具有以下优点：</p>
<ul>
<li>简化了相关的网络操作；</li>
<li>提供设备间的兼容性和标准接口；</li>
<li>促进标准化工作；</li>
<li>结构上可以分隔，各层可以独立修改或者扩充；</li>
<li>易于实现和维护；</li>
<li>有利于大家学习、理解数据通讯网络。</li>
</ul>
<p>各层包含的协议大致如下图所示：</p>
<p><img src="http://7xrlu9.com1.z0.glb.clouddn.com/Network_OSI_TCP_IP_1.png" alt=""></p>
<p>各层功能详述如下：</p>
<ol>
<li>物理层 (Physical Layer)：物理层是 OSI 参考模型的最低层，它利用传输介质为数据链路层提供物理连接。它主要关心的是通过物理链路从一个节点向另一个节点传送<code>比特流</code>，物理链路可能是铜线、卫星、微波或其他的通讯媒介。它关心的问题有：多少伏电压代表 1 ？多少伏电压代表 0 ？时钟速率是多少？采用全双工还是半双工传输？总的来说物理层关心的是链路的机械、电气、功能和规程特性。</li>
<li>数据链路层 (Data Link Layer)：数据链路层是为网络层提供服务的，解决两个相邻结点之间的通信问题，传送的协议数据单元称为<code>数据帧</code>。数据帧中包含物理地址（又称 MAC 地址）、控制码、数据及校验码等信息。该层的主要作用是通过校验、确认和反馈重发等手段，将不可靠的物理链路转换成对网络层来说无差错的数据链路。此外，数据链路层还要协调收发双方的数据传输速率，即进行流量控制，以防止接收方因来不及处理发送方来的高速数据而导致缓冲器溢出及线路阻塞。</li>
<li>网络层 (Network Layer)：网络层是为传输层提供服务的，传送的协议数据单元称为<code>数据包（分组）</code>。该层的主要作用是解决如何使数据包通过各结点传送的问题，即通过路径选择算法（路由）将数据包送到目的地。另外，为避免通信子网中出现过多的数据包而造成网络阻塞，需要对流入的数据包数量进行控制（拥塞控制）。当数据包要跨越多个通信子网才能到达目的地时，还要解决网际互连的问题。</li>
<li>传输层 (Transport Layer)：传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题，传输层传送的协议数据单元称为<code>数据段（报文）</code>。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。</li>
<li>会话层 (Session Layer)：会话层主要功能是管理和协调不同主机上各种进程之间的通信（对话），即负责建立、管理和终止应用程序之间的会话。会话层得名的原因是它很类似于两个实体间的会话概念。例如，一个交互的用户会话以登录到计算机开始，以注销结束。</li>
<li>表示层 (Presentation Layer)：表示层处理流经结点的数据编码的表示方式问题，以保证一个系统应用层发出的信息可被另一系统的应用层读出。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据表示格式转换成网络通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。</li>
<li>应用层 (Application Layer)：应用层是 OSI 参考模型的最高层，是用户与网络的接口。该层通过应用程序来完成网络用户的应用需求，如文件传输、收发电子邮件等。 </li>
</ol>
<p>［<a href="http://www.nowcoder.com/questionTerminal/4d87fe456e39498c995011813be0230b" target="_blank" rel="noopener">网络层含有的协议</a>］<br>［<a href="http://www.nowcoder.com/questionTerminal/b79339e956ac4330937b01af14b3102b" target="_blank" rel="noopener">网络层功能</a>］</p>
<h1 id="TCP-IP-协议栈"><a href="#TCP-IP-协议栈" class="headerlink" title="TCP/IP 协议栈"></a>TCP/IP 协议栈</h1><p>由于OSI模型和协议比较复杂，所以并没有得到广泛的应用。而TCP/IP(transfer control protocol/internet protocol,传输控制协议/网际协议)模型因其开放性和易用性在实践中得到了广泛的应用，TCP/IP协议栈也成为互联网的主流协议。</p>
<p>TCP/IP模型是一系列网络协议的总称，这些协议的目的，就是使计算机之间可以进行信息交换。所谓”协议”可以理解成机器之间交谈的语言，每一种协议都有自己的目的。TCP/IP模型一共包括几百种协议，对互联网上交换信息的各个方面都做了规定。</p>
<p>这些协议可以大致分成四个层次，分别为连接层(Link Layer)、网络层(Internet Layer)、传输层(Transport Layer)、应用层(Application Layer)，上一层的协议都以下一层的协议为基础，数据传输的的过程如下图所示：</p>
<p><img src="http://7xrlu9.com1.z0.glb.clouddn.com/Network_OSI_TCP_IP_2.png" alt=""></p>
<p>协议栈向下传递数据，并添加报头和报尾的过程称为<code>封装</code>，数据被封装并通过网络传输后，接收设备将删除添加的信息，并根据报头中的信息决定如何将数据沿协议栈上传给合适的应用程序，这个过程称为<code>解封装</code>。不同设备的对等层之间依靠封装和解封装来实现相互间的通信。</p>
<h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><p><a href="http://www.codeceo.com/article/tcp-ip-osi-model.html" target="_blank" rel="noopener">TCP/IP 协议栈及 OSI 参考模型详解</a><br><a href="https://zh.wikipedia.org/wiki/TCP/IP协议族" target="_blank" rel="noopener">TCP/IP协议族</a>  </p>
<hr>
<ul>
<li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p>
</li>
<li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p>
</li>
</ul>
<h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p>
<blockquote>
<p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p>
</blockquote>
<blockquote>
<p>体育&amp;户外用品推荐</p>
</blockquote>
<div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/se-notes/计算机网络基础/ch1-OSI参考模型/../more/ads/amazon.gif" width="100%"></a> </div>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/se-notes/计算机网络基础/ch1-OSI参考模型/">
    <time datetime="2019-01-03T13:49:30.000Z" class="entry-date">
        1月 3 2019
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/网络通讯/">网络通讯</a>, <a class="article-category-link" href="/categories/网络通讯/计算机网络基础/">计算机网络基础</a>
  </div>

    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/">http</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network/">network</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tcp-ip/">tcp/ip</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/计算机网络/">计算机网络</a></li></ul>

    </footer>
</article>






  
    <article id="post-se-notes/计算机网络基础/ch2-HTTP" class="post-se-notes/计算机网络基础/ch2-HTTP post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/se-notes/计算机网络基础/ch2-HTTP/">ch2-HTTP</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://wnhby.github.io/se-notes/计算机网络基础/ch2-HTTP/" data-id="cjsbbbeyi003we9s6rhjesif5" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <!-- TOC -->
<ul>
<li><a href="#http-协议基础">HTTP 协议基础</a><ul>
<li><a href="#http-request">HTTP Request</a><ul>
<li><a href="#请求行">请求行</a></li>
<li><a href="#消息报头">消息报头</a></li>
<li><a href="#空行">空行</a></li>
<li><a href="#请求正文">请求正文</a></li>
</ul>
</li>
<li><a href="#http-响应">HTTP 响应</a><ul>
<li><a href="#状态行">状态行</a></li>
<li><a href="#消息报头-1">消息报头</a></li>
<li><a href="#响应正文">响应正文</a></li>
</ul>
</li>
<li><a href="#get-与-post">GET 与 POST</a></li>
<li><a href="#http不同版本区别">HTTP不同版本区别</a></li>
</ul>
</li>
<li><a href="#http-高级内容">HTTP 高级内容</a><ul>
<li><a href="#cookie-与-session">Cookie 与 Session</a><ul>
<li><a href="#cookie-机制">Cookie 机制</a></li>
<li><a href="#session-机制">Session 机制</a></li>
</ul>
</li>
<li><a href="#跨站攻击">跨站攻击</a><ul>
<li><a href="#csrf跨站请求伪造">CSRF（跨站请求伪造）</a></li>
<li><a href="#xss跨站脚本攻击">XSS（跨站脚本攻击）</a></li>
</ul>
</li>
<li><a href="#web-缓存">Web 缓存</a></li>
<li><a href="#http-代理">HTTP 代理</a></li>
</ul>
</li>
<li><a href="#参考">参考</a><pre><code>- [Ads](#ads)
</code></pre></li>
</ul>
<!-- /TOC -->
<p>HTTP 是一个应用层 Web 协议，通常由 HTTP 客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的 TCP 连接。HTTP 服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP/1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016081901.jpg" alt=""></p>
<p>HTTP 的主要特点如下：</p>
<ul>
<li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、POST 。每种方法规定了客户与服务器联系的类型不同。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。</li>
<li>灵活： HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。</li>
<li>无连接（限于HTTP/1.0）：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li>
<li>无状态： HTTP 是一个<strong>无状态</strong>的协议，即服务器不会去维护与客户交互的相关信息，因此它对于事务处理没有记忆能力。举个例子来讲，你通过服务器认证后成功请求了一个资源，紧接着再次请求这一资源时，服务器仍旧会要求你表明身份。 </li>
</ul>
<p>无状态不代表 HTTP 不能保持 TCP 连接，更不能代表 HTTP 使用的是 UDP 协议（无连接）。HTTP 协议中，并没有规定它所依赖的层。HTTP 假定其下层协议提供可靠的传输，因此任何能够提供这种保证的协议都可以被其使用。HTTP 在 TCP/IP 协议族使用 TCP 作为其传输层，其在 TCP/IP 四层网络模型中的位置如下图所示： </p>
<p><img src="http://7xrlu9.com1.z0.glb.clouddn.com/Network_HTTP_2.png" alt=""></p>
<h1 id="HTTP-协议基础"><a href="#HTTP-协议基础" class="headerlink" title="HTTP 协议基础"></a>HTTP 协议基础</h1><h2 id="HTTP-Request"><a href="#HTTP-Request" class="headerlink" title="HTTP Request"></a>HTTP Request</h2><p>客户端发送一个 HTTP 请求到服务器的请求消息包括四个部分：<strong>请求行</strong>（request line）、<strong>消息报头</strong>（header）、空行、<strong>请求正文</strong>。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2964446-fdfb1a8fce8de946.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="enter image description here"></p>
<p>以下是一个 HTTP GET 请求的实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /562f25980001b1b106000338.jpg HTTP/1.1</span><br><span class="line">Host    img.mukewang.com</span><br><span class="line">User-Agent    Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36</span><br><span class="line">Accept    image/webp,image/*,*/*;q=0.8</span><br><span class="line">Referer    http://www.imooc.com/</span><br><span class="line">Accept-Encoding    gzip, deflate, sdch</span><br><span class="line">Accept-Language    zh-CN,zh;q=0.8</span><br></pre></td></tr></table></figure></p>
<h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><p>请求行以一个方法符号开头，后面跟着请求的 URI 和协议版本，彼此由空格分隔。</p>
<p>常用的请求方法如下： </p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>获取由 Request-URI 标识的任何信息(以实体的形式)，如果 Request-URI 引用某个数据处理过程，则应该以它产生的数据作为在响应中的实体，而不是该过程的源代码文本，除非该过程碰巧输出该文本。</td>
</tr>
<tr>
<td>POST</td>
<td>用来请求原始服务器接受请求中封装的实体作为请求行中的Request-URI标识的副属。POST主要用于向数据处理过程提供数据块，如递交表单或者是通过追加操作来扩展数据库。</td>
</tr>
<tr>
<td>PUT</td>
<td>以提供的Request-URI存储封装的实体。</td>
</tr>
<tr>
<td>DELETE</td>
<td>请求原始服务器删除Request-URI标识的资源。</td>
</tr>
<tr>
<td>HEAD</td>
<td>除了服务器不能在响应中返回消息体，HEAD方法与GET相同。用来获取暗示实体的元信息，而不需要传输实体本身。常用于测试超文本链接的有效性、可用性和最近的修改。</td>
</tr>
</tbody>
</table>
<p>简单例子如下：</p>
<pre><code>GET /index.html HTTP/1.1
POST http://192.168.2.217:8080/index.jsp HTTP/1.1
</code></pre><h3 id="消息报头"><a href="#消息报头" class="headerlink" title="消息报头"></a>消息报头</h3><p>消息报头是紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息。</p>
<p>报头域由键值对组成。请求头部包含了<strong>普通报头</strong>、<strong>请求报头</strong>、<strong>实体报头</strong>。</p>
<p><strong>普通报头</strong>用于所有的请求和响应消息，但并不用于被传输的实体，只用于传输的消息。比如： </p>
<ul>
<li>Cache-Control：用于指定缓存指令，缓存指令是单向的(响应中出现的缓存指令在请求中未必会出现)，且是独立的(一个消息的缓存指令不会影响另一个消息处理的缓存机制)；</li>
<li>Date：表示消息产生的日期和时间；</li>
<li>Connection：允许发送指定连接的选项，例如指定连接是连续的，或者指定 “close” 选项，通知服务器在响应完成后关闭连接。</li>
</ul>
<p><strong>请求报头</strong>允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。常用的请求报头如下： </p>
<ul>
<li>Host：指定被请求资源的 Internet 主机和端口号，它通常是从 HTTP URL 中提取出来的；</li>
<li>User-Agent：允许客户端将它的操作系统、浏览器和其它属性告诉服务器；</li>
<li>Accept：指定客户端接受哪些类型的信息，eg:Accept:image/gif，表明客户端希望接受GIF图象格式的资源；</li>
<li>Accept-Charset：指定客户端接受的字符集，缺省是任何字符集都可以接受；</li>
<li>Accept-Encoding：指定可接受的内容编码，缺省是各种内容编码都可以接受；</li>
<li>Authorization：证明客户端有权查看某个资源，当浏览器访问一个页面，如果收到服务器的响应代码为401(未授权)，可以发送一个包含 Authorization 请求报头域的请求，要求服务器对其进行验证。</li>
</ul>
<p><strong>实体报头</strong>定义了关于实体正文（eg：有无实体正文）和请求所标识的资源的元信息。常用的实体报头如下：</p>
<ul>
<li>Allow：GET，POST</li>
<li>Content-Encoding：文档的编码（Encode）方法，eg：gzip；</li>
<li>Content-Language：内容的语言类型，eg：zh-cn；</li>
<li>Content-Length：表示内容长度，eg：80</li>
</ul>
<h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><p>请求头部后面的空行是必须的。</p>
<p>即使第四部分的请求数据为空，也必须有空行。</p>
<h3 id="请求正文"><a href="#请求正文" class="headerlink" title="请求正文"></a>请求正文</h3><p>通常是 HTML 代码或者 JSON 格式的文本。</p>
<h2 id="HTTP-响应"><a href="#HTTP-响应" class="headerlink" title="HTTP 响应"></a>HTTP 响应</h2><p>在接收和解释请求消息后，服务器返回一个 HTTP 响应消息。HTTP 响应也是由四个部分组成，分别是：<strong>状态行</strong>、<strong>消息报头</strong>、空行、<strong>响应正文</strong>。</p>
<p>一个 HTTP Response 实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Fri, 22 May 2009 06:07:21 GMT</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">      &lt;head&gt;&lt;/head&gt;</span><br><span class="line">      &lt;body&gt;</span><br><span class="line">            &lt;!--body goes here--&gt;</span><br><span class="line">      &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h3><p>所有 HTTP 响应的第一行都是状态行，依次是当前 HTTP 版本号，3 位数字组成的状态码，以及描述状态的短语，彼此由空格分隔。</p>
<p>HTTP 状态码由三位数字组成，共分五种类别。状态代码的第一个数字代表当前响应的类型：</p>
<ul>
<li>1xx：指示信息——请求已被服务器接收，继续处理</li>
<li>2xx：成功——请求已成功被服务器接收、理解、接受</li>
<li>3xx：重定向——需要后续操作才能完成这一请求</li>
<li>4xx：客户端错误——请求含有词法错误或者无法被执行</li>
<li>5xx：服务器错误——服务器在处理某个正确请求时发生错误</li>
</ul>
<p>常见的状态码有如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">200 OK                        //客户端请求成功</span><br><span class="line">400 Bad Request               //客户端请求有语法错误，不能被服务器所理解</span><br><span class="line">401 Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </span><br><span class="line">403 Forbidden                 //服务器收到请求，但是拒绝提供服务</span><br><span class="line">404 Not Found                 //请求资源不存在，eg：输入了错误的URL</span><br><span class="line">500 Internal Server Error     //服务器发生不可预期的错误</span><br><span class="line">503 Server Unavailable        //服务器当前不能处理客户端的请求，一段时间后可能恢复正常</span><br></pre></td></tr></table></figure>
<h3 id="消息报头-1"><a href="#消息报头-1" class="headerlink" title="消息报头"></a>消息报头</h3><p>响应消息报头包含了<strong>普通报头</strong>、<strong>响应报头</strong>、<strong>实体报头</strong>，普通报头和实体报头与 HTTP Request 报头中的普通报头、实体报头相同。</p>
<p>响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和 对 Request-URI 所标识的资源进行下一步访问的信息。常用的响应报头如下： </p>
<ul>
<li>Location：用于重定向接受者到一个新的位置，Location 响应报头域常用在更换域名的时候；</li>
<li>Server：包含了服务器用来处理请求的软件信息，与 User-Agent 请求报头域是相对应的；</li>
<li>WWW-Authenticate：必须被包含在 401(未授权的)响应消息中。</li>
</ul>
<h3 id="响应正文"><a href="#响应正文" class="headerlink" title="响应正文"></a>响应正文</h3><p>消息正文类似 HTTP 请求的消息正文。</p>
<h2 id="GET-与-POST"><a href="#GET-与-POST" class="headerlink" title="GET 与 POST"></a>GET 与 POST</h2><p>HTTP 协议定义了很多与服务器交互的方法，最基本的有 4 种，分别是 GET, POST, PUT, DELETE 。一个 URL 用于描述一个网络上的资源，而 HTTP 中的 GET, POST, PUT, DELETE 就对应着对这个资源的查，改，增，删 4 个操作。</p>
<p>GET 一般用于<strong>获取/查询</strong>资源信息，而POST一般用于<strong>更新</strong>资源信息，主要区别如下：</p>
<ol>
<li>GET 通过地址栏来传值（但由于敏感信息附在 URL 上，可能有安全问题）；POST 方法通过提交表单来传值，提交的数据放在 HTTP 包的 Body 中。</li>
<li>GET 提交的数据大小有限制（因为<strong>浏览器对URL的长度有限制</strong>，实际上 HTTP 协议规范没有对 URL 长度进行限制），而 POST 方法提交的数据没有限制。</li>
<li>对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）；而对于 POST，浏览器先发送 header ，服务器响应 100 continue，浏览器再发送 data ，服务器响应 200 ok（返回数据）。</li>
<li>GET 在浏览器回退时是无害的，而 POST 会再次提交请求。GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。</li>
<li>对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。</li>
</ol>
<h2 id="HTTP不同版本区别"><a href="#HTTP不同版本区别" class="headerlink" title="HTTP不同版本区别"></a>HTTP不同版本区别</h2><p>HTTP/1.0 与 HTTP/1.1 主要区别如下：</p>
<ul>
<li><p>带宽优化</p>
<p>  HTTP/1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了。HTTP/1.1 中在请求消息中引入了 range 头域，它允许只请求资源的某个部分。</p>
<p>  另外一种情况是请求消息中如果包含比较大的实体内容，但不确定服务器是否能够接收该请求（如是否有权限），此时若贸然发出带实体的请求，如果被拒绝也会浪费带宽。HTTP/1.1 加入了一个新的状态码100（Continue），客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码 401（Unauthorized）；如果服务器接收此请求就回送响应码 100，客户端就可以继续发送带实体的完整请求了。</p>
</li>
<li><p>长连接</p>
<p>  HTTP 1.0 规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成请求处理后立即断开 TCP 连接，服务器不跟踪每个客户也不记录过去的请求。由于大多数网页的流量都比较小，一次 TCP 连接很少能通过 slow-start 区，不利于提高带宽利用率。</p>
<p>  HTTP 1.1 支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。</p>
<p>  HTTP 1.1 还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。</p>
</li>
<li><p>缓存</p>
<p>  在HTTP/1.0 中，使用<code>Expire头域</code>来判断资源的 fresh 或 stale ，并使用条件请求来判断资源是否仍有效。例如，cache 通过 If-Modified-Since 头域向服务器验证资源的 Last-Modefied 头域是否有更新，源服务器可能返回 304（Not Modified），则表明该对象仍有效；也可能返回 200（OK）替换请求的 Cache 对象。</p>
<p>  HTTP/1.1 在 1.0 的基础上加入了一些 cache 的新特性，当缓存对象的 Age 超过 Expire 时变为 stale 对象， cache 不需要直接抛弃 stale 对象，而是与源服务器进行重新激活（revalidation）。</p>
</li>
<li><p>Host 头域</p>
<p>  在 HTTP1.0 中认为每台服务器都绑定一个唯一的IP地址，因此请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个 IP 地址。HTTP1.1 的请求消息和响应消息都支持 Host 头域，请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。</p>
</li>
<li><p>错误提示</p>
<p>  HTTP/1.0 中只定义了16个状态响应码，对错误或警告的提示不够具体。HTTP/1.1 引入了一个 Warning 头域，增加对错误或警告信息的描述。</p>
<p>  此外，在HTTP/1.1中新增了24个状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p>
</li>
</ul>
<h1 id="HTTP-高级内容"><a href="#HTTP-高级内容" class="headerlink" title="HTTP 高级内容"></a>HTTP 高级内容</h1><h2 id="Cookie-与-Session"><a href="#Cookie-与-Session" class="headerlink" title="Cookie 与 Session"></a>Cookie 与 Session</h2><p>Cookie 和 Session 都为了用来保存状态信息，都是保存客户端状态的机制，它们都是为了解决 HTTP 无状态的问题。</p>
<h3 id="Cookie-机制"><a href="#Cookie-机制" class="headerlink" title="Cookie 机制"></a>Cookie 机制</h3><p>简单地说，cookie 就是浏览器储存在用户电脑上的一小段文本文件。cookie 是纯文本格式，不包含任何可执行的代码。一个 Web 页面或服务器告知浏览器按照一定规范来储存这些信息，并在随后的请求中将这些信息发送至服务器，Web 服务器就可以使用这些信息来识别不同的用户。大多数需要登录的网站在用户验证成功之后都会设置一个 cookie，只要这个 cookie 存在并可以，用户就可以自由浏览这个网站的任意页面。</p>
<p>cookie 会被浏览器自动删除，通常存在以下几种原因：</p>
<ol>
<li>会话 cookie (Session cookie) 在会话结束时（浏览器关闭）会被删除</li>
<li>持久化 cookie（Persistent cookie）在到达失效日期时会被删除</li>
<li>如果浏览器中的 cookie 数量达到限制，那么 cookie 会被删除以为新建的 cookie 创建空间。</li>
</ol>
<p>大多数浏览器支持最大为 4096 字节的 Cookie。由于这限制了 Cookie 的大小，最好用 Cookie 来存储少量数据，或者存储用户 ID 之类的标识符。用户 ID 随后便可用于标识用户，以及从数据库或其他数据源中读取用户信息。 浏览器还限制站点可以在用户计算机上存储的 Cookie 的数量。大多数浏览器只允许每个站点存储 20 个 Cookie；如果试图存储更多 Cookie，则最旧的 Cookie 便会被丢弃。有些浏览器还会对它们将接受的来自所有站点的 Cookie 总数作出绝对限制，通常为 300 个。</p>
<p>使用 Cookie 的缺点：</p>
<ul>
<li>不良站点用 Cookie 收集用户隐私信息</li>
<li>Cookie 窃取：黑客以可以通过窃取用户的 Cookie 来模拟用户的请求行为。（跨站请求伪造 CSRF）</li>
</ul>
<h3 id="Session-机制"><a href="#Session-机制" class="headerlink" title="Session 机制"></a>Session 机制</h3><p>Session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。当程序需要为某个客户端的请求创建一个 session 的时候，服务器首先检查这个客户端的请求里是否已包含了一个 session 标识（session id）：</p>
<ul>
<li>如果已包含一个session id 则说明以前已经为此客户端创建过 session，服务器就按照 session id 把这个 session 检索出来使用（如果检索不到，可能会新建一个）。</li>
<li>如果客户端请求不包含 session id，则为此客户端创建一个 session 并且生成一个与此session相关联的 session id ， session id 的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个 session id 将被在本次响应中返回给客户端保存。</li>
</ul>
<p>具体实现方式：</p>
<ul>
<li><strong>Cookie方式</strong>：服务器给每个Session分配一个唯一的JSESSIONID，并通过Cookie发送给客户端。当客户端发起新的请求的时候，将在Cookie头中携带这个JSESSIONID，这样服务器能够找到这个客户端对应的Session。</li>
<li><strong>URL回写</strong>：服务器在发送给浏览器页面的所有链接中都携带JSESSIONID的参数，这样客户端点击任何一个链接都会把JSESSIONID带回服务器。如果直接在浏览器输入服务端资源的url来请求该资源，那么Session是匹配不到的。</li>
</ul>
<h2 id="跨站攻击"><a href="#跨站攻击" class="headerlink" title="跨站攻击"></a>跨站攻击</h2><h3 id="CSRF（跨站请求伪造）"><a href="#CSRF（跨站请求伪造）" class="headerlink" title="CSRF（跨站请求伪造）"></a>CSRF（跨站请求伪造）</h3><p>CSRF 是通过伪造请求从而冒充用户在站内的正常操作。</p>
<p><img src="https://github.com/astaxie/build-web-application-with-golang/raw/master/zh/images/9.1.csrf.png?raw=true" alt="enter image description here"></p>
<p>从上图可以看出，要完成一次 CSRF 攻击，受害者必须依次完成两个步骤 ：</p>
<ol>
<li>登录受信任网站 A，并在本地生成 Cookie 。</li>
<li>在不退出 A 的情况下，访问危险网站 B。</li>
</ol>
<p>防范 CSRF 攻击的三种策略：</p>
<ul>
<li><p>验证码<br>  CSRF 攻击的过程，往往是在用户不知情的情况下构造网络请求。所以如果使用验证码，那么每次操作都需要用户进行互动，从而简单有效的防御了 CSRF 攻击。但会严重影响用户体验。</p>
</li>
<li><p>验证 HTTP Referer 字段<br>  HTTP 报文头中的字段 Referer 记录了该 HTTP 请求的来源地址。服务端通过验证 Referer 字段来验证请求是来自同一个站点的请求后才提供服务。但由于该字段可以人为篡改，因此也并不安全。</p>
</li>
<li><p>在请求地址中添加 token 并验证<br>  在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token。token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对。如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p>
</li>
<li><p>在 HTTP 头中自定义属性并验证<br>  这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。（然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。）</p>
</li>
</ul>
<h3 id="XSS（跨站脚本攻击）"><a href="#XSS（跨站脚本攻击）" class="headerlink" title="XSS（跨站脚本攻击）"></a>XSS（跨站脚本攻击）</h3><p>XSS 全称“跨站脚本”，是注入攻击的一种。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。</p>
<p>理论上，所有可输入的地方没有对输入数据进行处理的话，都会存在XSS漏洞，漏洞的危害取决于攻击代码的威力，攻击代码也不局限于script。防御 XSS 攻击最简单直接的方法，就是过滤用户的输入。</p>
<p>如果不需要用户输入 HTML，可以直接对用户的输入进行 HTML escape 。一小段脚本：<code>&lt;script&gt;window.location.href=”http://www.baidu.com”;&lt;/script&gt;</code>，经过 escape 之后就成了： <code>&amp;lt;script&amp;gt;window.location.href=&amp;quot;http://www.baidu.com&amp;quot;&amp;lt;/script&amp;gt;</code>。它现在会像普通文本一样显示出来，变得无毒无害，不能执行了。</p>
<h2 id="Web-缓存"><a href="#Web-缓存" class="headerlink" title="Web 缓存"></a>Web 缓存</h2><p>WEB缓存(cache)位于Web服务器和客户端之间，缓存机制会根据请求保存输出内容的副本，例如 html 页面、图片、文件。当下一个请求来到的时候：如果是相同的 URL，缓存直接使用副本响应访问请求，而不是向源服务器再次发送请求。</p>
<p>有缓存的 Get 请求过程如下：</p>
<p><img src="http://7xrlu9.com1.z0.glb.clouddn.com/Network_HTTP_3.png" alt=""></p>
<p>主要分三种情况:</p>
<ol>
<li><p>未找到缓存(黑色线)：当没有找到缓存时，说明本地并没有这些数据，这种情况一般发生在我们首次访问网站，或者以前访问过，但是清除过缓存后。浏览器就会先访问服务器，然后把服务器上的内容取回来，内容取回来以后，就要根据情况来决定是否要保留到缓存中了。</p>
</li>
<li><p>缓存未过期(蓝色线)：缓存未过期，指的是本地缓存没有过期，不需要访问服务器了，直接就可以拿本地的缓存作为响应在本地使用了。这样节省了不少网络成本，提高了用户体验过。</p>
</li>
<li><p>缓存已过期(红色线)：当满足过期的条件时，会向服务器发送请求，发送的请求一般都会进行一个验证，目的是虽然缓存文档过期了，但是文档内容不一定会有什么改变，所以服务器返回的也许是一个新的文档，这时候的HTTP状态码是200，或者返回的只是一个最新的时间戳和304状态码。</p>
<p> 缓存过期后，有两种方法来判定服务端的文件有没有更新。第一种在上一次服务端告诉客户端约定的有效期的同时，告诉客户端该文件最后修改的时间，当再次试图从服务端下载该文件的时候，check 下该文件有没有更新（对比最后修改时间），如果没有，则读取缓存；第二种方式是在上一次服务端告诉客户端约定有效期的同时，同时告诉客户端该文件的版本号，当服务端文件更新的时候，改变版本号，再次发送请求的时候check一下版本号是否一致就行了，如一致，则可直接读取缓存。</p>
</li>
</ol>
<p>浏览器是依靠请求和响应中的的头信息来控制缓存的，如下：</p>
<ul>
<li><p>Expires与Cache-Control：服务端用来约定和客户端的有效时间的。Expires规定了缓存失效时间（Date为当前时间），而Cache-Control的max-age规定了缓存有效时间（2552s）。Expires是HTTP1.0的东西，而Cache-Control是HTTP1.1的，规定如果max-age和Expires同时存在，前者优先级高于后者。</p>
</li>
<li><p>Last-Modified/If-Modified-Since：缓存过期后，check服务端文件是否更新的第一种方式。</p>
</li>
<li><p>ETag/If-None-Match：缓存过期时check服务端文件是否更新的第二种方式。实际上ETag并不是文件的版本号，而是一串可以代表该文件唯一的字符串，当客户端发现和服务器约定的直接读取缓存的时间过了，就在请求中发送If-None-Match选项，值即为上次请求后响应头的ETag值，该值在服务端和服务端代表该文件唯一的字符串对比（如果服务端该文件改变了，该值就会变），如果相同，则相应HTTP304，客户端直接读取缓存，如果不相同，HTTP200，下载正确的数据，更新ETag值。</p>
</li>
</ul>
<p>当然并不是所有请求都能被缓存。无法被浏览器缓存的请求：</p>
<ol>
<li>HTTP信息头中包含Cache-Control:no-cache，pragma:no-cache（HTTP1.0），或Cache-Control:max-age=0等告诉浏览器不用缓存的请求</li>
<li>需要根据Cookie，认证信息等决定输入内容的动态请求是不能被缓存的</li>
<li>POST请求无法被缓存</li>
</ol>
<p>浏览器缓存过程还和用户行为有关。譬如先打开一个主页有个 jquery 的请求（假设访问后会缓存下来）。接着如果直接在地址栏输入 jquery 地址，然后回车，响应HTTP200（from cache），因为有效期还没过直接读取的缓存；如果ctrl+r进行刷新，则会相应HTTP304（Not Modified），虽然还是读取的本地缓存，但是多了一次服务端的请求；而如果是ctrl+shift+r强刷，则会直接从服务器下载新的文件，响应HTTP200。</p>
<h2 id="HTTP-代理"><a href="#HTTP-代理" class="headerlink" title="HTTP 代理"></a>HTTP 代理</h2><p>Web代理（proxy）服务器是网络的中间实体。代理位于Web客户端和Web服务器之间，扮演“中间人”的角色。HTTP的代理服务器即是Web服务器又是Web客户端。（Fiddler 是以代理web服务器的形式工作的,它使用代理地址:127.0.0.1, 端口:8888. 当Fiddler退出的时候它会自动注销代理，这样就不会影响别的程序。）</p>
<p><img src="http://7xrlu9.com1.z0.glb.clouddn.com/Network_HTTP_4.png" alt=""></p>
<p>代理服务器有许多用处：</p>
<ul>
<li>跨过网络障碍。翻墙技术：局域网不能上网，只能通过局域网内的一台代理服务器上网。</li>
<li>匿名访问。HTTP代理服务器通过删除HTTP报文中的身份特性（比如客户端的IP地址，或cookie,或URI的会话ID），从而对远端服务器隐藏原始用户的IP地址以及其他细节。同时HTTP代理服务器上也不会记录原始用户访问记录的log。</li>
<li>通过代理缓存，加快上网速度。大部分代理服务器都具有缓存的功能，不断将新取得数据存储到它本地的存储器上，如果浏览器所请求的数据在它本机的存储器上已经存在而且是最新的，那么直接将存储器上的数据传给用户，这样就能显著提高浏览速度。</li>
<li>过滤指定内容。比如儿童过滤器，很多教育机构，会利用代理来阻止学生访问成人内容。</li>
</ul>
<p>代理服务器和抓包工具（比如Fiddler）都能看到http request中的数据。如果我们发送的request中有敏感数据，比如用户名，密码，信用卡号码，就会被代理服务器看到。所以我们一般都是用HTTPS来加密Http request。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.voidcn.com/blog/huangjianxiang1875/article/p-1596378.html" target="_blank" rel="noopener">深入理解HTTP协议（二）——协议详解篇</a><br><a href="http://www.voidcn.com/blog/huangjianxiang1875/article/p-1596379.html" target="_blank" rel="noopener">深入理解HTTP协议（三）——深入了解篇</a><br><a href="https://www.mnot.net/blog/2014/06/07/rfc2616_is_dead" target="_blank" rel="noopener">RFC2616 is Dead</a><br><a href="http://www.cnblogs.com/TankXiao/archive/2012/11/28/2793365.html" target="_blank" rel="noopener">HTTP协议 (四) 缓存</a><br><a href="http://bubkoo.com/2014/04/21/http-cookies-explained/" target="_blank" rel="noopener">HTTP cookies 详解</a><br><a href="http://www.cnblogs.com/fish-li/archive/2011/07/03/2096903.html" target="_blank" rel="noopener">细说 Cookie</a><br><a href="http://blog.csdn.net/forgotaboutgirl/article/details/6936982" target="_blank" rel="noopener">HTTP/1.1与HTTP/1.0的区别</a><br><a href="http://web.jobbole.com/82997/" target="_blank" rel="noopener">浏览器缓存机制浅析</a><br><a href="http://oohcode.com/2015/05/28/http-cache/" target="_blank" rel="noopener">HTTP缓存机制</a><br><a href="http://www.bkjia.com/headlines/491296.html" target="_blank" rel="noopener">Http状态码查询，各种返回码的详解</a><br><a href="http://www.bkjia.com/headlines/491855.html" target="_blank" rel="noopener">HTTP协议详解(五) http协议代理</a><br><a href="http://xfhnever.com/2014/10/08/http-header/" target="_blank" rel="noopener">Http(二)-消息报头</a><br><a href="https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/" target="_blank" rel="noopener">CSRF 攻击的应对之道</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&amp;mid=100000054&amp;idx=1&amp;sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd" target="_blank" rel="noopener">99%的人都理解错了HTTP中GET与POST的区别</a>  </p>
<hr>
<ul>
<li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p>
</li>
<li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p>
</li>
</ul>
<h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p>
<blockquote>
<p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p>
</blockquote>
<blockquote>
<p>体育&amp;户外用品推荐</p>
</blockquote>
<div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/se-notes/计算机网络基础/ch2-HTTP/../more/ads/amazon.gif" width="100%"></a> </div>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/se-notes/计算机网络基础/ch2-HTTP/">
    <time datetime="2019-01-03T13:49:30.000Z" class="entry-date">
        1月 3 2019
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/网络通讯/">网络通讯</a>, <a class="article-category-link" href="/categories/网络通讯/计算机网络基础/">计算机网络基础</a>
  </div>

    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/">http</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network/">network</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tcp-ip/">tcp/ip</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/计算机网络/">计算机网络</a></li></ul>

    </footer>
</article>






  
    <article id="post-se-notes/计算机网络基础/ch3-TCP" class="post-se-notes/计算机网络基础/ch3-TCP post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/se-notes/计算机网络基础/ch3-TCP/">ch3-TCP</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://wnhby.github.io/se-notes/计算机网络基础/ch3-TCP/" data-id="cjsbbbeyl0041e9s64dkbi2wd" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <!-- TOC -->
<ul>
<li><a href="#tcp-协议">TCP 协议</a><ul>
<li><a href="#tcp-报文结构">TCP 报文结构</a></li>
<li><a href="#三次握手建立连接">三次握手建立连接</a></li>
<li><a href="#四次握手断开连接">四次握手断开连接</a></li>
<li><a href="#tcp-状态转换图">TCP 状态转换图</a></li>
<li><a href="#tcp-重传机制">TCP 重传机制</a></li>
<li><a href="#tcp-滑动窗口">TCP 滑动窗口</a></li>
<li><a href="#tcp-拥塞控制">TCP 拥塞控制</a><ul>
<li><a href="#慢启动slow-start">慢启动(Slow Start)</a></li>
</ul>
</li>
<li><a href="#拥塞避免算法congestion-avoidance">拥塞避免算法(Congestion Avoidance)</a><ul>
<li><a href="#拥塞发生算法">拥塞发生算法</a></li>
</ul>
</li>
<li><a href="#更多阅读">更多阅读</a><ul>
<li><a href="#ads">Ads</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h1 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h1><p>因特网的网络层只提供无连接、不可靠的尽力服务。它可以将分组从一个主机通过因特网传送到另一台主机，可能出现比特错、丢失、重复和错序到达的情形。</p>
<p>传输层建立在网络层之上，为进程之间的数据传输提供服务。传输层可以通过不可靠的因特网在两个进程之间建立一条可靠的逻辑链路，提供字节流传输服务。</p>
<p>因特网的传输层有两个协议UDP和TCP：</p>
<ul>
<li>UDP(User Datagram Protocol)只提供无连接的不可靠的服务，应用进程通过&lt;远端IP地址，远端端口号&gt;向远端进程发送数据，应用进程并不要求远端进程进行确认。</li>
<li>TCP(Transmission Control Protocol)为应用程序之间提供面向连接的可靠的字节流服务。TCP为全双工协议，提供流控制机制，即允许接收方控制发送方的发送速度，此外还提供拥塞控制功能。</li>
</ul>
<p>下图即为两个端点之间TCP通信的简单示意图：</p>
<p><img src="http://7xrlu9.com1.z0.glb.clouddn.com/Network_TCP_1.png" alt=""></p>
<p>源主机的TCP进程从上层收集应用进程的数据，并在满足一定条件时发送出去，TCP发送的数据称为分段(Segment)。</p>
<h2 id="TCP-报文结构"><a href="#TCP-报文结构" class="headerlink" title="TCP 报文结构"></a>TCP 报文结构</h2><p>TCP头部数据格式如下：</p>
<p><img src="http://7xrlu9.com1.z0.glb.clouddn.com/Network_TCP_2.png" alt=""></p>
<p>各个字段的信息说明如下：</p>
<ul>
<li>Source Port(Destination Port)：分别占用16位，表示源端口号和目的端口号；用于区别主机中的不同进程，源端口号和目的端口号配合上IP首部中的源IP地址和目的IP地址就能唯一的确定一个TCP连接；</li>
<li>Sequence Number：用来标识从TCP发送端向TCP接收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节在数据流中的序号，主要用来解决<code>网络报乱序</code>的问题；</li>
<li>Acknowledgment Number：发送确认的一端所期望收到的<strong>下一个序号</strong>，因此，确认序号应当是上次已成功收到数据字节序号加1。不过，只有<strong>当标志位中的ACK标志为1时该确认序列号的字段才有效</strong>，该字段主要用来解决丢包的问题。此外，TCP采用<code>累计确认</code>，即只有当确认字节之前的所有数据都到达之后才能发送确认，这样就可以用一个数字概括接收到的所有数据。</li>
<li>Data offset：用来标识TCP头部的长度，该数字为头部中字(32 bit)的数目，需要这个值是因为任选字段的长度是可变的。这个字段占4bit，因此<strong>TCP最多有60字节的头部</strong>。然而，没有任选字段，正常的长度是20字节；</li>
<li>Reserved：3个保留位，留作以后使用，全部设置为0；</li>
<li>标志位：TCP头部中共有9个标志位，用于操控TCP的状态，主要有URG，ACK，PSH，RST，SYN，FIN，标志位的意思如下：<ul>
<li>URG：此标志表示TCP包的紧急指针域有效，用来保证TCP连接不被中断，并且督促中间层设备要尽快处理这些数据；</li>
<li>ACK：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；</li>
<li>PSH：表示Push操作，数据包到达接收端以后，立即传送给应用程序，而不是在缓冲区中排队；</li>
<li>RST：表示连接复位请求，用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包；</li>
<li>SYN：表示同步序号，用来建立连接。SYN标志位和ACK标志位搭配使用，当连接请求的时候，SYN=1，ACK=0；连接被响应的时候，SYN=1，ACK=1；</li>
<li>FIN：表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了。</li>
</ul>
</li>
<li>Window Size：窗口大小，也就是有名的<code>滑动窗口</code>，用来进行流量控制。指定从被确认的字节算起可以发送多少个字节，窗口大小字段为0是合法的，说明已经接收到了 确认号－1 个字节，但是接收端没有来得及取走数据。</li>
</ul>
<h2 id="三次握手建立连接"><a href="#三次握手建立连接" class="headerlink" title="三次握手建立连接"></a>三次握手建立连接</h2><p>TCP协议提供可靠的连接服务，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，连接是通过三次握手进行初始化的，三次握手的过程如下：</p>
<p><img src="http://7xrlu9.com1.z0.glb.clouddn.com/Network_TCP_3.png" alt=""></p>
<p>前两次握手，客户端进入连接状态，后两次握手，服务器进入连接状态。所以，三次握手之后，一个全双工的连接就建立起来了，之后，客户端和服务器端就可以开始传送数据。</p>
<ul>
<li>第一次握手：客户端发送连接请求报文段，将SYN位设为1，SeqNum为随机数A；</li>
<li>第二次握手：服务器返回ACK，确认收到客户端发来的SYN，然后设置AckNum为A+1；此外，服务器发送自己的连接请求报文段，即发送SYN和随机数B作为SeqNum；</li>
<li>第三次握手：客户端返回ACK，确认收到服务器发来的SYN，然后设置AckNum=B+1。</li>
</ul>
<p><strong>为什么需要三次握手建立连接？</strong></p>
<p>简单来说，为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p>
<p>考虑下面一种情况：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。server收到此失效的连接请求报文段后，误认为是client发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。</p>
<p>假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。</p>
<p>采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”</p>
<h2 id="四次握手断开连接"><a href="#四次握手断开连接" class="headerlink" title="四次握手断开连接"></a>四次握手断开连接</h2><p>客户端和服务器数据传送完毕后，需要断开TCP连接，断开连接的时候需要进行四次握手。</p>
<p><img src="http://7xrlu9.com1.z0.glb.clouddn.com/Network_TCP_4.png" alt=""></p>
<p>四次握手的过程如下：</p>
<ul>
<li>第一次握手：发起端发送FIN和SeqNum=A，进入FIN_WAIT_1状态，用来关闭发起端到接收端的数据传送，也就是告诉接收端：不会再给你发新数据了(<code>当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，发起端依然会重发这些数据</code>)，但此时发起段还可以接受数据；</li>
<li>第二次握手：接收端收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（AckNum=A+1），此时接收端仍然可以给发起段发送数据（同意关闭连接请求，但是我还有数据需要传送，稍等…）；</li>
<li>第三次握手：接收端向发起端发送FIN，用来关闭到发起端的数据传送，也就是告诉发起端：我的数据也发送完了，不会再给你发数据了。此时接收端进入CLOSE_WAIT状态；</li>
<li>第四次握手：发起端发送ACK报文段，然后进入TIME_WAIT状态，接收端收到ACK报文段以后，就关闭连接。发起端等待2MSL后依然没有收到回复，则证明Server端已正常关闭，此时也可以关闭连接了。</li>
</ul>
<p>如果要正确的理解四次分手的原理，还需要了解四次分手过程中的状态变化。</p>
<ul>
<li><code>FIN_WAIT_1</code>: FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态。（主动方）</li>
<li><code>FIN_WAIT_2</code>：FIN_WAIT_2状态下的SOCKET，表示半连接，也即主动方要求断开连接，得到了被动方的确认，但被动方还有数据要发送，因此主动方还得继续接收。（主动方）</li>
<li><code>TIME_WAIT</code>: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED状态了。如果FINWAIT1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（主动方）</li>
<li><code>CLOSE_WAIT</code>：在CLOSE_WAIT状态下，被动方还有数据需要传送。（被动方）</li>
<li><code>LAST_ACK</code>: 被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。（被动方）</li>
<li><code>CLOSED</code>: 表示连接中断。</li>
</ul>
<p><strong>为什么要四次握手断开连接？</strong></p>
<p>TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会中断这次TCP连接。</p>
<p><strong>TIME_WAIT 状态</strong>存在的理由：</p>
<ol>
<li><p><strong>可靠地实现TCP全双工连接的终止</strong>。</p>
<p> 在进行关闭连接四次握手协议时，最后的ACK是由主动关闭端发出的，如果这个最终的ACK丢失，被动关闭方将重发最终的FIN，主动关闭端只有在该连接未关闭的情况下才可以重新发送最终的那个ACK。否则主动关闭端将会响应一个RST，被动端会将此响应标记为错误，从而不能进行正常的关闭。</p>
</li>
<li><p><strong>允许老的重复分节在网络中消逝</strong>。</p>
<p> 假设TCP协议中不存在TIME_WAIT状态的限制，再假设当前有一条TCP连接：(local_ip, local_port, remote_ip,remote_port)，因某些原因，先关闭，接着很快以相同的四元组建立一条新连接。TCP协议栈是无法区分前后两条TCP连接的不同的，在它看来，这根本就是同一条连接，中间先释放再建立的过程对其来说是“感知”不到的。这样就可能发生这样的情况：前一条TCP连接由local peer发送的数据到达remote peer后，会被该remot peer的TCP传输层当做当前TCP连接的正常数据接收并向上传递至应用层（而事实上，在我们假设的场景下，这些旧数据到达remote peer前，旧连接已断开且一条由相同四元组构成的新TCP连接已建立，因此，这些旧数据是不应该被向上传递至应用层的），从而引起数据错乱进而导致各种无法预知的诡异现象。</p>
<p> local peer主动调用close后，此时的TCP连接进入TIME_WAIT状态，处于该状态下的TCP连接不能立即以同样的四元组建立新连接，即发起active close的那方占用的local port在TIME_WAIT期间不能再被重新分配。由于TIME_WAIT状态持续时间为2MSL，这样保证了旧TCP连接双工链路中的旧数据包均因过期（超过MSL）而消失，此后，就可以用相同的四元组建立一条新连接而不会发生前后两次连接数据错乱的情况。</p>
</li>
</ol>
<p>参考 <a href="http://huoding.com/2013/12/31/316" target="_blank" rel="noopener">再叙TIME_WAIT</a>  </p>
<h2 id="TCP-状态转换图"><a href="#TCP-状态转换图" class="headerlink" title="TCP 状态转换图"></a>TCP 状态转换图</h2><p><img src="http://7xrlu9.com1.z0.glb.clouddn.com/Network_TCP_5.png" alt=""></p>
<h2 id="TCP-重传机制"><a href="#TCP-重传机制" class="headerlink" title="TCP 重传机制"></a>TCP 重传机制</h2><p>TCP要保证所有的数据包都可以到达，所以，必需要有重传机制。</p>
<p>注意，接收端给发送端的Ack确认只会确认最后一个连续的包，比如，发送端发了1,2,3,4,5一共五份数据，接收端收到了1，2，于是回ack 3，然后收到了4（注意此时3没收到），此时的TCP会怎么办？我们要知道，SeqNum和Ack是以字节数为单位，所以ack的时候，不能跳着确认，只能确认最大的连续收到的包，不然，发送端就以为之前的都收到了。</p>
<p><code>超时重传机制</code></p>
<p>每次发送数据包时，发送的数据报都有seq号，接收端收到数据后，会回复ack进行确认，表示某一seq号数据已经收到。发送方在发送了某个seq包后，等待一段时间，如果没有收到对应的ack回复，就会认为报文丢失，会重传这个数据包。</p>
<p>针对上面的情况，接收端不回ack，死等3，当发送方发现收不到3的ack超时后，会重传3。一旦接收方收到3后，会ack 回 4——意味着3和4都收到了。但是，这种方式会有比较严重的问题，那就是因为要死等3，所以会导致4和5即便已经收到了，而发送方也完全不知道发生了什么事，因为没有收到Ack，所以，发送方可能会悲观地认为也丢了，所以有可能也会导致4和5的重传。</p>
<p><code>快速重传机制</code></p>
<p>接收数据一方发现有数据包丢掉了。就会发送ack报文告诉发送端重传丢失的报文。如果发送端连续收到标号相同的ack包，则会触发客户端的快速重传。比较超时重传和快速重传，可以发现超时重传是发送端在傻等超时，然后触发重传；而快速重传则是接收端主动告诉发送端数据没收到，然后触发发送端重传。</p>
<p>比如：如果发送方发出了1，2，3，4，5份数据，第一份先到送了，于是就ack回2，结果2因为某些原因没收到，3到达了，于是还是ack回2，后面的4和5都到了，但是还是ack回2，因为2还是没有收到，于是发送端收到了三个ack=2的确认，知道了2还没有到，于是就马上重转2。然后，接收端收到了2，此时因为3，4，5都收到了，于是ack回6。</p>
<h2 id="TCP-滑动窗口"><a href="#TCP-滑动窗口" class="headerlink" title="TCP 滑动窗口"></a>TCP 滑动窗口</h2><p>TCP头里有一个字段叫Window，又叫Advertised-Window，这个字段是<strong>接收端告诉发送端自己还有多少缓冲区可以接收数据</strong>。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。滑动窗可以是提高TCP传输效率的一种机制。<code>要注意滑动窗口只关注发送端和接收端自身的状况，而没有考虑整个网络的通信情况</code>。</p>
<p>为了说明滑动窗口，我们需要先看一下TCP缓冲区的一些数据结构：</p>
<p><img src="http://7xrlu9.com1.z0.glb.clouddn.com/Network_TCP_6.png" alt=""></p>
<p>上图中，我们可以看到：</p>
<ul>
<li>接收端LastByteRead指向了TCP缓冲区中读到的位置，NextByteExpected指向的地方是收到的连续包的最后一个位置，LastByteRcved指向的是收到的包的最后一个位置，我们可以看到中间有些数据还没有到达，所以有数据空白区。</li>
<li>发送端的LastByteAcked指向了被接收端Ack过的位置（表示成功发送确认），LastByteSent表示发出去了，但还没有收到成功确认的Ack，LastByteWritten指向的是上层应用正在写的地方。</li>
</ul>
<p>于是：</p>
<ul>
<li>接收端在给发送端回ACK中会汇报自己的AdvertisedWindow = MaxRcvBuffer – LastByteRcvd – 1;</li>
<li>而发送方会根据这个窗口来控制发送数据的大小，以保证接收方可以处理。</li>
</ul>
<p>下面我们来看一下发送方的滑动窗口示意图：</p>
<p><img src="http://7xrlu9.com1.z0.glb.clouddn.com/Network_TCP_7.png" alt=""></p>
<p>上图中分成了四个部分，分别是：（其中那个黑模型就是滑动窗口）</p>
<ol>
<li>已收到ack确认的数据。</li>
<li>发还没收到ack的。</li>
<li>在窗口中还没有发出的（接收方还有空间）。</li>
<li>窗口以外的数据（接收方没空间）</li>
</ol>
<p>下面是个滑动后的示意图（收到36的ack，并发出了46-51的字节）：</p>
<p><img src="http://7xrlu9.com1.z0.glb.clouddn.com/Network_TCP_8.png" alt=""></p>
<p>下面我们来看一个接收端控制发送端的图示：</p>
<p><img src="http://7xrlu9.com1.z0.glb.clouddn.com/Network_TCP_9.png" alt=""></p>
<p>上图可以看到一个处理缓慢的Server（接收端）是怎么把Client（发送端）的TCP Sliding Window给降成0的。如果Window变成0了，发送端就不发数据了，可以想像成“Window Closed”。（有两种意外情形，第一紧急数据仍可以发送，比如用户杀掉远程机器上运行的某一个进程。第二，发送段可以发送一个用来进行窗口探测的段，下面详细介绍）</p>
<p>Window size 变为0之后，为了防止服务器发来的窗口更新数据包丢失后发生死锁。TCP使用了<code>窗口探测</code>（Zero Window Probe）技术，缩写为ZWP，也就是说发送端在窗口变成0后会发送一个1字节的段给接收方，以便强制接收端重新宣告下一个期望的字节和窗口大小。一般会尝试发送3次，如果3次过后还是0的话，有的TCP实现就会发送RST把连接断开。</p>
<p>此外，发送端不一定接到应用程序传递来的数据就马上把数据传送出去，同样，接收端也不一定必须尽可能快的发送确认段。特别是遇到下面这两种极端情况：</p>
<ol>
<li>发送端每次向 TCP 连接传递一个字节；</li>
<li>接收端每次从 TCP 流中读取一个字节； </li>
</ol>
<p>考虑下面的场景：</p>
<ul>
<li>远程终端连接（SSH）：使用 <code>Nagle 算法</code>避免发送端发送多个小数据包，减轻发送端给网络的负载。（Nagle 算法：数据每次以很少量方式进入到发送端时，发送端只发送第一次到达的数据字节，然后将后面到达的缓存起来，直到发送出去的那个数据包被确认，然后将所有缓冲的字节放在一个 TCP 段中发送出去。并且继续开始缓冲，直到下一个端被确认。）不适用的场景：互动游戏，需要快速的短数据包流。</li>
<li>低能窗口综合症：接收端的交互式应用每次仅能读取一个字节数据。使用<code>延迟确认</code>的优化方法可以避免接收端发送只有一个字节的窗口更新端。Clark解决方案：禁止接收端发送只有1个字节的窗口更新端，强制必须等一段时间，直到有了一定数量的可用空间之后再通知给对方。</li>
</ul>
<h2 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h2><p>TCP通过滑动窗口来做流量控制，但是这还不够，因为滑动窗口仅依赖于连接的发送端和接收端，其并不知道网络中间发生了什么。TCP的设计者觉得，一个伟大而牛逼的协议仅仅做到流量控制并不够，因为流量控制只是网络模型4层以上的事，TCP的还应该更聪明地知道整个网络上的事。</p>
<p>考虑一下这样的场景：某一时刻网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，于是，这个情况就会进入恶性循环被不断地放大。试想一下，如果一个网络内有成千上万的TCP连接都这么行事，那么马上就会形成<code>“网络风暴”</code>，TCP这个协议就会拖垮整个网络。</p>
<p>所以，TCP不能忽略网络上发生的事情，而无脑地一个劲地重发数据，对网络造成更大的伤害。对此TCP的设计理念是：TCP不是一个自私的协议，当拥塞发生的时候，要做自我牺牲。就像交通阻塞一样，每个车都应该把路让出来，而不要再去抢路了。</p>
<p>拥塞控制主要是四个算法（<a href="http://ee.lbl.gov/papers/congavoid.pdf" target="_blank" rel="noopener">相应的论文</a>）：1）慢启动，2）拥塞避免，3）拥塞发生，4）快速恢复。 这四个算法不是一天都搞出来的，它们的发展经历了很多时间，到今天都还在优化中。 </p>
<ul>
<li>1988年，TCP-Tahoe 提出了1）慢启动，2）拥塞避免，3）拥塞发生时的快速重传；</li>
<li>1990年，TCP Reno 在Tahoe的基础上增加了 4）快速恢复</li>
</ul>
<h3 id="慢启动-Slow-Start"><a href="#慢启动-Slow-Start" class="headerlink" title="慢启动(Slow Start)"></a>慢启动(Slow Start)</h3><p>慢启动的意思是，刚刚加入网络的连接，一点一点地提速。慢启动的算法如下(cwnd全称Congestion Window)：</p>
<ol>
<li>连接建好的开始先初始化cwnd = 1，表明可以传一个MSS大小的数据。</li>
<li>每当收到一个ACK，cwnd++; 这样每当过了一个RTT，cwnd = cwnd*2。</li>
<li>还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”</li>
</ol>
<p>所以，我们可以看到，如果网速很快的话，ACK也会返回得快，<code>RTT</code>（Round Trip Time，也就是一个数据包从发出去到回来的时间）也会短，那么，这个慢启动就一点也不慢。下图说明了这个过程。</p>
<p><img src="http://7xrlu9.com1.z0.glb.clouddn.com/Network_TCP_10.jpg" alt=""></p>
<h2 id="拥塞避免算法-Congestion-Avoidance"><a href="#拥塞避免算法-Congestion-Avoidance" class="headerlink" title="拥塞避免算法(Congestion Avoidance)"></a>拥塞避免算法(Congestion Avoidance)</h2><p>ssthresh（slow start threshold）是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”。一般来说ssthresh的值是65535，单位是字节，当cwnd达到这个值时后，算法如下：</p>
<p>收到一个ACK时，cwnd = cwnd + 1/cwnd，这样当每过一个RTT时，cwnd = cwnd + 1</p>
<p>这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。很明显，是一个线性上升的算法。</p>
<h3 id="拥塞发生算法"><a href="#拥塞发生算法" class="headerlink" title="拥塞发生算法"></a>拥塞发生算法</h3><p>前面我们说过，当丢包的时候，会有两种情况：</p>
<p>1）等到RTO超时，重传数据包。TCP认为这种情况太糟糕，反应也很强烈。</p>
<ul>
<li>ssthresh =  cwnd /2</li>
<li>cwnd 重置为 1</li>
<li>进入慢启动过程</li>
</ul>
<p>2）快速重传，也就是在收到3个duplicate ACK时就开启重传，而不用等到RTO超时。</p>
<ul>
<li>TCP Tahoe的实现和RTO超时一样。</li>
<li>TCP Reno(<a href="http://tools.ietf.org/html/rfc5681" target="_blank" rel="noopener">RFC5681</a>, <a href="http://tools.ietf.org/html/rfc6582" target="_blank" rel="noopener">RFC682</a>)的实现是：<ul>
<li>cwnd = cwnd /2</li>
<li>ssthresh = cwnd</li>
<li>按照拥塞避免算法继续线性增长</li>
</ul>
</li>
</ul>
<h2 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h2><p><a href="http://www.cricode.com/3568.html" target="_blank" rel="noopener">图解TCP-IP协议</a><br><a href="http://www.jellythink.com/archives/705" target="_blank" rel="noopener">简析TCP的三次握手与四次分手</a><br><a href="http://coolshell.cn/articles/11564.html" target="_blank" rel="noopener">TCP 的那些事儿（上）</a><br><a href="http://coolshell.cn/articles/11609.html" target="_blank" rel="noopener">TCP 的那些事儿（下）</a>  </p>
<p><a href="http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/overview.html" target="_blank" rel="noopener">TCP keepalive overview</a><br><a href="http://blog.stephencleary.com/2009/05/detection-of-half-open-dropped.html" target="_blank" rel="noopener">Detection of Half-Open (Dropped) Connections</a>  </p>
<hr>
<ul>
<li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p>
</li>
<li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p>
</li>
</ul>
<h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p>
<blockquote>
<p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p>
</blockquote>
<blockquote>
<p>体育&amp;户外用品推荐</p>
</blockquote>
<div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/se-notes/计算机网络基础/ch3-TCP/../more/ads/amazon.gif" width="100%"></a> </div>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/se-notes/计算机网络基础/ch3-TCP/">
    <time datetime="2019-01-03T13:49:30.000Z" class="entry-date">
        1月 3 2019
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/网络通讯/">网络通讯</a>, <a class="article-category-link" href="/categories/网络通讯/计算机网络基础/">计算机网络基础</a>
  </div>

    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/">http</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network/">network</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tcp-ip/">tcp/ip</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/计算机网络/">计算机网络</a></li></ul>

    </footer>
</article>






  
    <article id="post-se-notes/计算机网络基础/ch4-IP" class="post-se-notes/计算机网络基础/ch4-IP post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/se-notes/计算机网络基础/ch4-IP/">ch4-IP</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://wnhby.github.io/se-notes/计算机网络基础/ch4-IP/" data-id="cjsbbbeyn0044e9s6l2kpkyff" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <!-- TOC -->
<ul>
<li><a href="#ip-%E5%9C%B0%E5%9D%80">IP 地址</a></li>
<li><a href="#ip-%E6%8A%A5%E6%96%87">IP 报文</a></li>
<li><a href="#%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE">路由协议</a><ul>
<li><a href="#ads">Ads</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<p>整个的因特网就是一个单一的、抽象的网络。IP地址就是给因特网上的每一个主机（或路由器）的每一个接口分配一个在全世界范围内唯一的32位的标识符。</p>
<h1 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h1><p>每个 32 位的 IP 地址由高位的可变长网络和低位的主机两部分组成。同一网络的所有主机，其地址的网络值是相同的。这意味着一个网络对应一块连续的 IP 地址空间，这块地址空间就称为<code>地址的前缀</code>。如果前缀包含 2^8 个主机地址，那么就留下了 24 位用于网络部分，可以写成 <code>*.*.*.*/24</code>。<code>子网掩码</code>用来与一个 IP 地址进行 AND 操作，提取出该 IP 地址的网络部分。</p>
<p><code>子网划分</code>：在内部将一个网络块分成几个部分供多个内部网络使用，但对外部世界仍像单个网络一样。<br><code>路由聚合</code>：把多个小前缀的地址块合并成一个大前缀的地址块。（解决路由表过大的问题）。</p>
<p>1953年，IP 地址被分为 5 个类别：</p>
<p><img src="http://7xrlu9.com1.z0.glb.clouddn.com/Network_IP_1.png" alt=""></p>
<p>注意全零（0.0.0.0）地址对应于当前主机。全1的IP地址（255.255.255.255）是当前子网的广播地址。</p>
<p>还有三个范围的 IP地址被声明为私有化，任何网络可以在内部随意地使用这些地址，但是不允许包含这些地址的数据包出现在 Internet 上。</p>
<ul>
<li>1  个A类地址：10.0.0.0~10.255.255.255/8      (2^24 个地址) </li>
<li>16 个B类地址：172.16.0.0~172.31.255.255/16   (16 * 2^16 个地址)</li>
<li>256个C类地址：192.168.0.0~192.168.255.255/24 (256*2^8 个地址)</li>
</ul>
<p>保留IP地址不会在internet网上出现，用于企业网络，A企业可以用,B企业也可以使用！</p>
<h1 id="IP-报文"><a href="#IP-报文" class="headerlink" title="IP 报文"></a>IP 报文</h1><p><img src="http://7xrlu9.com1.z0.glb.clouddn.com/Network_IP_2.png" alt=""></p>
<p>报头各字段：</p>
<ul>
<li>版本号（Version）：标识目前采用的IP协议的版本号。一般的值为0100（IPv4），IPv6的值（0110）</li>
<li>头部长度（Header Length）：这个字段的作用是为了描述IP包头的长度，因为在IP包中有变长的可选部分。</li>
<li>服务类型（Type of Service）：这个子段可以拆分成两个部分：Precedence和TOS。TOS目前不太使用。而Precedence则用于QOS应用。（TOS字段的详细描述RFC 1340 1349）</li>
<li>总长（Total Length）：长度16比特。IP包最大长度65535字节。</li>
<li>标识符（Identifier）：该字段和Flags和Fragment Offest字段联合使用，对大的上层数据包进行分段（fragment）操作。</li>
<li>标记（Flags）：该字段第一位不使用。第二位是DF位，DF位设为1时表明路由器不能对该上层数据包分段。如果一个上层数据包无法在不分段的情况下进行转发，则路由器会丢弃该上层数据包并返回一个错误信息。第三位是MF位，当路由器对一个上层数据包分段，则路由器会在除了最后一个分段的IP包的包头中将MF位设为1。</li>
<li>分段序号（Fragment Offset）：该字段对包含分段的上层数据包的IP包赋予序号。由于IP包在网络上传送的时候不一定能按顺序到达，这个字段保证了目标路由器在接受到IP包之后能够还原分段的上层数据包。到某个包含分段的上层数据包的IP包在传送是丢失，则整个一系列包含分段的上层数据包的IP包都会被要求重传。</li>
<li>生存时间（TTL）：TTL长度8 bit，最大值是255，TTL的一个推荐值是64。虽然从字面上翻译，TTL是IP数据包在计算机网络中的存在的最长时间。但实际上TTL是IP数据包在网络中可以转发的最大跳数。TTL字段由IP数据包的发送者设置，在IP数据包从源到目的的整个转发路径上，每经过一个路由器，把该TTL的值减1，然后再将IP包转发出去。如果在IP包到达目的IP之前，TTL减少为0，路由器将会丢弃收到的TTL=0的IP包并向发送者发送 ICMP time exceeded消息。TTL的主要作用是避免IP包在网络中的无限循环和收发，节省了网络带宽，并能使IP包的发送者能收到告警消息。这个字段可以防止由于故障而导致IP包在网络中不停被转发。</li>
<li>起源和目标地址（Source and Destination Addresses）：这两个地段都是32比特。标识了这个IP包的起源和目标地址。</li>
</ul>
<h1 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h1><p>在互联网中，网络结构是相当复杂的（存在复杂的局域网或广域网），若想要将数据包从一个主机成功发送到目的主机，则需要合理的路由将数据转发最终发送到目的主机。而要使路由能够正确的工作，需要路由控制模块和相关的<code>路由协议</code>来支持路由的工作。</p>
<hr>
<ul>
<li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p>
</li>
<li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p>
</li>
</ul>
<h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p>
<blockquote>
<p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p>
</blockquote>
<blockquote>
<p>体育&amp;户外用品推荐</p>
</blockquote>
<div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/se-notes/计算机网络基础/ch4-IP/../more/ads/amazon.gif" width="100%"></a> </div>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/se-notes/计算机网络基础/ch4-IP/">
    <time datetime="2019-01-03T13:49:30.000Z" class="entry-date">
        1月 3 2019
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/网络通讯/">网络通讯</a>, <a class="article-category-link" href="/categories/网络通讯/计算机网络基础/">计算机网络基础</a>
  </div>

    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/">http</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network/">network</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tcp-ip/">tcp/ip</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/计算机网络/">计算机网络</a></li></ul>

    </footer>
</article>






  
    <article id="post-se-notes/计算机网络基础/ch5-Web" class="post-se-notes/计算机网络基础/ch5-Web post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/se-notes/计算机网络基础/ch5-Web/">ch5-Web</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://wnhby.github.io/se-notes/计算机网络基础/ch5-Web/" data-id="cjsbbbeyp0049e9s6y3k9k163" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <!-- TOC -->
<ul>
<li><a href="#为什么需要高并发">为什么需要高并发？</a><ul>
<li><a href="#慢客户端">慢客户端</a></li>
</ul>
</li>
<li><a href="#web-服务器并发处理">Web 服务器并发处理</a><ul>
<li><a href="#nginx">nginx</a></li>
</ul>
</li>
<li><a href="#高并发解决方案">高并发解决方案</a><ul>
<li><a href="#html静态化">HTML静态化</a></li>
<li><a href="#图片服务器分离">图片服务器分离</a></li>
<li><a href="#数据库集群库表散列">数据库集群、库表散列</a></li>
<li><a href="#缓存">缓存</a></li>
<li><a href="#镜像">镜像</a></li>
<li><a href="#负载均衡">负载均衡</a></li>
<li><a href="#cdn加速技术">CDN加速技术</a></li>
</ul>
</li>
<li><a href="#更多阅读">更多阅读</a><pre><code>- [Ads](#ads)
</code></pre></li>
</ul>
<!-- /TOC -->
<p>简单来说，一台服务器在单位时间里能处理的请求越多，服务器的能力越高，也就是服务器并发处理能力越强。</p>
<h1 id="为什么需要高并发？"><a href="#为什么需要高并发？" class="headerlink" title="为什么需要高并发？"></a>为什么需要高并发？</h1><p>相比十年前，互联网已得到了广泛的普及与应用。现在我们甚至难以想象离开互联网的世界。</p>
<p>从最初基于 NCSA 进化到基于Apache web 提供的可进行简单文本操作的html，再到目前的全世界20亿用户永久在线媒介。互联网一直在高速进化，即时信息与娱乐服务变得更加轻盈精巧，在线业务的安全可靠性也发生了显著变化。因此，当下的网站服务比之前变得更复杂，web引擎需要在工程上更具健壮性和可扩展性。</p>
<p><strong>并发一直是web体系结构最大的挑战之一</strong>。自web services应用以来，并发能力持续增长。流行站点服务10w甚至100w的访问量非常常见。</p>
<p>十年前，影响并发的主要因素是客户端缓慢－－用户使用ADSL或者拨号连接网络。现在，并发增长主要是由移动端和新的应用架构引起，这些应用采用长链接以便能让用户及时更新消息，微博和朋友圈等等。<br>浏览器行为的变化是另一个导致并发增长的原因，现代浏览器访问网站时一般会打开4～6个并发以提高页面加载速度。</p>
<h2 id="慢客户端"><a href="#慢客户端" class="headerlink" title="慢客户端"></a>慢客户端</h2><p>设想一个基于Apache的简单网站服务器，该服务器生成相对简短的100K的返回体–由文本或图片组成的简单页面。服务器耗费了不到一秒的时间生成一个页面，但是在80kbps(10KB/s)的网络环境下却耗费了10秒传输到客户端。网站服务器相对较快地推送10KB的内容，却需要在释放连接前耗费10秒钟将内容发送到客户端。</p>
<p>现在设想有1000个客户端同时连接上，请求类似的内容。假设仅分配1M内存给每个客户端，那么就是说，1000个客户端，100KB的请求内容，服务端却要消耗1G的内存。</p>
<p>事实上，一个典型的基于Apache的网站服务器需要为每个client分配超过1M的内存，而移动端的有效速度往往也在几十kbps。针对发送内容到客户端低效这个问题，虽然提高操作系统内核的socket缓冲区的大小，能一定程度上解决缓解问题，但是并不是一个通用的解决方案，并且有无法预期的副作用。</p>
<h1 id="Web-服务器并发处理"><a href="#Web-服务器并发处理" class="headerlink" title="Web 服务器并发处理"></a>Web 服务器并发处理</h1><p><strong>单进程</strong>：此种架构方式中，web服务器一次处理一个请求，结束后读取并处理下一个请求。在某请求处理过程中，其它所有的请求将被忽略，因此，在并发请求较多的场景中将会出现严重的性能问题。</p>
<p><strong>多进程/多线程</strong>：此种架构方式中，web服务器生成多个进程或线程并行处理多个用户请求，进程或线程可以按需或事先生成。有的web服务器应用程序为每个用户请求生成一个单独的进程或线程来进行响应，不过，一旦并发请求数量达到成千上万时，多个同时运行的进程或线程将会消耗大量的系统资源。</p>
<p><strong>I/O多路复用</strong>：为了能够支持更多的并发用户请求，越来越多的web服务器正在采用多种复用的架构：即<strong>同步监控所有的连接请求的活动状态，当一个连接的状态发生改变时(如数据准备完毕或发生某错误)，将为其执行一系列特定操作</strong>；在操作完成后，此连接将重新变回暂时的稳定态并返回至打开的连接列表中，直到下一次的状态改变。由于其多路复用的特性，进程或线程不会被空闲的连接所占用，因而可以提供高效的工作模式。</p>
<p><strong>基于事件的模型</strong>：一个进程处理多个请求，并且通过epoll机制来通知用户请求完成。</p>
<h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><p>nginx采用了模块化、事件驱动、异步、单线程及非阻塞的架构，并大量采用了多路复用及事件通知机制。在nginx中，连接请求由为数不多的几个仅包含一个线程的进程worker以高效的回环(run-loop)机制进行处理，而每个worker可以并行处理数千个的并发连接及请求。</p>
<p>Nginx会按需同时运行多个进程：一个主进程(master)和几个工作进程(worker)，配置了缓存时还会有缓存加载器进程(cache loader)和缓存管理器进程(cache manager)等。所有进程均是仅含有一个线程，并主要通过“共享内存”的机制实现进程间通信。主进程以root用户身份运行，而worker、cache loader和cache manager均应以非特权用户身份运行。</p>
<p>主进程主要完成如下工作：</p>
<ol>
<li>读取并验正配置信息；</li>
<li>创建、绑定及关闭套接字；</li>
<li>启动、终止及维护worker进程的个数；</li>
<li>无须中止服务而重新配置工作特性；</li>
<li>控制非中断式程序升级，启用新的二进制程序并在需要时回滚至老版本；</li>
<li>重新打开日志文件；</li>
<li>编译嵌入式perl脚本；</li>
</ol>
<p>worker进程主要完成的任务包括：</p>
<ol>
<li>接收、传入并处理来自客户端的连接；</li>
<li>提供反向代理及过滤功能；</li>
<li>nginx任何能完成的其它任务；</li>
</ol>
<p>如果负载以CPU密集型应用为主，如SSL或压缩应用，则worker数应与CPU数相同；如果负载以IO密集型为主，如响应大量内容给客户端，则worker数应该为CPU个数的1.5或2倍</p>
<h1 id="高并发解决方案"><a href="#高并发解决方案" class="headerlink" title="高并发解决方案"></a>高并发解决方案</h1><p>随着互联网业务的不断丰富，网站相关的技术经过这些年的发展，已经细分到很细的方方面面，尤其对于大型网站来说，所采用的技术更是涉及面非常广，从硬件到软件、编程语言、数据库、WebServer、防火墙等各个领域都有了很高的要求，已经不是原来简单的html静态网站所能比拟的。</p>
<p>大型网站，比如门户网站，在面对大量用户访问、高并发请求方面，基本的解决方案集中在这样几个环节：使用高性能的服务器、高性能的数据库、高效率的编程语言、还有高性能的Web容器。</p>
<h2 id="HTML静态化"><a href="#HTML静态化" class="headerlink" title="HTML静态化"></a>HTML静态化</h2><p>效率最高、消耗最小的就是纯静态化的html页面，所以我们尽可能使我们的网站上的页面采用静态页面来实现，这个最简单的方法其实也是最有效的方法。但是对于大量内容并且频繁更新的网站，我们无法全部手动去挨个实现，于是出现了我们常见的信息发布系统CMS，像我们常访问的各个门户站点的新闻频道，甚至他们的其他频道，都是通过信息发布系统来管理和实现的，信息发布系统可以实现最简单的信息录入自动生成静态页面，还能具备频道管理、权限管理、自动抓取等功能，对于一个大型网站来说，拥有一套高效、可管理的CMS是必不可少的。</p>
<p>除了门户和信息发布类型的网站，对于交互性要求很高的社区类型网站来说，尽可能的静态化也是提高性能的必要手段，将社区内的帖子、文章进行实时的静态化、有更新的时候再重新静态化也是大量使用的策略，像Mop的大杂烩就是使用了这样的策略，网易社区等也是如此。</p>
<p>同时，html静态化也是某些缓存策略使用的手段，对于系统中频繁使用数据库查询但是内容更新很小的应用，可以考虑使用html静态化来实现。比如论坛中论坛的公用设置信息，这些信息目前的主流论坛都可以进行后台管理并且存储在数据库中，这些信息其实大量被前台程序调用，但是更新频率很小，可以考虑将这部分内容进行后台更新的时候进行静态化，这样避免了大量的数据库访问请求。</p>
<h2 id="图片服务器分离"><a href="#图片服务器分离" class="headerlink" title="图片服务器分离"></a>图片服务器分离</h2><p>对于Web服务器来说，不管是Apache、IIS还是其他容器，图片是最消耗资源的，于是我们有必要将图片与页面进行分离，这是基本上大型网站都会采用的策略，他们都有独立的、甚至很多台的图片服务器。这样的架构可以降低提供页面访问请求的服务器系统压力，并且可以保证系统不会因为图片问题而崩溃。</p>
<p>在应用服务器和图片服务器上，可以进行不同的配置优化，比如apache在配置ContentType的时候可以尽量少支持、尽可能少的LoadModule，保证更高的系统消耗和执行效率。</p>
<h2 id="数据库集群、库表散列"><a href="#数据库集群、库表散列" class="headerlink" title="数据库集群、库表散列"></a>数据库集群、库表散列</h2><p>大型网站都有复杂的应用，这些应用必须使用数据库，那么在面对大量访问的时候，数据库的瓶颈很快就能显现出来，这时一台数据库将很快无法满足应用，于是我们需要使用数据库集群或者库表散列。</p>
<p>在数据库集群方面，很多数据库都有自己的解决方案，Oracle、Sybase等都有很好的方案，常用的MySQL提供的Master/Slave也是类似的方案，您使用了什么样的DB，就参考相应的解决方案来实施即可。</p>
<p>上面提到的数据库集群由于在架构、成本、扩张性方面都会受到所采用DB类型的限制，于是我们需要从应用程序的角度来考虑改善系统架构，库表散列是常用并且最有效的解决方案。</p>
<p>我们在应用程序中安装业务和应用或者功能模块将数据库进行分离，不同的模块对应不同的数据库或者表，再按照一定的策略对某个页面或者功能进行更小的数据库散列，比如用户表，按照用户ID进行表散列，这样就能够低成本的提升系统的性能并且有很好的扩展性。</p>
<p>sohu的论坛就是采用了这样的架构，将论坛的用户、设置、帖子等信息进行数据库分离，然后对帖子、用户按照板块和ID进行散列数据库和表，最终可以在配置文件中进行简单的配置便能让系统随时增加一台低成本的数据库进来补充系统性能。</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>缓存一词搞技术的都接触过，很多地方用到缓存。网站架构和网站开发中的缓存也是非常重要。</p>
<p>架构方面的缓存，对Apache比较熟悉的人都能知道Apache提供了自己的缓存模块，也可以使用外加的Squid模块进行缓存，这两种方式均可以有效的提高Apache的访问响应能力。</p>
<p>网站程序开发方面的缓存，Linux上提供的Memory Cache是常用的缓存接口，可以在web开发中使用，比如用java开发的时候就可以调用MemoryCache对一些数据进行缓存和通讯共享，一些大型社区使用了这样的架构。另外，在使用web语言开发的时候，各种语言基本都有自己的缓存模块和方法，PHP有Pear的Cache模块，Java就更多了，.net不是很熟悉，相信也肯定有。</p>
<h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>镜像是大型网站常采用的提高性能和数据安全性的方式，镜像的技术可以解决不同网络接入商和地域带来的用户访问速度差异，比如ChinaNet和EduNet之间的差异就促使了很多网站在教育网内搭建镜像站点，数据进行定时更新或者实时更新。在镜像的细节技术方面，这里不阐述太深，有很多专业的现成的解决架构和产品可选。也有廉价的通过软件实现的思路，比如Linux上的rsync等工具。</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>负载均衡将是大型网站解决高负荷访问和大量并发请求采用的高端解决办法。负载均衡技术发展了多年，有很多专业的服务提供商和产品可以选择，我个人接触过一些解决方法，其中有两个架构可以给大家做参考。</p>
<p>硬件四层交换：第四层交换使用第三层和第四层信息包的报头信息，根据应用区间识别业务流，将整个区间段的业务流分配到合适的应用服务器进行处理。</p>
<p>第四层交换功能就像是虚IP，指向物理服务器。它传输的业务服从的协议多种多样，有HTTP、FTP、NFS、Telnet或其他协议。这些业务在物理服务器基础上，需要复杂的载量平衡算法。在IP世界，业务类型由终端TCP或UDP端口地址来决定，在第四层交换中的应用区间则由源端和终端IP地址、TCP和UDP端口共同决定。</p>
<p>在硬件四层交换产品领域，有一些知名的产品可以选择，比如Alteon、F5等，这些产品很昂贵，但是物有所值，能够提供非常优秀的性能和很灵活的管理能力。“Yahoo中国”当初接近2000台服务器，只使用了三、四台Alteon就搞定了。</p>
<p>软件四层交换：大家知道了硬件四层交换机的原理后，基于OSI模型来实现的软件四层交换也就应运而生，这样的解决方案实现的原理一致，不过性能稍差。但是满足一定量的压力还是游刃有余的，有人说软件实现方式其实更灵活，处理能力完全看你配置的熟悉能力。</p>
<p>软件四层交换我们可以使用Linux上常用的LVS来解决，LVS就是Linux Virtual Server，他提供了基于心跳线heartbeat的实时灾难应对解决方案，提高系统的强壮性，同时可供了灵活的虚拟VIP配置和管理功能，可以同时满足多种应用需求，这对于分布式的系统来说必不可少。</p>
<p>一个典型的使用负载均衡的策略就是，在软件或者硬件四层交换的基础上搭建squid集群，这种思路在很多大型网站包括搜索引擎上被采用，这样的架构低成本、高性能还有很强的扩张性，随时往架构里面增减节点都非常容易。</p>
<p>对于大型网站来说，前面提到的每个方法可能都会被同时使用到，这里介绍得比较浅显，具体实现过程中很多细节还需要大家慢慢熟悉和体会。有时一个很小的squid参数或者apache参数设置，对于系统性能的影响就会很大。</p>
<h2 id="CDN加速技术"><a href="#CDN加速技术" class="headerlink" title="CDN加速技术"></a>CDN加速技术</h2><p>CDN的全称是内容分发网络。其目的是通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络“边缘”，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。</p>
<p>CDN有别于镜像，因为它比镜像更智能，或者可以做这样一个比喻：CDN=更智能的镜像+缓存+流量导流。因而，CDN可以明显提高Internet网络中信息流动的效率。从技术上全面解决由于网络带宽小、用户访问量大、网点分布不均等问题，提高用户访问网站的响应速度。</p>
<p>CDN的实现分为三类：镜像、高速缓存、专线。</p>
<ul>
<li>镜像站点（Mirror Site），是最常见的，它让内容直接发布，适用于静态和准动态的数据同步。但是购买和维护新服务器的费用较高，还必须在各个地区设置镜像服务器，配备专业技术人员进行管理与维护。对于大型网站来说，更新所用的带宽成本也大大提高了。</li>
<li>高速缓存，成本较低，适用于静态内容。Internet的统计表明，超过80%的用户经常访问的是20%的网站的内容，在这个规律下，缓存服务器可以处理大部分客户的静态请求，而原始的服务器只需处理约20%左右的非缓存请求和动态请求，于是大大加快了客户请求的响应时间，并降低了原始服务器的负载。CDN服务一般会在全国范围内的关键节点上放置缓存服务器。</li>
<li>专线，让用户直接访问数据源，可以实现数据的动态同步。</li>
</ul>
<p>CDN的实例：举个例子来说，当某用户访问网站时，网站会利用全球负载均衡技术，将用户的访问指向到距离用户最近的正常工作的缓存服务器上，直接响应用户的请求。</p>
<p>当用户访问已经使用了CDN服务的网站时，其解析过程与传统解析方式的最大区别就在于网站的授权域名服务器不是以传统的轮询方式来响应本地DNS的解析请求，而是充分考虑用户发起请求的地点和当时网络的情况，来决定把用户的请求定向到离用户最近同时负载相对较轻的节点缓存服务器上。</p>
<p>通过用户定位算法和服务器健康检测算法综合后的数据，可以将用户的请求就近定向到分布在网络“边缘”的缓存服务器上，保证用户的访问能得到更及时可靠的响应。</p>
<p>由于大量的用户访问都由分布在网络边缘的CDN节点缓存服务器直接响应了，这就不仅提高了用户的访问质量，同时有效地降低了源服务器的负载压力。</p>
<h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><p><a href="http://blog.arganzheng.me/posts/how-to-improve-server-concurrency.html" target="_blank" rel="noopener">如何提高服务器并发处理能力</a><br><a href="http://andremouche.github.io/nginx/nginx-introduction-I.html" target="_blank" rel="noopener">Nginx介绍(为什么高并发很重要)</a><br><a href="http://andremouche.github.io/nginx/nginx-introduction-II.html" target="_blank" rel="noopener">Nginx介绍(Nginx架构综述)</a><br><a href="http://www.360doc.com/content/15/0907/11/7256015_497436359.shtml" target="_blank" rel="noopener">Web服务器处理并发连接请求的工作模型</a><br><a href="http://www.jianshu.com/p/dd2fc7119bab" target="_blank" rel="noopener">Web网站高并发量的解决方案</a>  </p>
<hr>
<ul>
<li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p>
</li>
<li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p>
</li>
</ul>
<h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p>
<blockquote>
<p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p>
</blockquote>
<blockquote>
<p>体育&amp;户外用品推荐</p>
</blockquote>
<div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/se-notes/计算机网络基础/ch5-Web/../more/ads/amazon.gif" width="100%"></a> </div>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/se-notes/计算机网络基础/ch5-Web/">
    <time datetime="2019-01-03T13:49:30.000Z" class="entry-date">
        1月 3 2019
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/网络通讯/">网络通讯</a>, <a class="article-category-link" href="/categories/网络通讯/计算机网络基础/">计算机网络基础</a>
  </div>

    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/">http</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network/">network</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tcp-ip/">tcp/ip</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/计算机网络/">计算机网络</a></li></ul>

    </footer>
</article>






  
    <article id="post-se-notes/计算机网络基础/ch6-Socket" class="post-se-notes/计算机网络基础/ch6-Socket post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/se-notes/计算机网络基础/ch6-Socket/">ch6-Socket</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://wnhby.github.io/se-notes/计算机网络基础/ch6-Socket/" data-id="cjsbbbeys004ce9s6oj7utds5" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <!-- TOC -->
<ul>
<li><a href="#socket-属性">Socket 属性</a></li>
<li><a href="#socket-接口函数">Socket 接口函数</a><ul>
<li><a href="#服务器端函数">服务器端函数</a></li>
<li><a href="#客户端函数">客户端函数</a></li>
<li><a href="#通用函数">通用函数</a></li>
</ul>
</li>
<li><a href="#tcp-通信">TCP 通信</a></li>
<li><a href="#udp-socket函数">UDP Socket函数</a></li>
<li><a href="#更多阅读">更多阅读</a><pre><code>- [Ads](#ads)
</code></pre></li>
</ul>
<!-- /TOC -->
<p>Socket 起源于 Unix，而Unix基本哲学之一就是<code>一切皆文件</code>，都可以用“<code>打开open –&gt; 读写write/read –&gt; 关闭close</code>”模式来操作。Socket就是该模式的一个实现，网络的Socket数据传输是一种特殊的I/O，Socket也是一种文件描述符。</p>
<p>Socket也具有一个类似于打开文件的函数调用：Socket()，该函数返回一个整型的Socket描述符，随后的连接建立、数据传输等操作都是通过该Socket实现的。使用TCP/IP协议的应用程序通常采用应用编程接口：UNIX BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰），来实现网络进程之间的通信。</p>
<h1 id="Socket-属性"><a href="#Socket-属性" class="headerlink" title="Socket 属性"></a>Socket 属性</h1><p>套接字的特性由3个属性确定，它们分别是：域、类型和协议。</p>
<ol>
<li><p>套接字的域：它指定<strong>套接字通信中使用的网络介质</strong>，最常见的套接字域是AF_INET，它指的是Internet网络。当客户使用套接字进行跨网络的连接时，它就需要用到服务器计算机的IP地址和端口来指定一台联网机器上的某个特定服务，所以在使用socket作为通信的终点，服务器应用程序必须在开始通信之前绑定一个端口，服务器在指定的端口等待客户的连接。另一个域AF_UNIX表示UNIX文件系统，它就是文件输入/输出，而它的地址就是文件名。</p>
</li>
<li><p>套接字类型：因特网提供了两种通信机制：流（stream）和数据报（datagram），因而套接字的类型也就分为流套接字和数据报套接字。这里主要讲流套接字。</p>
<p> 流套接字由类型SOCK_STREAM指定，它们是在AF_INET域中通过TCP/IP连接实现，同时也是AF_UNIX中常用的套接字类型。流套接字提供的是一个<strong>有序、可靠、双向字节流</strong>的连接，因此发送的数据可以确保不会丢失、重复或乱序到达，而且它还有一定的出错后重新发送的机制。</p>
<p> 与流套接字相对的是由类型SOCK_DGRAM指定的数据报套接字，它不需要建立连接和维持一个连接，它们在AF_INET中通常是通过UDP/IP协议实现的。它对可以发送的数据的长度有限制，数据报作为一个单独的网络消息被传输,它可能会丢失、复制或错乱到达，UDP不是一个可靠的协议，但是它的速度比较高，因为它并一需要总是要建立和维持一个连接。</p>
</li>
<li><p>套接字协议：只要底层的传输机制允许不止一个协议来提供要求的套接字类型，我们就可以为套接字选择一个特定的协议。通常只需要使用默认值。</p>
</li>
</ol>
<h1 id="Socket-接口函数"><a href="#Socket-接口函数" class="headerlink" title="Socket 接口函数"></a>Socket 接口函数</h1><p>既然socket是“open—write/read—close”模式的一种实现，那么socket就提供了这些操作对应的函数接口。下面以TCP为例，介绍几个基本的socket接口函数。</p>
<p><code>socket函数</code>：<strong>使用给定的协议族、套接字类型、协议编号（默认为0）来创建套接字</strong>。</p>
<p>socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而socket()用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。</p>
<pre><code>int socket(int domain, int type, int protocol);
</code></pre><p>socket函数的三个参数分别为：</p>
<ul>
<li>domain：<code>协议域</code>。常用的协议族有AF_INET、AF_INET6等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合。</li>
<li>type：<code>socket类型</code>。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等。</li>
<li>protocol：<code>指定协议</code>。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP等，它们分别对应TCP传输协议、UDP传输协议。</li>
</ul>
<p>注意：type和protocol不可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。</p>
<p>我们调用socket创建一个socket后，返回的socket描述符存在于协议族空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。</p>
<h2 id="服务器端函数"><a href="#服务器端函数" class="headerlink" title="服务器端函数"></a>服务器端函数</h2><p><code>bind函数</code>：<strong>将套接字绑定到地址。</strong></p>
<pre><code>int bind(int sockfd, struct sockaddr * my_addr, int addrlen);
</code></pre><p>三个参数分别为：</p>
<ul>
<li>sockfd : 即socket描述字，通过socket()函数创建，唯一标识一个socket。</li>
<li>my_addr : 结构体指针变量，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同。</li>
<li>addrlen : 对应的是地址的长度。</li>
</ul>
<p>通常服务器在启动的时候都会绑定一个地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。</p>
<p><code>listen函数</code>：使服务器的这个端口和IP处于监听状态，等待网络中某一客户机的连接请求。如果客户端有连接请求，端口就会接受这个连接。</p>
<pre><code>int listen(int sockfd, int backlog);
</code></pre><p>两个参数分别为：</p>
<ul>
<li>sockfd: socket描述字。</li>
<li>backlog: 指定同时能处理的最大连接要求，通常为10或者5。最大值可设至128。</li>
</ul>
<p><code>accept函数</code>：接受远程计算机的连接请求，建立起与客户机之间的通信连接。服务器处于监听状态时，如果某时刻获得客户机的连接请求，此时并不是立即处理这个请求，而是将这个请求放在等待队列中，当系统空闲时再处理客户机的连接请求。</p>
<pre><code>int accept(int sockfd, struct sockaddr * addr,int * addrlen);
</code></pre><p>三个参数分别为：</p>
<ul>
<li>sockfd : socket描述字。</li>
<li>addr: 为结构体指针变量，和bind的结构体是同种类型的，系统会把远程主机的信息（远程主机的地址和端口号信息）保存到这个指针所指的结构体中。</li>
<li>addrlen : 表示结构体的长度</li>
</ul>
<p>accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为<code>监听socket描述字</code>；而accept函数返回的是<code>已连接的socket描述字</code>。一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。</p>
<h2 id="客户端函数"><a href="#客户端函数" class="headerlink" title="客户端函数"></a>客户端函数</h2><p><code>connect函数</code>用来请求连接远程服务器.</p>
<pre><code>int connect (int sockfd,struct sockaddr * serv_addr,int addrlen);
</code></pre><p>三个参数分别为：</p>
<ul>
<li>sockfd : socket描述字，前面socket的返回值；</li>
<li>serv_addr : 存储着远程服务器的IP与端口号信息；</li>
<li>addrlen : 表示结构体变量的长度。</li>
</ul>
<h2 id="通用函数"><a href="#通用函数" class="headerlink" title="通用函数"></a>通用函数</h2><p><code>recv函数</code>：负责从缓冲区中读取内容。当读成功时，read返回实际所读的字节数，如果返回的值是0表示已经读到文件的结束了，小于0表示出现了错误。</p>
<pre><code>int recv(int sockfd,void *buf,int len,unsigned int flags);
</code></pre><p>四个参数分别为：</p>
<ul>
<li>sockfd : 为前面accept的返回值.也就是新的套接字。</li>
<li>buf : 表示缓冲区</li>
<li>len : 表示缓冲区的长度</li>
<li>flags : 通常为0</li>
</ul>
<p><code>send函数</code>：将buf中的n bytes字节内容写入socket描述字。成功时返回写的字节数。失败时返回-1，并设置errno变量。</p>
<pre><code>int send(int sockfd,const void * msg,int len,unsigned int flags);
</code></pre><ul>
<li>sockfd : 为前面socket的返回值.</li>
<li>msg : 一般为常量字符串</li>
<li>len : 表示长度</li>
<li>flags : 通常为0</li>
</ul>
<p><code>close函数</code>：关闭套接字。若顺利关闭则返回0，发生错误时返回-1。</p>
<pre><code>int close(int sockfd);
</code></pre><h1 id="TCP-通信"><a href="#TCP-通信" class="headerlink" title="TCP 通信"></a>TCP 通信</h1><p>TCP中 Socket 通信的基本步骤如下：</p>
<p><img src="http://7xrlu9.com1.z0.glb.clouddn.com/Network_Socket_1.png" alt=""></p>
<p>一个简单的 C/S 程序如下（客户端发出的数据, 服务器会回显到客户端的终端上。只是一个简单的模型, 没考虑错误处理等问题。）</p>
<p>服务器端如下：</p>
<pre><code>import socket   # socket模块

BUF_SIZE = 1024  # 设置缓冲区大小
server_addr = (&apos;127.0.0.1&apos;, 8888)  # IP和端口构成表示地址

server = socket.socket(socket.AF_INET,
                       socket.SOCK_STREAM)   # 生成一个新的socket对象
server.setsockopt(socket.SOL_SOCKET,
                  socket.SO_REUSEADDR, 1)    # 设置地址复用
server.bind(server_addr)  # 绑定地址
server.listen(5)          # 监听, 最大监听数为5
while True:
    client, client_addr = server.accept()  # 接收TCP连接, 并返回新的套接字和地址
    print &apos;Connected by&apos;, client_addr
    while True:
        data = client.recv(BUF_SIZE)       # 从客户端接收数据
        print data
        client.sendall(data)               # 发送数据到客户端
server.close()
</code></pre><p>客户端如下：</p>
<pre><code>import socket

BUF_SIZE = 1024
server_addr = (&apos;127.0.0.1&apos;, 8888)
client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect(server_addr)
while True:
    data = raw_input(&quot;Please input some string &gt; &quot;)
    client.sendall(data)
    data = client.recv(BUF_SIZE)
    print data
client.close()
</code></pre><p>不过真实的网络编程环境中，一定要使用大量的错误处理，可以尽量的发现错误，也能够使代码显得更加严谨。</p>
<p>三次握手<br>SYN_SENT    connect() 阻塞 — accept() 阻塞 SYS_RCV<br>ESTABLISHED connect() 返回 — accept() 返回 ESTABLISHED</p>
<p>四次挥手<br>FIN_WAIT1 close() 阻塞 — read() 读 0 字节 LAST_ACK<br>FIN_WAIT2 close()</p>
<h1 id="UDP-Socket函数"><a href="#UDP-Socket函数" class="headerlink" title="UDP Socket函数"></a>UDP Socket函数</h1><p><code>sendto()</code>函数：发送UDP数据，将数据发送到套接字。返回实际发送的数据字节长度或在出现发送错误时返回-1。</p>
<pre><code>int sendto(int sockfd, const void *msg,int len,unsigned int flags,const struct sockaddr *to, int tolen);
</code></pre><p><code>recvfrom()</code>函数：接受UDP套接字的数据, 与recv()类似。返回接收到的字节数或当出现错误时返回-1，并置相应的errno。</p>
<pre><code>int recvfrom(int sockfd,void *buf,int len,unsigned int flags,struct sockaddr *from,int *fromlen);
</code></pre><p>UDP通信流程图如下：</p>
<p><img src="http://7xrlu9.com1.z0.glb.clouddn.com/Network_Socket_2.png" alt=""></p>
<p>简单的客户端服务器UDP连接，服务器端：</p>
<pre><code>#!/usr/bin/env python
# -*- coding:utf-8 -*-

import socket

BUF_SIZE = 1024                     # 设置缓冲区大小
server_addr = (&apos;127.0.0.1&apos;, 8888)   # IP和端口构成表示地址

# 生成新的套接字对象
server = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
server.bind(server_addr)        # 套接字绑定IP和端口

while True:
  print &quot;waitting for data&quot;
  # 从客户端接收数据
  data, client_addr = server.recvfrom(BUF_SIZE)
  print &apos;Connected by&apos;, client_addr, &apos; Receive Data : &apos;, data
  # 发送数据给客户端
  server.sendto(data, client_addr)
server.close()
</code></pre><p>客户端如下：</p>
<pre><code>import socket

BUF_SIZE = 1024                     # 设置缓冲区
    server_addr = (&apos;127.0.0.1&apos;, 8888)   # IP和端口构成表示地址

client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
while True:
  data = raw_input(&apos;Please Input data &gt; &apos;)
  client.sendto(data, server_addr)  # 向服务器发送数据
  data, addr = client.recvfrom(BUF_SIZE)  # 从服务器接收数据
  print &quot;Data : &quot;, data
client.close()
</code></pre><h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><p><a href="http://www.jianshu.com/p/90348ef3f41e" target="_blank" rel="noopener">Socket通信原理简介</a><br><a href="http://www.cnblogs.com/dolphinX/p/3460545.html" target="_blank" rel="noopener">简单理解Socket</a><br><a href="http://www.jianshu.com/p/e062b3dd110c" target="_blank" rel="noopener">Python爬虫(三)-Socket网络编程</a><br><a href="http://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html" target="_blank" rel="noopener">Linux Socket编程（不限Linux）</a>  </p>
<hr>
<ul>
<li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p>
</li>
<li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p>
</li>
</ul>
<h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p>
<blockquote>
<p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p>
</blockquote>
<blockquote>
<p>体育&amp;户外用品推荐</p>
</blockquote>
<div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/se-notes/计算机网络基础/ch6-Socket/../more/ads/amazon.gif" width="100%"></a> </div>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/se-notes/计算机网络基础/ch6-Socket/">
    <time datetime="2019-01-03T13:49:30.000Z" class="entry-date">
        1月 3 2019
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/网络通讯/">网络通讯</a>, <a class="article-category-link" href="/categories/网络通讯/计算机网络基础/">计算机网络基础</a>
  </div>

    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/">http</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network/">network</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tcp-ip/">tcp/ip</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/计算机网络/">计算机网络</a></li></ul>

    </footer>
</article>






  
    <article id="post-se-notes/计算机网络基础/ch7-More" class="post-se-notes/计算机网络基础/ch7-More post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/se-notes/计算机网络基础/ch7-More/">ch7-More</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://wnhby.github.io/se-notes/计算机网络基础/ch7-More/" data-id="cjsbbbeyu004he9s6icn82nrf" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <!-- TOC -->
<ul>
<li><a href="#网络延迟">网络延迟</a></li>
<li><a href="#以太网工作模式">以太网工作模式</a></li>
<li><a href="#路由权">路由权</a></li>
<li><a href="#路由器与交换机区别">路由器与交换机区别</a><ul>
<li><a href="#ads">Ads</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="网络延迟"><a href="#网络延迟" class="headerlink" title="网络延迟"></a>网络延迟</h2><p>在传输介质中传输所用的时间，即从报文开始进入网络到它开始离开网络之间的时间。(网络延迟PING值越低速度越快)</p>
<ul>
<li>1~30ms:极快，几乎察觉不出有延迟，玩任何游戏速度都特别顺畅</li>
<li>31~50ms:良好，可以正常游戏，没有明显的延迟情况</li>
<li>51~100ms:普通，对抗类游戏能感觉出明显延迟，稍有停顿</li>
<li><blockquote>
<p>100ms:差，无法正常游戏，有卡顿，丢包并掉线现象</p>
</blockquote>
</li>
</ul>
<h2 id="以太网工作模式"><a href="#以太网工作模式" class="headerlink" title="以太网工作模式"></a>以太网工作模式</h2><p>常用的以太网卡支持以下工作模式：<code>广播模式、多播模式、直接模式和混杂模式</code>。</p>
<ol>
<li>广播模式（Broad Cast Model）：物理地址（MAC）地址是 0Xffffff 的帧为广播帧，工作在广播模式的网卡接收广播帧。它将会接收所有目的地址为广播地址的数据包，一般所有的网卡都会设置为这个模式。</li>
<li>多播模式（MultiCast Model）：多播传送地址作为目的物理地址的帧可以被组内的其它主机同时接收，而组外主机却接收不到。但是，如果将网卡设置为多播传送模式，它可以接收所有的多播传送帧，而不论它是不是组内成员。</li>
<li>直接模式（Direct Model）：工作在直接模式下的网卡只接收目地址是自己Mac地址的帧。只有当数据包的目的地址为网卡自己的地址时，网卡才接收它。</li>
<li>混杂模式（Promiscuous Model）：工作在混杂模式下的网卡接收所有的流过网卡的帧，信包捕获程序就是在这种模式下运行的。网卡的缺省工作模式包含广播模式和直接模式，即它只接收广播帧和发给自己的帧。如果采用混杂模式，一个站点的网卡将接受同一网络内所有站点所发送的数据包这样就可以到达对于网络信息监视捕获的目的。它将接收所有经过的数据包，这个特性是编写网络监听程序的关键。</li>
</ol>
<h2 id="路由权"><a href="#路由权" class="headerlink" title="路由权"></a>路由权</h2><p>路由权是衡量路由好坏的标准。路由算法修改路由表的基本目的是将最好路由信息添加到路由表中，路由的好坏是由路由算法根据自己获得的路由信息计算出来的。</p>
<p>对于每一条路由，路由算法产生一种权值来表示路由的好坏。通常情况下，这种权值越小，该路径越好。路由权的计算可能基于路径某单一特性计算，也可能基于路径多种属性进行计算。有几种路径特性经常被用于权值计算，如下：</p>
<ul>
<li>带宽 – 链路的数据容量。例如，通常情况下10M 以太网链路比 64K 出租线路要更好。</li>
<li>时延 – 报文到达目标网络所需要的时间。</li>
<li>负载 – 处于活跃状态的网络资源数量。</li>
<li>可靠性 – 每条数据链路的出错率。</li>
<li>跳数 – 报文到目的地需要经过的网络数。</li>
<li>开销 – 一种人为设定的值，通常由网络管理员根据带宽、线路价格或其他一些因素综合得出。</li>
</ul>
<h2 id="路由器与交换机区别"><a href="#路由器与交换机区别" class="headerlink" title="路由器与交换机区别"></a>路由器与交换机区别</h2><p>工作层次不同：最初的的交换机是工作在数据链路层，而路由器一开始就设计工作在网络层。由于交换机工作在数据链路层，所以它的工作原理比较简单，而路由器工作在网络层，可以得到更多的协议信息，路由器可以做出更加智能的转发决策。 </p>
<p>数据转发所依据的对象不同：交换机是利用物理地址或者说MAC地址来确定转发数据的目的地址。而路由器则是利用IP地址来确定数据转发的地址。IP地址是在软件中实现的，描述的是设备所在的网络。MAC地址通常是硬件自带的，由网卡生产商来分配的，而且已经固化到了网卡中去，一般来说是不可更改的。而IP地址则通常由网络管理员或系统自动分配。 </p>
<p>传统的交换机只能分割冲突域，不能分割广播域；而路由器可以分割广播域。由交换机连接的网段仍属于同一个广播域，广播数据包会在交换机连接的所有网段上传播，在某些情况下会导致通信拥挤和安全漏洞。连接到路由器上的网段会被分配成不同的广播域，广播数据不会穿过路由器。虽然第三层以上交换机具有VLAN功能，也可以分割广播域，但是各子广播域之间是不能通信交流的，它们之间的交流仍然需要路由器。 </p>
<p>路由器提供了防火墙的服务：路由器仅仅转发特定地址的数据包，不传送不支持路由协议的数据包传送和未知目标网络数据包的传送，从而可以防止广播风暴。</p>
<hr>
<ul>
<li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p>
</li>
<li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p>
</li>
</ul>
<h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p>
<blockquote>
<p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p>
</blockquote>
<blockquote>
<p>体育&amp;户外用品推荐</p>
</blockquote>
<div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/se-notes/计算机网络基础/ch7-More/../more/ads/amazon.gif" width="100%"></a> </div>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/se-notes/计算机网络基础/ch7-More/">
    <time datetime="2019-01-03T13:49:30.000Z" class="entry-date">
        1月 3 2019
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/网络通讯/">网络通讯</a>, <a class="article-category-link" href="/categories/网络通讯/计算机网络基础/">计算机网络基础</a>
  </div>

    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/">http</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network/">network</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tcp-ip/">tcp/ip</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/计算机网络/">计算机网络</a></li></ul>

    </footer>
</article>






  
    <article id="post-se-notes/计算机网络基础/ch8-Questions" class="post-se-notes/计算机网络基础/ch8-Questions post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/se-notes/计算机网络基础/ch8-Questions/">ch8-Questions</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://wnhby.github.io/se-notes/计算机网络基础/ch8-Questions/" data-id="cjsbbbeyw004ke9s6ec09jk4f" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <!-- TOC -->
<ul>
<li><a href="#访问网页过程">访问网页过程</a><ul>
<li><a href="#ping-过程">Ping 过程</a></li>
</ul>
</li>
<li><a href="#qq-传输层udp">QQ 传输层UDP</a></li>
<li><a href="#更多阅读">更多阅读</a><pre><code>- [Ads](#ads)
</code></pre></li>
</ul>
<!-- /TOC -->
<h1 id="访问网页过程"><a href="#访问网页过程" class="headerlink" title="访问网页过程"></a>访问网页过程</h1><p>从网络模型的角度来分析，主要涉及</p>
<ul>
<li>应用层：DNS、HTTP；</li>
<li>传输层：TCP</li>
<li>网络层：IP，路由选择协议RIP，OSPF(内部网关协议),BGP(外部网关协议）</li>
<li>数据链路层：ARP</li>
</ul>
<p><code>应用层</code>：客户端浏览器发起一个HTTP会话到服务器。客户端浏览器通过 DNS 解析到 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 的IP地址，通过这个IP地址找到客户端到服务器的路径。</p>
<p><code>传输层</code>：在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口（服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000），和服务器建立 TCP 连接后进行通信。</p>
<p><code>网络层</code>：客户端的网络层不关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器。其中可能用到的路由选择协议有 RIP协议、OSPF协议、EGP协议。</p>
<p><code>链路层</code>：包从路由器到达服务器的局域网后，通过 ARP 协议查找服务器IP地址对应的MAC地址，然后将数据帧传到服务器。</p>
<h2 id="Ping-过程"><a href="#Ping-过程" class="headerlink" title="Ping 过程"></a>Ping 过程</h2><p>ping 程序用来探测主机到主机之间是否可通信，如果不能ping到某台主机，表明不能和这台主机建立连接。ping 使用的是ICMP协议，它发送icmp回送请求消息给目的主机。ICMP协议规定：目的主机必须返回ICMP回送应答消息给源主机。如果源主机在一定时间内收到应答，则认为主机可达。</p>
<p>假定主机A的IP地址是192.168.1.1，主机B的IP地址是192.168.1.2，都在同一子网内，则当你在主机A上运行“Ping 192.168.1.2”后，都发生了些什么呢?</p>
<p>首先，Ping命令会构建一个固定格式的ICMP请求数据包，然后由ICMP协议将这个数据包连同地址“192.168.1.2”一起交给IP层协议（和ICMP一样，实际上是一组后台运行的进程），IP层协议将以地址“192.168.1.2”作为目的地址，本机IP地址作为源地址，加上一些其他的控制信息，构建一个IP数据包，并在通过 ARP 协议查找出IP地址192.168.1.2所对应的物理地址，一并交给数据链路层。后者构建一个数据帧，目的地址是IP层传过来的物理地址，源地址则是本机的物理地址，还要附加上一些控制信息，依据以太网的介质访问规则，将它们传送出去。</p>
<p>主机B收到这个数据帧后，先检查它的目的地址，并和本机的物理地址对比，如符合，则接收；否则丢弃。接收后检查该数据帧，将IP数据包从帧中提取出来，交给本机的IP层协议。同样，IP层检查后，将有用的信息提取后交给ICMP协议，后者处理后，马上构建一个ICMP应答包，发送给主机A，其过程和主机A发送ICMP请求包到主机B一模一样。</p>
<h1 id="QQ-传输层UDP"><a href="#QQ-传输层UDP" class="headerlink" title="QQ 传输层UDP"></a>QQ 传输层UDP</h1><p>QQ 为什么采用 UDP 协议？</p>
<p>最本质上UDP的优势还是<code>带宽的利用</code>。这一切要回归到99~03年的网络状况，当时网络的特点就是接入带宽很窄而且抖动特别厉害。所谓抖动可能是多方面的，例如延时突发性地暴增、也有可能是由于路由层面的变化突然导致路由黑洞，还各种等等等等的问题。TCP因为拥塞控制、保证有序等原因，在这种网络状态上对带宽的利用是非常低的。而且因为网络抖动的原因，应用层心跳超时（一般不依靠keepalive）应用层主动断掉socket之后TCP需要三次握手才能重新建立链接，一旦出现频繁的小抖动就会使得带宽利用更低。而等待四次挥手的时间，也会占用服务器上宝贵的资源。总结来说，当网络差到一定程度了，TCP的优势反而会成为劣势。</p>
<p>使用UDP对抗网络抖动，说到底就是在应用层比TCP更快地探测和重传，一旦超过一定的时间没有收到回复，客户端可以选择马上重试，在服务器端则可以果断地断掉socket。而可以应用UDP的时候，往往是你的应用层协议本身已经具备了一定的面向连接的特性。如果你应用层的协议已经达到了一定程度的消息幂等，客户端可以几乎无脑地进行重传，这样就可以尽可能地降低网络抖动的影响，同时也可以尽可能地利用整个带宽。而刚好QQ的协议，就具备类似的特点。</p>
<p>简单来说就是我们可以使用UDP实现一个面向连接协议，这个协议可以很好地适应当时的网络状况和QQ本身的业务。但凡事都有成本，成本就是你的应用层协议本身需要去实现抵抗网络异常带来的问题。例如<code>乱序</code>、重传，业务数据的分片和重组、网络状态探测等。</p>
<p>（当然，也可能是因为当时没有epoll这种可以支持成千上万tcp并发连接的技术，所以他们使用了udp，然后在udp上面封装了模拟tcp，解决大并发的问题。）</p>
<h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><p><a href="http://www.nowcoder.com/discuss/3853" target="_blank" rel="noopener">在浏览器中输入URL后执行的全部过程的个人总结</a><br><a href="https://www.zhihu.com/question/20292749" target="_blank" rel="noopener">QQ 为什么采用 UDP 协议，而不采用 TCP 协议实现</a>  </p>
<hr>
<ul>
<li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p>
</li>
<li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p>
</li>
</ul>
<h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p>
<blockquote>
<p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p>
</blockquote>
<blockquote>
<p>体育&amp;户外用品推荐</p>
</blockquote>
<div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/se-notes/计算机网络基础/ch8-Questions/../more/ads/amazon.gif" width="100%"></a> </div>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/se-notes/计算机网络基础/ch8-Questions/">
    <time datetime="2019-01-03T13:49:30.000Z" class="entry-date">
        1月 3 2019
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/网络通讯/">网络通讯</a>, <a class="article-category-link" href="/categories/网络通讯/计算机网络基础/">计算机网络基础</a>
  </div>

    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/">http</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network/">network</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tcp-ip/">tcp/ip</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/计算机网络/">计算机网络</a></li></ul>

    </footer>
</article>






  
    <article id="post-se-notes/计算机网络基础/ch9-SS_Surge" class="post-se-notes/计算机网络基础/ch9-SS_Surge post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/se-notes/计算机网络基础/ch9-SS_Surge/">ch9-SS_Surge</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://wnhby.github.io/se-notes/计算机网络基础/ch9-SS_Surge/" data-id="cjsbbbeyz004oe9s6yvka3reg" class="leave-reply bdsharebuttonbox" data-cmd="more">分享</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <!-- TOC -->
<ul>
<li><a href="#shadowsocks%E7%9A%84%E5%8E%9F%E7%90%86">ShadowSocks的原理</a></li>
<li><a href="#%E6%89%A9%E5%B1%95">扩展</a></li>
<li><a href="#surge-%E6%98%AF%E4%BB%80%E4%B9%88">surge 是什么</a></li>
<li><a href="#%E6%9B%B4%E5%A4%9A%E9%98%85%E8%AF%BB">更多阅读</a><ul>
<li><a href="#ads">Ads</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h1 id="ShadowSocks的原理"><a href="#ShadowSocks的原理" class="headerlink" title="ShadowSocks的原理"></a>ShadowSocks的原理</h1><p>Shadowsocks 基于 Socks5协议，将代理服务器拆开成Server端和client端，然后通过以下方式进行通信：</p>
<p><img src="http://7xrlu9.com1.z0.glb.clouddn.com/Network_ShadowSocks_1.png" alt=""></p>
<ol>
<li>PC客户端（即你的电脑）发出请求基于Socks5协议跟SS-Local端进行通讯;</li>
<li>SS-Local和SS-Server两端通过多种可选的加密方法进行通讯;</li>
<li>SS-Server将收到的加密数据进行解密，还原初始请求，再发送到用户需要访问的服务网站，获取响应原路再返回到客户端。</li>
</ol>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>为什么不应该用 SSL 翻墙？</p>
<p>SSL 设计目标:</p>
<ol>
<li>防内容篡改</li>
<li>防冒充服务器身份</li>
<li>加密通信内容</li>
</ol>
<p>而翻墙的目标:</p>
<ol>
<li>不被检测出客户端在访问什么网站</li>
<li>不被检测出服务器在提供翻墙服务</li>
</ol>
<p>SSL 和这个目标还是有一些出入。其中最大的问题是防冒充服务器身份这个功能多余了。他会导致墙嗅探出证书信息，继而墙会知道服务器身份。如果墙知道一个服务器身份是用来翻墙的，它要做的仅仅是封掉使用这个证书的所有 IP。</p>
<h1 id="surge-是什么"><a href="#surge-是什么" class="headerlink" title="surge 是什么"></a>surge 是什么</h1><blockquote>
<p>如果你还没听过 Surge，你就有点落后了，如果你还没用过 Surge，很抱歉你错过了好多。</p>
</blockquote>
<p><a href="http://surge.run/manual/" target="_blank" rel="noopener">Surge</a> 是一款开发者调试和代理工具，一经推出便备受大家瞩目，赢的一片赞誉。最开始时，它只是一款 iOS 9 上的网络调试工具，较适用于开发人员。现在，还有了 Mac 版。目前功能可以说是强大至极，包括广告过滤（再也看不到各种讨厌的广告），科学上网等，绝对值得所有人拥有。</p>
<h1 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h1><p><a href="http://drops.wooyun.org/papers/10177" target="_blank" rel="noopener">翻墙路由器的原理与实现</a><br><a href="https://plus.google.com/+GhostAssassin/posts/TtWFAQmSMVE" target="_blank" rel="noopener">翻墙软件的选择与安全系数</a><br><a href="https://plus.google.com/+GhostAssassin/posts/a8aKzvZLsuV" target="_blank" rel="noopener">关于翻墙和匿名与网络安全类科普文大集合</a><br><a href="https://medium.com/@scomper/surge-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-a1533c10e80b" target="_blank" rel="noopener">Surge 新手使用指南</a><br><a href="https://medium.com/@scomper/surge-for-mac-%E7%AE%80%E6%98%8E%E6%8C%87%E5%8D%97-f6f357b8f09c" target="_blank" rel="noopener">Surge for Mac 简明指南</a>  </p>
<hr>
<ul>
<li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p>
</li>
<li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p>
</li>
</ul>
<h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p>
<blockquote>
<p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p>
</blockquote>
<blockquote>
<p>体育&amp;户外用品推荐</p>
</blockquote>
<div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/se-notes/计算机网络基础/ch9-SS_Surge/../more/ads/amazon.gif" width="100%"></a> </div>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/se-notes/计算机网络基础/ch9-SS_Surge/">
    <time datetime="2019-01-03T13:49:30.000Z" class="entry-date">
        1月 3 2019
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/网络通讯/">网络通讯</a>, <a class="article-category-link" href="/categories/网络通讯/计算机网络基础/">计算机网络基础</a>
  </div>

    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/">http</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network/">network</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tcp-ip/">tcp/ip</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/计算机网络/">计算机网络</a></li></ul>

    </footer>
</article>






  
  

</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="q">
        <input type="submit" id="searchsubmit" value="google搜索">
    </div>
</form></aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/系统剩余空间查看/">系统剩余空间查看</a>
          </li>
        
          <li>
            <a href="/数据库分类/">数据库分类</a>
          </li>
        
          <li>
            <a href="/se-notes/Linux基础/README/">Linux基础-README</a>
          </li>
        
          <li>
            <a href="/se-notes/云计算实践/区块链相关/区块链简介/">区块链简介</a>
          </li>
        
          <li>
            <a href="/se-notes/云计算实践/集群高可用方案/Heartbeat双机热备方案/">Heartbeat双机热备方案</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Archives</h3>
    <div class="widget-content">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a><span class="archive-list-count">56</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">一月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">十一月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">一月 2014</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-content">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Graphics/">Graphics</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">7</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/Shell/">Shell</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/linux基础/">linux基础</a><span class="category-list-count">6</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/协议证书/">协议证书</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/协议证书/openssl/">openssl</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">4</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/数据库基础/">数据库基础</a><span class="category-list-count">3</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/框架/">框架</a><span class="category-list-count">9</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/框架/python-web应用框架/">python-web应用框架</a><span class="category-list-count">9</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/版本控制/">版本控制</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/版本控制/Git/">Git</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程语言/">编程语言</a><span class="category-list-count">13</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/编程语言/java/">java</a><span class="category-list-count">13</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络通讯/">网络通讯</a><span class="category-list-count">11</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/网络通讯/大小端/">大小端</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络通讯/计算机网络基础/">计算机网络基础</a><span class="category-list-count">10</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/路由器/">路由器</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/路由器/openwrt/">openwrt</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/通用技术/">通用技术</a><span class="category-list-count">13</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/通用技术/Docker/">Docker</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/通用技术/云计算实践/">云计算实践</a><span class="category-list-count">11</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/通用技术/云计算实践/kubernetes部署/">kubernetes部署</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/通用技术/云计算实践/区块链/">区块链</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/通用技术/云计算实践/集群高可用方案/">集群高可用方案</a><span class="category-list-count">4</span></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/默认/">默认</a><span class="category-list-count">1</span></li></ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-content">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CS-Notes/">CS-Notes</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PEM证书/">PEM证书</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell/">Shell</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cron/">cron</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/database/">database</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/diagrams/">diagrams</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker-qq/">docker-qq</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flask/">flask</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/graphics/">graphics</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/informationisbeautiful/">informationisbeautiful</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java基础/">java基础</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java语法/">java语法</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kubernetes/">kubernetes</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network/">network</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/openssl/">openssl</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/openwrt/">openwrt</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/p12/">p12</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pfx/">pfx</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tcp-ip/">tcp/ip</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web开发/">web开发</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/云计算/">云计算</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/区块链/">区块链</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/大小端/">大小端</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/系统管理/">系统管理</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机网络/">计算机网络</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/集群/">集群</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/默认/">默认</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-content tagcloud">
      <a href="/tags/CS-Notes/" style="font-size: 10px;">CS-Notes</a> <a href="/tags/PEM证书/" style="font-size: 10px;">PEM证书</a> <a href="/tags/Shell/" style="font-size: 10px;">Shell</a> <a href="/tags/cron/" style="font-size: 10px;">cron</a> <a href="/tags/database/" style="font-size: 10px;">database</a> <a href="/tags/diagrams/" style="font-size: 10px;">diagrams</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/docker-qq/" style="font-size: 10px;">docker-qq</a> <a href="/tags/flask/" style="font-size: 16.25px;">flask</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/graphics/" style="font-size: 10px;">graphics</a> <a href="/tags/http/" style="font-size: 17.5px;">http</a> <a href="/tags/informationisbeautiful/" style="font-size: 10px;">informationisbeautiful</a> <a href="/tags/java基础/" style="font-size: 20px;">java基础</a> <a href="/tags/java语法/" style="font-size: 20px;">java语法</a> <a href="/tags/kubernetes/" style="font-size: 13.75px;">kubernetes</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/mysql/" style="font-size: 11.25px;">mysql</a> <a href="/tags/network/" style="font-size: 17.5px;">network</a> <a href="/tags/openssl/" style="font-size: 10px;">openssl</a> <a href="/tags/openwrt/" style="font-size: 10px;">openwrt</a> <a href="/tags/p12/" style="font-size: 10px;">p12</a> <a href="/tags/pfx/" style="font-size: 10px;">pfx</a> <a href="/tags/tcp-ip/" style="font-size: 17.5px;">tcp/ip</a> <a href="/tags/web开发/" style="font-size: 16.25px;">web开发</a> <a href="/tags/云计算/" style="font-size: 18.75px;">云计算</a> <a href="/tags/区块链/" style="font-size: 10px;">区块链</a> <a href="/tags/大小端/" style="font-size: 10px;">大小端</a> <a href="/tags/数据库/" style="font-size: 12.5px;">数据库</a> <a href="/tags/系统管理/" style="font-size: 15px;">系统管理</a> <a href="/tags/计算机网络/" style="font-size: 17.5px;">计算机网络</a> <a href="/tags/集群/" style="font-size: 13.75px;">集群</a> <a href="/tags/默认/" style="font-size: 10px;">默认</a>
    </div>
  </aside>

  
    <aside class="widget">
    <h3 class="widget-title">Links</h3>
    <div class="widget-content">
		<ul id="link-list">
		<!-- link begin -->

		<li><a href="https://www.google.com/">google</a></li>
		<li><a href="https://www.baidu.com/">baidu</a></li>
		
		<!-- link end -->
		</ul>
    </div>
</aside>

  
    <aside class="widget">
    <h3 class="widget-title">Ads</h3>
    <div class="widget-content">
	 
			* <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;">
			<br><br>
			* 体育&户外用品推荐>
			<div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5"><img src="/more/ads/amazon.gif" width="100%"></a> </div>

    </div>
</aside>

  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2019 momoda
    All rights reserved.</p>
    <p>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></p>
    <a href="javascript:scrollTo(0,0);">返回顶部</a>
</footer>

    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>

<script src="/js/jquery-2.0.3.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

<script src="/js/navigation.js"></script>


<script type="text/javascript" src="https://js.users.51.la/19862371.js"></script>
<div id="bg"></div>

  </div>
</body>
</html>