<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Just another blog</title>
  <icon>https://www.gravatar.com/avatar/83dad19bf42039d033d062e2d9174776</icon>
  <subtitle>momoda blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wnhby.github.io/"/>
  <updated>2019-01-23T13:22:20.924Z</updated>
  <id>https://wnhby.github.io/</id>
  
  <author>
    <name>momoda</name>
    <email>momoda</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>系统剩余空间查看</title>
    <link href="https://wnhby.github.io/%E7%B3%BB%E7%BB%9F%E5%89%A9%E4%BD%99%E7%A9%BA%E9%97%B4%E6%9F%A5%E7%9C%8B/"/>
    <id>https://wnhby.github.io/系统剩余空间查看/</id>
    <published>2019-01-10T08:11:51.000Z</published>
    <updated>2019-01-23T13:22:20.924Z</updated>
    
    <content type="html"><![CDATA[<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"><span class="meta">#</span> 系统剩余磁盘空间查看等报告</span><br><span class="line">echo report date = `date`</span><br><span class="line">echo -e "\n"</span><br><span class="line"></span><br><span class="line">echo "MEM INFO:"</span><br><span class="line">echo mem total = `free -g |grep 'Mem' |awk '&#123;print $2&#125;'`G</span><br><span class="line">echo mem used = `free -g |grep 'Mem' |awk '&#123;print $3&#125;'`G</span><br><span class="line">echo -e "\n" </span><br><span class="line"></span><br><span class="line">echo "PROCESS INFO:"</span><br><span class="line">echo process num = `ps -elf |wc -l`</span><br><span class="line">echo zombie process num =`ps -elf |awk '&#123;print $2&#125;'|grep 'Z' |wc -l`</span><br><span class="line">echo -e "\n"</span><br><span class="line"></span><br><span class="line">echo "DISK SPACE INFO:"</span><br><span class="line">echo root_space_total = `df -h |grep '/dev/sda' |awk '&#123;print $2&#125;'`</span><br><span class="line">echo root_space_used = `df -h |grep '/dev/sda' |awk '&#123;print $3&#125;'`</span><br><span class="line">echo root_space_avliable = `df -h |grep '/dev/sda' |awk '&#123;print $4&#125;'`</span><br><span class="line">echo root_space_used_percent =  `df -h |grep '/dev/sda' |awk '&#123;print $5&#125;'`</span><br></pre></td></tr></table></figure><h2 id="result"><a href="#result" class="headerlink" title="result"></a>result</h2><div align="center"> <img src="/系统剩余空间查看/2019-01-10 17-45-58屏幕截图.png" width="400px"><br>图1. 系统剩余空间查看示例</div><br><br><br>—<br><br><em> <a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </em> <a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a><br><br><br>### Ads<br><br><em>这是小广告! 如果有需要, 不妨支持一下吧~</em><br><br>&gt;  <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"><br><br>&gt; 体育&amp;户外用品推荐<br><div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/系统剩余空间查看/../more/ads/amazon.gif" width="100%"></a> </div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;code&quot;&gt;&lt;a href=&quot;#code&quot; class=&quot;headerlink&quot; title=&quot;code&quot;&gt;&lt;/a&gt;code&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
      <category term="Linux" scheme="https://wnhby.github.io/categories/Linux/"/>
    
      <category term="Shell" scheme="https://wnhby.github.io/categories/Linux/Shell/"/>
    
    
      <category term="Shell" scheme="https://wnhby.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>数据库分类</title>
    <link href="https://wnhby.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E7%B1%BB/"/>
    <id>https://wnhby.github.io/数据库分类/</id>
    <published>2019-01-07T13:46:03.000Z</published>
    <updated>2019-01-23T13:22:12.892Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库分类"><a href="#数据库分类" class="headerlink" title="数据库分类"></a>数据库分类</h2><div align="center"> <img src="/数据库分类/pics/database.png" width="100%"> </div><hr><ul><li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p></li><li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p></li></ul><h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p><blockquote><p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p></blockquote><blockquote><p>体育&amp;户外用品推荐</p></blockquote><div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/数据库分类/../more/ads/amazon.gif" width="100%"></a> </div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据库分类&quot;&gt;&lt;a href=&quot;#数据库分类&quot; class=&quot;headerlink&quot; title=&quot;数据库分类&quot;&gt;&lt;/a&gt;数据库分类&lt;/h2&gt;&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;/数据库分类/pics/database.png&quot; widt
      
    
    </summary>
    
      <category term="数据库" scheme="https://wnhby.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://wnhby.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="database" scheme="https://wnhby.github.io/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础-README</title>
    <link href="https://wnhby.github.io/se-notes/Linux%E5%9F%BA%E7%A1%80/README/"/>
    <id>https://wnhby.github.io/se-notes/Linux基础/README/</id>
    <published>2019-01-03T13:49:30.000Z</published>
    <updated>2019-02-19T05:20:41.536Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#简介">简介</a></li><li><a href="#操作系统的特征">操作系统的特征</a></li><li><a href="#操作系统目标">操作系统目标</a></li><li><a href="#操作系统的运行机制">操作系统的运行机制</a></li><li><a href="#系统调用">系统调用</a><ul><li><a href="#标准库函数">标准库函数</a></li></ul></li><li><a href="#中断和异常">中断和异常</a></li><li><a href="#用户态内核态">用户态、内核态</a></li><li><a href="#-操作系统发展">* 操作系统发展</a><pre><code>- [手工操作阶段（此阶段无操作系统）](#手工操作阶段此阶段无操作系统)- [批处理阶段](#批处理阶段)- [分时操作系统](#分时操作系统)- [实时操作系统](#实时操作系统)- [分布式计算机系统](#分布式计算机系统)- [Ads](#ads)</code></pre></li></ul><!-- /TOC --><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>操作系统（Operating System, OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境的程序集合。计算机操作系统是随着计算机研究和应用的发展逐步形成并发展起来的，它是计算机系统中最基本的系统软件。</p><blockquote><p>操作系统三大功能：资源管理与分配、调度工作流程、封装接口与提供环境</p></blockquote><h1 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h1><p>操作系统是一种系统软件，但与其他的系统软件和应用软件有很大的不同，它有自己的基本特征。操作系统的基本特征包括<strong>并发</strong>、<strong>共享</strong>、<strong>虚拟</strong>和<strong>异步</strong>。</p><ul><li>并发（Concurrence）：并发是指多个事件在同一时间间隔内发生。操作系统的并发性是指计算机系统中同时存在多个运行着的程序，因此它具有处理和调度多个程序同时执行的能力。在操作系统中，引入进程的目的是使程序能并发执行。</li><li>共享（Sharing）：资源共享是指系统中的资源可供内存中多个并发执行的进程共同使用。共享可分为以下两种资源共享方式：<ul><li>互斥共享方式：系统中的某些资源，如打印机、磁带机，虽然它们可以提供给多个进程使用，但为使所打印或记录的结果不致造成混淆，应规定在一段时间内只允许一个进程访问该资源。</li><li>同时访问方式：系统中还有另一类资源，允许在一段时间内由多个进程同时对它们进行访问。这里所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问即 “分时共享”。典型的可供多个进程“同时”访问的资源是磁盘设备，一些文件也可以被“同时”共享，即若干个用户同时访问该文件。</li></ul></li></ul><blockquote><p>PS：并发和共享是操作系统两个最基本的特征，这两者之间又是互为存在条件的：资源共享是以程序的并发为条件的，若系统不允许程序并发执行，则自然不存在资源共享问题；若系统不能对资源共享实施有效的管理，也必将影响到程序的并发执行，甚至根本无法并发执行。</p></blockquote><ul><li><p>虛拟（Virtual）：虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。用于实现虚拟的技术，称为虚拟技术。在操作系统中利用了多种虚拟技术，分别用来实现虚拟处理器、虚拟内存和虚拟外部设备等。</p><ul><li>如在虚拟处理器技术中，利用多道程序设计技术（即同时把多个程序放入内存，并允许它们交替在CPU中运行），把一个物理上的 CPU 虚拟为多个逻辑上的 CPU 。</li></ul></li><li><p>异步（Asynchronism）：在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p></li></ul><h1 id="操作系统目标"><a href="#操作系统目标" class="headerlink" title="操作系统目标"></a>操作系统目标</h1><p>为了给多道程序提供良好的运行环境，操作系统作为计算机系统资源的管理者具有以下几方面的功能：</p><ul><li>处理机管理（进程线程管理）：在多道程序环境下，处理机的分配和运行都以进程（或线程）为基本单位，因而对处理机的管理可归结为对进程（或线程）的管理。并发时在计算机内同时运行多个进程，进程何时创建、何时撤销、如何管理、如何避免冲突、合理共享是进程管理的主要任务。</li><li>存储器管理：存储器管理是为了给多道程序的运行提供良好的环境，方便用户使用以及提高内存的利用率。</li><li>文件管理：计算机中的信息都是以文件的形式存在的，操作系统中负责文件管理的部分称为文件系统。</li><li>设备管理：设备管理的主要任务是完成用户的I/O请求，方便用户使用各种设备。</li></ul><p>为方便用户使用计算机，操作系统还提供了用户接口。操作系统提供的接口主要分为两类，一类是命令接口，用户利用这些操作命令来组织和控制作业的执行；另一类是程序接口，编程人员可以使用它们来请求操作系统服务。</p><h1 id="操作系统的运行机制"><a href="#操作系统的运行机制" class="headerlink" title="操作系统的运行机制"></a>操作系统的运行机制</h1><p>计算机系统中，通常 CPU 执行两种不同性质的程序：一种是操作系统内核程序；另一种是用户自编程序或系统外层的应用程序。对操作系统而言，这两种程序的作用不同，前者是后者的管理者，因此“管理程序”要执行一些特权指令，而“被管理程序”出于安全考虑不能执行这些指令。所谓特权指令，是指计算机中不允许用户直接使用的指令，如 I/O 指令、 置中断指令，存取用于内存保护的寄存器、送程序状态字到程序状态字寄存器等指令。操作系统在具体实现上划分了用户态和核心态，以严格区分两类程序。</p><p>内核是计算机上配置的底层软件，是计算机功能的延伸。不同系统对内核的定义稍有区别，大多数<strong>操作系统内核</strong>包括以下四个方面：</p><ul><li><p>时钟管理：在计算机的各种部件中，时钟是最关键的设备。操作系统需要通过时钟管理，向用户提供标准的系统时间。另外通过时钟中断的管理，可以实现进程的切换。诸如，在分时操作系统中，釆用时间片轮转调度的实现；在实时系统中，按截止时间控制运行的实现；在批处理系统中，通过时钟管理来衡量一个作业的运行程度等。</p></li><li><p>中断机制：引入中断技术的初衷是提高多道程序运行环境中 CPU 的利用率，而且主要是针对外部设备的。后来逐步得到发展，形成了多种类型，成为操作系统各项操作的基础。例如，键盘或鼠标信息的输入、进程的管理和调度、系统功能的调用、设备驱动、文件访问等，无不依赖于中断机制。可以说，现代操作系统是靠中断驱动的软件。</p></li><li><p>原语：按层次结构设计的操作系统，底层是一些可被调用的公用小程序，它们各自完成一个规定的操作。其特点是：它们处于操作系统的最底层，是最接近硬件的部分。这些程序的运行具有原子性，运行时间较短，而且调用频繁。通常把具有这些特点的程序称为原语（Atomic Operation）。定义原语的直接方法是关闭中断，让它的所有动作不可分割地进行完再打开中断。系统中的设备驱动、CPU 切换、进程通信等功能中的部分操作都可以定义为原语，使它们成为内核的组成部分。</p></li><li><p>系统控制的数据结构及处理：系统中用来登记状态信息的数据结构很多，比如作业控制块、进程控制块(PCB)、设备控制块、各类链表、消息队列、缓冲区、空闲区登记表、内存分配表等。为了实现有效的管理，系统需要一些基本的操作，常见的操作有以下三种：</p><ul><li>进程管理：进程状态管理、进程调度和分派、创建与撤销进程控制块等。</li><li>存储器管理：存储器的空间分配和回收、内存信息保护程序、代码对换程序等。</li><li>设备管理：缓冲区管理、设备分配和回收等。</li></ul></li></ul><h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>所有的操作系统都提供多种服务的入口点，由此程序向内核请求服务。各种版本的 UNIX 实现都提供良好定义、数量有限、直接进入内核的入口点，这些入口点被称为系统调用。简单来说，系统调用就是操作系统提供的用于实现系统各种核心功能的许多子程序，如 read()、write()、open() 等。</p><p>这些系统调用按功能大致可分为如下几类：</p><ul><li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li><li>文件管理。完成文件的读、写、创建及删除等功能。</li><li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li><li>进程通信。完成进程之间的消息传递或信号传递等功能。</li><li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及始址等功能。</li></ul><p>显然，系统调用运行在系统的核心态。通过系统调用的方式来使用系统功能，可以保证系统的稳定性和安全性，防止用户随意更改或访问系统的数据或命令。系统调用命令是由操作系统提供的一个或多个子程序模块实现的。</p><p>这样，操作系统的运行环境可以理解为：用户通过操作系统运行上层程序（如系统提供的命令解释程序或用户自编程序），而这个上层程序的运行依赖于操作系统的底层管理程序提供服务支持，当需要管理程序服务时，系统则通过<code>硬件中断</code>机制进入核心态，运行底层管理程序；也可能是程序运行<code>出现异常</code>情况，被动地需要底层管理程序的服务，这时就通过异常处理来进入核心态。当底层管理程序运行结束时，用户程序需要继续运行，则通过相应的保存的程序现场退出中断处理程序或异常处理程序，返回断点处继续执行。</p><p>下面列举一些由用户态转向核心态的例子：</p><ul><li>用户程序要求操作系统的服务，即系统调用。</li><li>发生一次中断。</li><li>用户程序中产生了一个错误状态。</li><li>用户程序中企图执行一条特权指令。</li><li>从核心态转向用户态由一条指令实现，这条指令也是特权命令。一般是中断返回指令。</li></ul><p>注意：由用户态进入核心态，不仅仅是状态需要切换。而且，所使用的堆栈也可能需要由用户堆栈切换为系统堆栈，但这个系统堆栈也是属于该进程的。</p><h2 id="标准库函数"><a href="#标准库函数" class="headerlink" title="标准库函数"></a>标准库函数</h2><p>库函数顾名思义是把函数放到库里，是把一些常用到的函数编完放到一个文件里，供别人用。libc 就是一个 C 标准库，里面存放一些基本函数，这些基本函数都是被标准化了的，而且这些函数通常都是用汇编直接实现的，如 printf、scanf 等。</p><p>标准库函数构建在系统调用接口之上，应用程序既可以使用标准库函数，也可以使用系统调用。如下图：</p><p><img src="https://camo.githubusercontent.com/382fca944c80316687d2a8d2dfd54fadc17e8525/687474703a2f2f3778726c75392e636f6d312e7a302e676c622e636c6f7564646e2e636f6d2f4c696e75785f4f535f322e706e67" alt="enter image description here"></p><p>系统调用和标准库函数的区别如下：</p><ul><li>从程序完成的功能来看，函数库提供的函数通常不需要操作系统的服务。系统调用是要求操作系统为用户提供某种服务，通常是涉及系统的硬件资源和一些敏感的软件资源等。</li><li>从程序执行的空间来说，标准库函数是在用户空间内执行的，除非函数涉及到 I/O 操作等，一般是不会切到内核态的。系统调用则运行于内核空间。</li><li>从程序的可移植性的角度来看，相对于系统调用，C 语言的标准备函数库具备较高的可移植性。因为在所有的 ANSI C 编译器版本中，标准库函数是相同的；系统调用与系统有关，各个操作系统的系统调用是不同的。</li></ul><p>［<a href="http://www.nowcoder.com/questionTerminal/06be659534644b8eb3f164f9f1085a9d" target="_blank" rel="noopener">系统调用函数</a>］  </p><h1 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h1><ul><li>中断(Interruption)，也称外中断，指来自 CPU 执行指令以外的事件的发生，如设备发出的 I/O 结束中断，表示设备输入/输出处理已经完成，希望处理机能够向设备发下一个输入 / 输出请求，同时让完成输入/输出后的程序继续运行。时钟中断，表示一个固定的时间片已到，让处理机处理计时、启动定时运行的任务等。这一类中断通常是与当前程序运行无关的事件，即它们与当前处理机运行的程序无关。</li><li>异常(Exception)，也称内中断、例外或陷入(Trap)，指源自 CPU 执行指令内部的事件，如程序的非法操作码、地址越界、算术溢出、虚存系统的缺页以及专门的陷入指令等引起的事件。对异常的处理一般要依赖于当前程序的运行现场，而且异常不能被屏蔽，一旦出现应立即处理。</li></ul><h1 id="用户态、内核态"><a href="#用户态、内核态" class="headerlink" title="用户态、内核态"></a>用户态、内核态</h1><p>操作系统的很多操作会消耗系统的物理资源，例如创建一个新进程时，要做很多底层的工作，如分配物理内存，从父进程拷贝相关信息，拷贝设置页目录、页表等，这些操作显然不能让任何程序都可以做。</p><p>我们知道，Intel 的 X86 架构的 CPU 提供了 0 到 3 四个特权级（在CPU的设计中，用户态指非特权状态。在此状态下，执行的代码被硬件限定，不能进行某些操作，比如写入其他进程的存储空间，以防止给操作系统带来安全隐患）。</p><p>在 Linux 操作系统操作系统的设计中主要采用了0和3两个特权级，也就是我们通常所说的内核态和用户态。运行于用户态的进程可以执行的操作和访问的资源都受到极大的限制，而运行于内核态的进程则可以执行任何操作并且在资源的使用上也没有限制。</p><p>当一个任务（进程）陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0 级）内核代码中执行。每个进程都有自己的内核栈和用户栈，当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态），此时处理器在特权级最低的（3 级）用户代码中运行。简单来说在内核态下， CPU 可执行任何指令，在用户态下 CPU 只能执行非特权指令。</p><p>Linux 进程的 4GB 地址空间，3G-4G 是内核态的地址空间，存放整个内核的代码和所有的内核模块，以及内核所维护的数据。用户运行一个程序，该程序所创建的进程运行在用户态，如果要执行文件操作，网络数据发送等操作，必须通过 write，send 等系统调用，这些系统调用会调用内核中的代码来完成操作。这时必须切换到 Ring 0，然后进入 3GB-4GB 中的内核地址空间去执行这些代码完成操作，完成后切换回Ring 3，回到用户态。当程序处于内核态时可以随意进入用户态。</p><p>很多程序开始时运行于用户态，但在执行的过程中，一些操作需要在内核权限下才能执行，这就涉及到一个从用户态切换到内核态的过程。用户态切换到内核态的 3 种方式：</p><ul><li>系统调用：这是处于用户态的进程主动请求切换到内核态的一种方式。用户态的进程通过系统调用申请使用操作系统提供的系统调用服务例程来处理任务</li><li>产生异常：CPU 执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会切换到内核态，如缺页异常</li><li>外围设备的中断：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换    </li></ul><h1 id="操作系统发展"><a href="#操作系统发展" class="headerlink" title="* 操作系统发展"></a>* 操作系统发展</h1><h3 id="手工操作阶段（此阶段无操作系统）"><a href="#手工操作阶段（此阶段无操作系统）" class="headerlink" title="手工操作阶段（此阶段无操作系统）"></a>手工操作阶段（此阶段无操作系统）</h3><p>用户在计算机上算题的所有工作都要人工干预，如程序的装入、运行、结果的输出等。随着计算机硬件的发展，人机矛盾（速度和资源利用）越来越大，必须寻求新的解决办法。</p><h3 id="批处理阶段"><a href="#批处理阶段" class="headerlink" title="批处理阶段"></a>批处理阶段</h3><p>为了解决人机矛盾及CPU和I/O设备之间速度不匹配的矛盾，出现了批处理系统。它按发展历程又分为单道批处理系统、多道批处理系统（多道程序设计技术出现以后）。</p><ul><li>单道批处理系统：系统对作业的处理是成批进行的，但内存中始终只保持一道作业。当该程序完成或发生异常情况时，才换入其后继程序进入内存运行。</li><li>多道批处理系统：多道程序设计技术允许多个程序同时进入内存并运行。即同时把多个程序放入内存，并允许它们交替在CPU中运行，它们共享系统中的各种硬、软件资源。当一道程序因I/O请求而暂停运行时，CPU便立即转去运行另一道程序。它没有用某些机制提高某一技术方面的瓶颈问题，而是让系统的各个组成部分都尽量去“忙”，花费很少时间去切换任务，达到了系统各部件之间的并行工作，使其整体在单位时间内的效率翻倍。</li></ul><h3 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h3><p>把处理器的运行时间分成很短的时间片，按时间片轮流把处理器分配给各联机作业使用。若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时停止运行，把处理器让给其他作业使用，等待下一轮再继续运行。由于计算机速度很快，作业运行轮转得很快，给每个用户的感觉好像是自己独占一台计算机。多道批处理是实现作业自动控制而无需人工干预的系统，而分时系统是实现人机交互的系统。</p><p>分时系统具有与批处理系统不同的特征，其主要特征如下：</p><ul><li>同时性。同时性也称多路性，指允许多个终端用户同时使用一台计算机。</li><li>交互性。用户能够方便地与系统进行人-机对话。</li><li>独立性。系统中多个用户可以彼此独立地进行操作，互不干扰。</li><li>及时性。用户请求能在很短时间内获得响应。</li></ul><h3 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h3><p>为了能在某个时间限制内完成某些紧急任务而不需时间片排队，诞生了实时操作系统。这里的时间限制可以分为两种情况：如果某个动作必须绝对地在规定的时刻（或规定的时间范围）发生，则称为硬实时系统。例如，飞行器的飞行自动控制系统，这类系统必须提供绝对保证，让某个特定的动作在规定的时间内完成。如果能够接受偶尔违反时间规定，并且不会引起任何永久性的损害，则称为软实时系统，如飞机订票系统、银行管理系统。</p><p>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完接收的事件。实时橾作系统的主要特点是及时性和可靠性。</p><h3 id="分布式计算机系统"><a href="#分布式计算机系统" class="headerlink" title="分布式计算机系统"></a>分布式计算机系统</h3><p>分布式计算机系统是由多台计算机组成并满足下列条件的系统：系统中任意两台计算机通过通信方式交换信息；系统中的每一台计算机都具有同等的地位，即没有主机也没有从机；每台计算机上的资源为所有用户共享；系统中的任意若千台计算机都可以构成一个子系统，并且还能重构；任何工作都可以分布在几台计算机上，由它们并行工作、协同完成。</p><p>用于管理分布式计算机系统的操作系统称为分布式计算机系统。该系统的主要特点是：分布性和并行性。分布式操作系统与网络操作系统本质上的不同之处在于分布式操作系统中，若干台计算机相互协同完成同一任务。</p><p>分布式领域 CAP 理论：</p><ul><li>Consistency(一致性)，数据一致更新，所有数据变动都是同步的</li><li>Availability(可用性)，好的响应性能</li><li>Partition tolerance(分区容错性)：可靠性</li></ul><p>定理：任何分布式系统只可同时满足二点，没法三者兼顾。<br>忠告：架构师不要将精力浪费在如何设计能满足三者的完美分布式系统，而是应该进行取舍。</p><p>［<a href="http://www.nowcoder.com/questionTerminal/3666684e8eb142369092da0a559925bb" target="_blank" rel="noopener">分布式系统三个指标</a>］</p><hr><ul><li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p></li><li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p></li></ul><h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p><blockquote><p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p></blockquote><blockquote><p>体育&amp;户外用品推荐</p></blockquote><div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/se-notes/Linux基础/README/../more/ads/amazon.gif" width="100%"></a> </div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#简介&quot;&gt;简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#操作系统的特征&quot;&gt;操作系统的特征&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#操作系统目标&quot;&gt;操作系统目标&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="Linux" scheme="https://wnhby.github.io/categories/Linux/"/>
    
      <category term="linux基础" scheme="https://wnhby.github.io/categories/Linux/linux%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="linux" scheme="https://wnhby.github.io/tags/linux/"/>
    
      <category term="系统管理" scheme="https://wnhby.github.io/tags/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>区块链简介</title>
    <link href="https://wnhby.github.io/se-notes/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%AE%9E%E8%B7%B5/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9B%B8%E5%85%B3/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%AE%80%E4%BB%8B/"/>
    <id>https://wnhby.github.io/se-notes/云计算实践/区块链相关/区块链简介/</id>
    <published>2019-01-03T13:49:30.000Z</published>
    <updated>2019-02-19T05:21:34.401Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#区块链简介">区块链简介</a></li><li><a href="#应用领域">应用领域</a><ul><li><a href="#基于区块链的征信系统与数据中心比较">基于区块链的征信系统（与数据中心比较）</a><ul><li><a href="#ads">Ads</a></li></ul></li></ul></li></ul><!-- /TOC --><h1 id="区块链简介"><a href="#区块链简介" class="headerlink" title="区块链简介"></a>区块链简介</h1><p>区块链技术是金融科技（FinTech）领域的一项重要技术创新。作为去中心化记账（Decentralized Ledger Technology，DLT）平台的核心技术，区块链被认为在金融、征信、物联网、经济贸易结算、资产管理等众多领域都拥有广泛的应用前景。</p><p>把区块链想象成一个公共账本，这个账本：</p><ol><li>存放在区块链系统的各个节点上，每个节点都有一份完整的备份。</li><li>每个节点的账本都记录着自区块链系统建立以来的所有交易。</li><li>账本被分为若干个区块进行存储，每个区块包含一部分交易记录。每一个区块都会记录着前一区块的 id，形成一个链状结构，因而称为区块链。</li><li>当发起一笔交易时，只需把交易信息广播到系统的 p2p 网络中，其他节点把该笔交易信息记录成一个新的区块连到区块链上，交易即可完成。</li></ol><p>区块链的重要特性（DACT）：</p><ul><li>Distributed（分布式的）：区块链系统中有多个独立节点，所有节点都共享同一份数据。</li><li>Autonomous（自治的）：所有操作都由系统自动完成而不需要一个中心机构进行管理。</li><li>Contractual（按照合约执行的）：数据是公开的不代表所有人可以随意访问区块链系统上的数据，系统有着最严格的权限设置。在系统约定一个共同合约后，只有确定权限的用户才可以访问加密的数据。</li><li>Trackable（可追溯的）：区块链系统中所有交易都是可追溯的，添加交易信息需要得到系统的共识，因而数据不可篡改。</li></ul><blockquote><p>区块链的意义在于：构建了更加可靠、值得信任的互联网，从根本上解决了价值转移和交换过程中出现的存在的欺诈与寻租现象。</p></blockquote><h1 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h1><h2 id="基于区块链的征信系统（与数据中心比较）"><a href="#基于区块链的征信系统（与数据中心比较）" class="headerlink" title="基于区块链的征信系统（与数据中心比较）"></a>基于区块链的征信系统（与数据中心比较）</h2><p>征信：为防止在非即付经济交往中的交易双方收到损失而进行的一种信用评估。征信所提供的服务，就是向交易双方提供对方的背景和信用信息，解决交易信任的问题。</p><p>在一个征信体系中，对金融机构有价值的客户可划分为优质客户（白名单）、中间客户、风险客户（黑名单）。白名单是主要服务对象，因为其意味着收益；而对黑名单则需要进行风险控制。但目前传统意义上的金融征信系统普遍存在局限性：</p><ul><li>目前大部分信用数据是一个个独立的信息孤岛（比如央行征信系统的数据），彼此并不联通。而完全开放征信系统数据又可能会造成虚假数据上传、金融机构核心业务信息被泄露等问题。</li><li>即使是对于传统意义上的征信共享，多个机构共享的结果是把每个机构的数据汇总到一个庞大的数据中心系统，参与机构都在该系统上查询。但也会有问题：<ul><li>系统是中心化的，一旦中心遭到攻击、篡改、上传虚假数据就会影响到所有数据的可靠性；同时也会出现人工误操作的情况。</li><li>数据汇总与更新速度不可控，难以及时进行征信数据同步</li><li>数据访问权限以及数据交换、共享问题：难以实现权限控制以及两个机构之间的私密数据有偿交换</li><li>由于数据中心共享的透明性，有些机构会故意保留己方的核心业务数据以防泄露</li><li>若要保证查询速度，则需要构建复杂的冗余系统；否则的话只有一个中心处理所有的请求，则系统速度可能会慢到不可用的程度</li></ul></li></ul><p>而区块链技术是最适合用于解决征信问题的解决方案：</p><ul><li>把中心化的存储转化为去中心化的分布式存储，变统一中心节点查询为 p2p 查询，提高安全性与性能</li><li>每个节点的数据完全同步</li><li>数据无法被篡改，即使有虚假数据也可以迅速追溯到源头</li><li>利用智能合约设置数据汇总与更新规则</li><li>通过智能合约进行权限控制，拥有对应的访问权限才可访问对应的数据</li></ul><hr><ul><li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p></li><li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p></li></ul><h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p><blockquote><p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p></blockquote><blockquote><p>体育&amp;户外用品推荐</p></blockquote><div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/se-notes/云计算实践/区块链相关/区块链简介/../more/ads/amazon.gif" width="100%"></a> </div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#区块链简介&quot;&gt;区块链简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#应用领域&quot;&gt;应用领域&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#基于区块链的征信系统与数据中心比较&quot;&gt;基于区块链的征信系统（与数据中心比较）&lt;
      
    
    </summary>
    
      <category term="通用技术" scheme="https://wnhby.github.io/categories/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/"/>
    
      <category term="云计算实践" scheme="https://wnhby.github.io/categories/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%AE%9E%E8%B7%B5/"/>
    
      <category term="区块链" scheme="https://wnhby.github.io/categories/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%AE%9E%E8%B7%B5/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="云计算" scheme="https://wnhby.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="区块链" scheme="https://wnhby.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Heartbeat双机热备方案</title>
    <link href="https://wnhby.github.io/se-notes/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%AE%9E%E8%B7%B5/%E9%9B%86%E7%BE%A4%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88/Heartbeat%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87%E6%96%B9%E6%A1%88/"/>
    <id>https://wnhby.github.io/se-notes/云计算实践/集群高可用方案/Heartbeat双机热备方案/</id>
    <published>2019-01-03T13:49:30.000Z</published>
    <updated>2019-02-19T05:21:48.557Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#heartbeat-%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88centos">Heartbeat 部署方案（CentOS）</a><ul><li><a href="#%E5%AE%89%E8%A3%85">安装</a></li><li><a href="#%E9%85%8D%E7%BD%AE">配置</a><ul><li><a href="#%E8%AE%A4%E8%AF%81%E6%96%87%E4%BB%B6etchadauthkeys">认证文件（/etc/ha.d/authkeys）</a></li><li><a href="#%E4%B8%BB%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6etchadhacf">主配置文件（/etc/ha.d/ha.cf）</a></li><li><a href="#%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6etchadharesources">资源文件（/etc/ha.d/haresources）</a></li><li><a href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3">参考文档</a></li><li><a href="#ads">Ads</a></li></ul></li></ul></li></ul><!-- /TOC --><h1 id="Heartbeat-部署方案（CentOS）"><a href="#Heartbeat-部署方案（CentOS）" class="headerlink" title="Heartbeat 部署方案（CentOS）"></a>Heartbeat 部署方案（CentOS）</h1><blockquote><p>注意：Heartbeat 方案本人还未有实践过</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>两种安装方式：</p><ul><li>主从节点都使用<code>yum install heartbeat*</code>命令安装 Heartbeat（须确保已安装 epel 扩展软件包源）。</li><li>在 Linux-HA 官网下载 <a href="http://www.linux-ha.org/wiki/Downloads" target="_blank" rel="noopener">Heartbeat</a>。</li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Heartbeat 主要的配置文件有 3 个，分别是 <strong>authkeys</strong>，<strong>ha.cf</strong> 和 <strong>haresources</strong>。其中 ha.cf 是主配置文件，haresource 用来配置要让 Heartbeat 托管的服务，authkey 是用来指定 Heartbeat 的认证方式。</p><blockquote><p>在 Heartbeat 安装后，默认并没有这三个文件，可以直接从解压的源码目录中找到。</p></blockquote><p>这里以 master/slave 两节点为例，示例的配置文件为 master 节点的。</p><h3 id="认证文件（-etc-ha-d-authkeys）"><a href="#认证文件（-etc-ha-d-authkeys）" class="headerlink" title="认证文件（/etc/ha.d/authkeys）"></a>认证文件（/etc/ha.d/authkeys）</h3><p>该文件为 Heartbeat 的认证文件，该文件主要是用于集群中两个节点的认证，采用的算法和密钥（如果有的话）在集群中节点上必须相同。目前提供了 3 种算法：crc/md5/sha1。其中 crc 不能够提供认证，它只能够用于校验数据包是否损坏，而 sha1/md5 需要一个密钥来进行认证。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auth 2</span><br><span class="line">#1 crc</span><br><span class="line">2 sha1 somewords</span><br><span class="line">#3 md5 somewords</span><br></pre></td></tr></table></figure><p>以上示例中使用的是 sha1 算法，如果要换用其他算法只需要修改 auth 指令后面的数字，然后取消相应行的注释即可。</p><blockquote><p>注意：该文件的属性必须为600，否则 Heartbeat 启动将失败。且两个节点的 authkeys 文件内容及权限相同。</p></blockquote><h3 id="主配置文件（-etc-ha-d-ha-cf）"><a href="#主配置文件（-etc-ha-d-ha-cf）" class="headerlink" title="主配置文件（/etc/ha.d/ha.cf）"></a>主配置文件（/etc/ha.d/ha.cf）</h3><p>该文件是 Heartbeat 的主配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">keepalive 2</span><br><span class="line">warntime 5</span><br><span class="line">deadtime 30</span><br><span class="line">initdead 120</span><br><span class="line">udpport 6942</span><br><span class="line">bcast eth0</span><br><span class="line"># mcast eth0 225.0.0.1 694 1 0</span><br><span class="line">ucast eth1 &#123;&#123; slave的IP地址 &#125;&#125;</span><br><span class="line">auto_failback off</span><br><span class="line">watchdog /dev/watchdog</span><br><span class="line">node host41 host42</span><br><span class="line"># ping 172.16.12.1 ping_group group1 172.16.12.1</span><br><span class="line">respawn hacluster /usr/lib64/heartbeat/ipfail</span><br><span class="line">respawn hacluster /usr/lib64/heartbeat/dopd</span><br><span class="line">apiauth dopd gid=haclient uid=hacluster</span><br><span class="line">use_logd yes</span><br></pre></td></tr></table></figure><ul><li>keepalive：发送心跳报文的间隔。默认单位为秒，也可以使用 500ms 来指代 500 毫秒，等同于 0.5。</li><li>warntime：认为对方可能宕掉的间隔时间。</li><li>deadtime：认为对方宕掉的间隔时间，超过这个时间，则认为对方已经宕掉。</li><li>initdead：等待对方启动的最大时间。</li><li>udpport：heartbeat 广播/单播通讯使用的 udp 端口。</li><li>bcast：心跳所使用的网络接口。</li><li>ucast：单播通讯，对方网络接口及IP地址。</li><li>mcast：组播通讯，参数如右：通讯所用的接口 绑定的组播IP（224.0.0.0-239.255.255.255）通讯端口 ttl 是否允许环回。</li><li>auto_failback：表示当主节点（即提供资源/服务的节点）正常之后是否将资源/服务切换回来。</li><li>watchdog：看门狗定时器，如果节点一分钟内没有心跳，则重启节点。</li><li>node：heartbeat 集群中的节点信息（节点的主机名: uname -n）。</li><li>ping/ping_group：用于建立伪集群成员，作用是监测物理链路，如果该节点与伪集群成员不相通，那么该节点无权接管资源/服务。</li></ul><p>另一从节点（slave）需要将 ha.cf 文件中 ucast 的 IP 地址改为主节点（master）的 IP 地址。</p><h3 id="资源文件（-etc-ha-d-haresources）"><a href="#资源文件（-etc-ha-d-haresources）" class="headerlink" title="资源文件（/etc/ha.d/haresources）"></a>资源文件（/etc/ha.d/haresources）</h3><p>haresources 文件用于指定双机系统的主节点、集群IP、子网掩码、广播地址以及启动的服务等集群资源。文件每一行可以包含一个或多个资源脚本名，资源之间使用空格隔开，参数之间使用两个冒号隔开。在两个节点上该文件必须完全一致，此文件的一般格式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node-name network &lt;resource-group&gt;</span><br></pre></td></tr></table></figure></p><p>node-name 表示主节点的主机名，必须和 ha.cf 文件中指定的节点名一致；network 用于设定集群的 IP 地址、子网掩码、网络设备标识等（这里指定的IP地址就是集群对外服务的IP地址），resource-group 用来指定需要 Heartbeat 托管的服务，也就是这些服务可以由 Heartbeat 来启动和关闭，如果要托管这些服务，必须将服务写成可以通过 start/stop 来启动和关闭的脚本，然后放到 /etc/init.d/ 或者 /etc/ha.d/resource.d/ 目录下，heartbeat 会根据脚本的名称自动去 /etc/init.d 或者 /etc/ha.d/resource.d/ 目录下找到相应脚本进行启动或关闭操作。</p><p>以下是一个具体实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node1 IPaddr::192.168.60.200/24/eth0/  Filesystem::/dev/sdb5::/webdata::ext3  httpd tomcat</span><br></pre></td></tr></table></figure></p><p>其中，node1 是 HA 集群的主节点，IPaddr 为 HeartbeatH自带的一个执行脚本，Heartbeat 首先将执行<code>/etc/ha.d/resource.d/IPaddr 192.168.60.200/24 start</code>的操作，也就是虚拟出一个子网掩码为 255.255.255.0，IP为 192.168.60.200 的地址，此IP为 Heartbeat 对外提供服务的网络地址，同时指定此 IP 使用的网络接口为 eth0，接着，Heartbeat 将执行共享磁盘分区的挂载操作，<code>Filesystem::/dev/sdb5::/webdata::ext3</code>相当于在命令行下执行 mount 操作，即“mount –t ext3 /dev/sdb5 /webdata”，最后依次启动 httpd 和 tomcat 服务。</p><blockquote><p>注意：主节点和从节点中资源文件 haresources 一般要完全一致。</p></blockquote><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="http://ixdba.blog.51cto.com/2895551/548625" target="_blank" rel="noopener">Linux-HA开源软件Heartbeat（配置篇）</a><br><a href="https://github.com/chenzhiwei/linux/tree/master/heartbeat" target="_blank" rel="noopener">heartbeat配置相关</a></p><hr><ul><li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p></li><li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p></li></ul><h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p><blockquote><p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p></blockquote><blockquote><p>体育&amp;户外用品推荐</p></blockquote><div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/se-notes/云计算实践/集群高可用方案/Heartbeat双机热备方案/../more/ads/amazon.gif" width="100%"></a> </div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#heartbeat-%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88centos&quot;&gt;Heartbeat 部署方案（CentOS）&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AE%89
      
    
    </summary>
    
      <category term="通用技术" scheme="https://wnhby.github.io/categories/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/"/>
    
      <category term="云计算实践" scheme="https://wnhby.github.io/categories/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%AE%9E%E8%B7%B5/"/>
    
      <category term="集群高可用方案" scheme="https://wnhby.github.io/categories/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%AE%9E%E8%B7%B5/%E9%9B%86%E7%BE%A4%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="云计算" scheme="https://wnhby.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="集群" scheme="https://wnhby.github.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>HAProxy+Keepalived高可用方案</title>
    <link href="https://wnhby.github.io/se-notes/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%AE%9E%E8%B7%B5/%E9%9B%86%E7%BE%A4%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88/HAProxy+Keepalived%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88/"/>
    <id>https://wnhby.github.io/se-notes/云计算实践/集群高可用方案/HAProxy+Keepalived高可用方案/</id>
    <published>2019-01-03T13:49:30.000Z</published>
    <updated>2019-02-19T05:21:41.485Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B">技术简介</a><ul><li><a href="#haproxy">HAProxy</a></li><li><a href="#keepalived">Keepalived</a></li></ul></li><li><a href="#haproxy--keepalived-%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88">HAProxy + Keepalived 部署方案</a><ul><li><a href="#%E5%89%8D%E7%AB%AF%E9%85%8D%E7%BD%AE">前端配置</a><ul><li><a href="#%E5%89%8D%E7%AB%AF%E9%85%8D%E7%BD%AE-keepalived">前端配置 keepalived</a></li><li><a href="#%E5%89%8D%E7%AB%AF%E9%85%8D%E7%BD%AE-haproxy">前端配置 HAProxy</a></li></ul></li></ul></li><li><a href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3">参考文档</a><ul><li><a href="#ads">Ads</a></li></ul></li></ul><!-- /TOC --><h1 id="技术简介"><a href="#技术简介" class="headerlink" title="技术简介"></a>技术简介</h1><h3 id="HAProxy"><a href="#HAProxy" class="headerlink" title="HAProxy"></a>HAProxy</h3><p>HAProxy（High Available Proxy）是一款提供高可用性、负载均衡以及基于 TCP（第四层）和 HTTP（第七层）应用的代理软件。 HAProxy 配置简单、支持多达上万并发连接。其运行模型可使得它非常容易和无风险地集成到现有的架构中，并且同时可以保护 web 服务器不被暴露到网络上。</p><h3 id="Keepalived"><a href="#Keepalived" class="headerlink" title="Keepalived"></a>Keepalived</h3><p>Keepalived 是一款高可用软件，它的功能是基于 VRRP 协议，通过 IP 漂移实现服务的高可用：服务器集群共享一个虚拟 IP，同一时间只有一个服务器占有虚拟 IP 并对外提供服务。若该服务器不可用，则虚拟 IP 漂移至另一台服务器并对外提供服务。</p><p>Keepalived 可以单独使用，即通过 IP 漂移实现服务的高可用，也可以结合 LVS 使用（即一方面通过 IP 漂移实现 LVS 负载均衡层的高可用，另一方面实现 LVS 应用服务层的状态监控）。</p><h1 id="HAProxy-Keepalived-部署方案"><a href="#HAProxy-Keepalived-部署方案" class="headerlink" title="HAProxy + Keepalived 部署方案"></a>HAProxy + Keepalived 部署方案</h1><p>准备四台虚机，分别记作 HA-master、HA-slave、web-node1、web-node2。前两者作为 HA 负载均衡调度器（即前端），后两者是提供应用服务的 web 服务器（即后端）。</p><h2 id="前端配置"><a href="#前端配置" class="headerlink" title="前端配置"></a>前端配置</h2><h3 id="前端配置-keepalived"><a href="#前端配置-keepalived" class="headerlink" title="前端配置 keepalived"></a>前端配置 keepalived</h3><p>HA-master 与 HA-slave 都需安装 keepalived 服务：<code>yum -y install keepalived</code>，keepalived 的配置文件路径为<code>/etc/keepalived/keepalived.conf</code>。</p><p>配置 HA-master 的 keepalived：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">   router_id HA_DEVEL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;        #主从实例1</span><br><span class="line">    state MASTER            #HA-master（172.18.216.115）为主，</span><br><span class="line">                            #HA-slave（172.18.216.79）为备</span><br><span class="line">                            #在HA-slave上，该处设置为BACKUP</span><br><span class="line">    interface ens192        #与实际网卡的名称必须保持一致</span><br><span class="line">    virtual_router_id 88    #实例1的VRID为88</span><br><span class="line">    garp_master_delay 1     #在切换到master状态后，延迟进行gratuitous ARP请求</span><br><span class="line">    priority 100            #HA-master的优先级为100，HA-slave的优先级为99</span><br><span class="line">                            #在HA-slave上，该选项设置为99</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 123456</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        172.18.216.194       #实例1的虚拟IP</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来再配置 HA-slave 的 keepalived 配置文件。HA-slave 与 HA-master 的配置文件除了<code>state</code>项与<code>priority</code>项不同以外，其他项完全相同。</p><p>配置完成后，在两台虚机上都用<code>service keepalived start</code>命令启动 keepalive 服务。之后在 HA-master 上使用<code>ip addr show</code>命令可以看到当前节点已经绑定了虚拟 IP。且可以通过关闭 HA-master 上的 keepalive 服务来查看虚拟 IP 是否浮动到了 HA-slave。</p><blockquote><p>但目前 haproxy 服务停止时，keepalived 服务并不会停止，所以还需要写一个脚本，使得当 haproxy 服务停止时，keepalived 服务也会停止</p></blockquote><h3 id="前端配置-HAProxy"><a href="#前端配置-HAProxy" class="headerlink" title="前端配置 HAProxy"></a>前端配置 HAProxy</h3><p>在 HA-master 与 HA-slave 上安装 HAProxy：<code>yum install haproxy</code>，然后配置 HAProxy（路径<code>/etc/haproxy/haproxy.cfg</code>）。</p><p>HAProxy 的配置文件分为五个部分：</p><ul><li>global：全局配置的进程级参数，用来控制 Haproxy 启动前的一些进程及系统设置</li><li>defaults：配置默认参数，可以被 frontend，backend，listen 段继承使用</li><li>frontend：定义接收请求的前端虚拟节点，可根据用户所请求的不同域名、URL 等做不同的请求处理</li><li>backend：定义处理业务的后端服务器集群，以及设置后端的权重、队列、连接数等选项</li><li>listen：frontend 和 backend 的组合体</li></ul><blockquote><p>对配置参数的更详细说明请查阅文末的参考文档。</p></blockquote><p>以下是 HA-master 与 HA-slave 上的配置示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">global</span><br><span class="line">    log         127.0.0.1 local2      # 定义日志输出设置</span><br><span class="line">    chroot      /var/lib/haproxy      # chroot运行路径</span><br><span class="line">    pidfile     /var/run/haproxy.pid  # haproxy进程PID文件</span><br><span class="line">    maxconn     20000                  # 默认最大连接数</span><br><span class="line">    daemon                            # 以后台形式运行harpoxy</span><br><span class="line">#---------------------------------------------------------------------</span><br><span class="line"># common defaults that all the &apos;listen&apos; and &apos;backend&apos; sections will</span><br><span class="line"># use if not designated in their block</span><br><span class="line">#---------------------------------------------------------------------</span><br><span class="line">defaults</span><br><span class="line">    mode                    http         # 所处理的类别(7层代理http，4层代理tcp)</span><br><span class="line">    log                     global       # 引入global定义的日志格式</span><br><span class="line">    option                  httplog      # 日志类别为http日志格式</span><br><span class="line">    option                  dontlognull  </span><br><span class="line">    option http-server-close    # 当客户端超时时，允许服务器关闭连接</span><br><span class="line">    option forwardfor       except 127.0.0.0/8    # 在响应头部加入forwardfor</span><br><span class="line">    option                  redispatch    # 在使用了基于cookie的会话保持的时候，通常需要</span><br><span class="line">                                          # 加这么一项，一旦后端某一server宕机时，能够将</span><br><span class="line">                                          # 其会话重新派发到其它的servers</span><br><span class="line">    retries                 3             # 3次连接失败就认为服务器不可用</span><br><span class="line">    timeout http-request    10s           </span><br><span class="line">    timeout queue           1m            </span><br><span class="line">    timeout connect         10s           </span><br><span class="line">    timeout client          1m            </span><br><span class="line">    timeout server          1m</span><br><span class="line">    timeout http-keep-alive 10s           # 默认持久连接超时时间</span><br><span class="line">    timeout check           10s           # 心跳检查超时时间</span><br><span class="line">    maxconn                 5000          # 最大并发连接数</span><br><span class="line">#---------------------------------------------------------------------</span><br><span class="line"># main frontend which proxys to the backends</span><br><span class="line">#---------------------------------------------------------------------</span><br><span class="line">frontend  proxy *:80    #前端代理</span><br><span class="line">    default_backend             dynamic</span><br><span class="line">#---------------------------------------------------------------------</span><br><span class="line"># round robin balancing between the various backends</span><br><span class="line">#---------------------------------------------------------------------</span><br><span class="line">backend dynamic    #后端动态服务器</span><br><span class="line">    balance     roundrobin</span><br><span class="line">    cookie      SESSION_ID insert indirect nocache    #设置cookie保持</span><br><span class="line">    server      web1  172.18.218.149:80 inter 3000 rise 2 fall 3 check maxconn 5000 cookie A</span><br><span class="line">    server      web2  172.18.216.107:80 inter 3000 rise 2 fall 3 check maxconn 5000 cookie B</span><br><span class="line">listen statistics  #设置HAProxy 的自带管理系统</span><br><span class="line">        mode http</span><br><span class="line">        bind *:8080    #把stats页面绑定到8080端口</span><br><span class="line">        stats enable   #开启stats功能</span><br><span class="line">        stats auth admin:admin    #认证的用户名和密码</span><br><span class="line">        stats uri /admin?stats    #指定uri访问路径</span><br><span class="line">        stats hide-version        #为了安全（版本bug），隐藏版本信息</span><br><span class="line">        stats refresh 5s          #页面5秒刷新一次</span><br></pre></td></tr></table></figure></p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="http://nmshuishui.blog.51cto.com/1850554/1405486" target="_blank" rel="noopener">keepalived+haproxy双主高可用负载均衡</a><br><a href="http://www.ttlsa.com/linux/haproxy-study-tutorial/" target="_blank" rel="noopener">HAProxy用法详解 全网最详细中文文档</a><br><a href="http://leejia.blog.51cto.com/4356849/1421882" target="_blank" rel="noopener">haproxy配置详解</a><br><a href="http://blief.blog.51cto.com/6170059/1750952" target="_blank" rel="noopener">HAproxy指南之haproxy配置详解</a></p><hr><ul><li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p></li><li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p></li></ul><h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p><blockquote><p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p></blockquote><blockquote><p>体育&amp;户外用品推荐</p></blockquote><div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/se-notes/云计算实践/集群高可用方案/HAProxy+Keepalived高可用方案/../more/ads/amazon.gif" width="100%"></a> </div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B&quot;&gt;技术简介&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#haproxy&quot;&gt;HAProxy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#kee
      
    
    </summary>
    
      <category term="通用技术" scheme="https://wnhby.github.io/categories/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/"/>
    
      <category term="云计算实践" scheme="https://wnhby.github.io/categories/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%AE%9E%E8%B7%B5/"/>
    
      <category term="集群高可用方案" scheme="https://wnhby.github.io/categories/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%AE%9E%E8%B7%B5/%E9%9B%86%E7%BE%A4%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="云计算" scheme="https://wnhby.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="集群" scheme="https://wnhby.github.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>k8s基础教程</title>
    <link href="https://wnhby.github.io/se-notes/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%AE%9E%E8%B7%B5/Kubernetes%E9%83%A8%E7%BD%B2/k8s%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
    <id>https://wnhby.github.io/se-notes/云计算实践/Kubernetes部署/k8s基础教程/</id>
    <published>2019-01-03T13:49:30.000Z</published>
    <updated>2019-02-19T05:21:07.459Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#k8s-集群的介绍安装与配置实践版">K8S 集群的介绍、安装与配置（实践版）</a><pre><code>- [术语简介](#术语简介)</code></pre><ul><li><a href="#1--事前准备">1.  事前准备</a></li><li><a href="#2-配置-kubectl-与-minikube">2. 配置 kubectl 与 Minikube</a></li><li><a href="#3-安装-virtualbox">3. 安装 VirtualBox</a></li><li><a href="#4-使用-minikube-运行集群">4. 使用 Minikube 运行集群</a></li><li><a href="#5-在集群上部署应用">5. 在集群上部署应用</a></li><li><a href="#6-查看-pod-与-node">6. 查看 Pod 与 Node</a></li><li><a href="#7-部署-service">7. 部署 Service</a></li><li><a href="#8-调整应用规模">8. 调整应用规模</a></li><li><a href="#9-执行滚动更新">9. 执行滚动更新</a></li><li><a href="#注意事项">注意事项</a></li><li><a href="#参考资料">参考资料</a><ul><li><a href="#ads">Ads</a></li></ul></li></ul></li></ul><!-- /TOC --><h1 id="K8S-集群的介绍、安装与配置（实践版）"><a href="#K8S-集群的介绍、安装与配置（实践版）" class="headerlink" title="K8S 集群的介绍、安装与配置（实践版）"></a>K8S 集群的介绍、安装与配置（实践版）</h1><p>k8s 集群由一个 master 节点与多个 node 节点组成，所有节点均是在逻辑上独立的一个机器 。master 节点是管理整个集群的节点，而 node 节点是具体执行业务的节点，每个 node 都有一个 kubelet 作为其代理用于与 master 通信。</p><p><img src="https://d33wubrfki0l68.cloudfront.net/99d9808dcbf2880a996ed50d308a186b5900cec9/40b94/docs/tutorials/kubernetes-basics/public/images/module_01_cluster.svg" alt="enter image description here"></p><p>而在本教程中，我们介绍 k8s 集群的基本操作：将会在本地机器上部署一个<strong>单 Node 的 k8s 集群</strong>，并尝试在该集群上<strong>部署一个应用</strong>、<strong>配置暴露应用的服务</strong>、以及<strong>对应用进行规模调整与版本更新</strong>。</p><h3 id="术语简介"><a href="#术语简介" class="headerlink" title="术语简介"></a>术语简介</h3><p><a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl/" target="_blank" rel="noopener">kubectl</a> 是 k8s 的命令行管理工具，管理 k8s 集群需要通过该系列命令进行。</p><p> <a href="https://kubernetes.io/docs/getting-started-guides/minikube/" target="_blank" rel="noopener">Minikube</a> 是一个用于在本地上运行 kubernates 的工具插件。Minikube 可在本地机器上创建一个虚拟机（需要安装对应的虚拟机驱动，如 VirtualBox、KVM 等），从而运行一个单节点的 k8s 集群。原理图如下：</p><p><img src="https://yqfile.alicdn.com/c03a43e0731ca579d1844fb44269fd2fd257bfb3.jpeg" alt="minikube 原理说明图"></p><p><a href="https://www.virtualbox.org/" target="_blank" rel="noopener">VirtualBox</a> 是一款支持 x86 和 AMD64/Intel64 的开源虚拟机软件，支持 Window、Linux 等系统。在本教程中，我们把它作为 Minikube 的虚拟机驱动。</p><h2 id="1-事前准备"><a href="#1-事前准备" class="headerlink" title="1.  事前准备"></a>1.  事前准备</h2><ul><li>准备好一台操作系统为 Linux CentOS 7 系统、内存为 <strong>4G 以上</strong>的虚机（或物理机），完成换源与关闭防火墙和 SELinux</li><li>需要在虚机上安装 VirtualBox 或 KVM 作为虚拟化软件（本教程介绍 VirtualBox 的安装）</li><li>设置 CPU 支持虚拟化 VT-X（若是物理机则在BIOS上设置，若是虚机则在VMware里设置 ）</li></ul><h2 id="2-配置-kubectl-与-Minikube"><a href="#2-配置-kubectl-与-Minikube" class="headerlink" title="2. 配置 kubectl 与 Minikube"></a>2. 配置 kubectl 与 Minikube</h2><p>下载 kubectl 并配置到系统路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -LO https://storage.googleapis.com/kubernetes-release/release/v1.9.1/bin/linux/amd64/kubectl</span><br><span class="line">$ chmod +x ./kubectl</span><br><span class="line">$ sudo mv ./kubectl /usr/local/bin/</span><br></pre></td></tr></table></figure></p><blockquote><p>注意 kubectl 的版本必须新于 k8s 服务器的版本，否则会出现校验错误。可通过 <code>curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt</code> 命令查询当前的最新稳定版本。</p></blockquote><p>下载 Minikube 并配置到系统路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 </span><br><span class="line">$ chmod +x ./minikube</span><br><span class="line">$ sudo mv ./minikube /usr/local/bin/</span><br></pre></td></tr></table></figure></p><blockquote><p>注意：由于本节所述的下载网址有时会无法通过 curl 命令访问，因此建议直接下载 kubectl 或 minikube 到本地再上传到虚机中。也可以通过其他途径如 <a href="https://github.com/kubernetes/minikube/releases" target="_blank" rel="noopener">minikube 的 github 下载地址</a> 进行下载。</p></blockquote><h2 id="3-安装-VirtualBox"><a href="#3-安装-VirtualBox" class="headerlink" title="3. 安装 VirtualBox"></a>3. 安装 VirtualBox</h2><p>本教程中 minikube 的虚拟机采用 VirtualBox ，安装步骤如下：</p><ol><li>在官网下载对应系统的 VirtualBox rpm 包</li><li>安装 VirtualBox 的依赖包：<code>yum install qt qt-x11 gcc gcc-c++ kernel-devel perl SDL</code></li><li>安装 VirtualBox：<code>rpm -i VirtualBox-5.2-5.2.6_120293_el7-1.x86_64.rpm</code></li><li>添加当前用户到 VirtualBox 创建的用户组 “vboxusers”：<code>usermod -a -G vboxusers </code></li></ol><blockquote><p>在 Linux 下，Minikube 也支持 –vm-driver=none 选项来在本机运行 Kubernetes 组件（此种方式尚未实验）。</p></blockquote><h2 id="4-使用-Minikube-运行集群"><a href="#4-使用-Minikube-运行集群" class="headerlink" title="4. 使用 Minikube 运行集群"></a>4. 使用 Minikube 运行集群</h2><p>执行 <code>minikube start</code> 启动本地 k8s 集群。当正常启动成功时，出现以下输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Starting local Kubernetes v1.8.0 cluster...</span><br><span class="line">Starting VM...</span><br><span class="line">Downloading Minikube ISO</span><br><span class="line"> 140.01 MB / 140.01 MB [============================================] 100.00% 0s</span><br><span class="line">Getting VM IP address...</span><br><span class="line">Moving files into cluster...</span><br><span class="line">Downloading localkube binary</span><br><span class="line"> 148.25 MB / 148.25 MB [============================================] 100.00% 0s</span><br><span class="line">Connecting to cluster...</span><br><span class="line">Setting up kubeconfig...</span><br><span class="line">Starting cluster components...</span><br><span class="line">Kubectl is now configured to use the cluster.</span><br><span class="line">Loading cached images from config file.</span><br></pre></td></tr></table></figure></p><p>执行 <code>minikube status</code> 可查看当前集群状态，输出类似如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">minikube: Running</span><br><span class="line">cluster: Running</span><br><span class="line">kubectl: Correctly Configured: pointing to minikube-vm at 192.168.99.100</span><br></pre></td></tr></table></figure></p><p>使用 <code>kubectl version</code> 可查看当前的 k8s 集群的客户端与服务端的版本；使用 <code>kubectl cluster-info</code> 可查看集群的详细部署情况；使用 <code>kubectl get nodes</code> 查看集群节点情况。</p><h2 id="5-在集群上部署应用"><a href="#5-在集群上部署应用" class="headerlink" title="5. 在集群上部署应用"></a>5. 在集群上部署应用</h2><p>部署文件（Deployment）是用于指导 k8s 集群如何创建与维护应用实例的。</p><p><img src="https://d33wubrfki0l68.cloudfront.net/152c845f25df8e69dd24dd7b0836a289747e258a/4a1d2/docs/tutorials/kubernetes-basics/public/images/module_02_first_app.svg" alt="enter image description here"></p><p><code>kubectl run</code> 命令用于创建一个新的 Deployment，此命令需要提供 Deployment 的命名以及 app 镜像的地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 若需要在特定端口运行app，则用 --port 指明运行端口</span><br><span class="line">$ kubectl run kubernetes-bootcamp --image=docker.io/jocatalin/kubernetes-bootcamp:v1 --port=8080</span><br><span class="line"># 创建完成后可以查询 Deployment</span><br><span class="line">$ kubectl get deployments</span><br></pre></td></tr></table></figure></p><p>Pod 是 k8s 集群管理的基本单位。当一个 Deployment 创建后，集群将会创建一个 Pod 来管理应用实例。一个 Pod 是一个 k8s 抽象，代表了一组（一个或多个）应用容器，且这些容器之间共享存储、网络等资源。</p><p>默认情况下，集群中的 Pods 对外部网络是不可见的，但 kubectl 可以创建一个能够转发请求到集群端私有网络的代理：<code>kubectl proxy</code>，执行后的输出类似如下（注意当前终端会阻塞）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl proxy</span><br><span class="line">Starting to serve on 127.0.0.1:8001</span><br></pre></td></tr></table></figure></p><p>通过使用 <code>kubectl proxy</code> 所展示的地址，我们就可以直接访问 k8s API，例如 <code>curl http://127.0.0.1:8001/version</code> 就可获取当前 API Server 的版本。</p><p>API Server 会自动根据 pod 的名字来为每个 pod 创建一个访问点（endpoint），该访问点也可以通过 proxy 来直接访问：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ export POD_NAME=$(kubectl get pods -o go-template --template &apos;&#123;&#123;range .items&#125;&#125;&#123;&#123;.metadata.name&#125;&#125;&#123;&#123;&quot;\n&quot;&#125;&#125;&#123;&#123;end&#125;&#125;&apos;)</span><br><span class="line">$ echo Name of the Pod: $POD_NAME</span><br><span class="line">$ curl http://localhost:8001/api/v1/proxy/namespaces/default/pods/$POD_NAME/</span><br></pre></td></tr></table></figure></p><h2 id="6-查看-Pod-与-Node"><a href="#6-查看-Pod-与-Node" class="headerlink" title="6. 查看 Pod 与 Node"></a>6. 查看 Pod 与 Node</h2><p>一个 Pod 运行于一个 Node 上，Node 则是 k8s 集群中的执行业务的逻辑主机（虚拟机或者物理机），由 master 进行管理。一个 Node 可以拥有多个 Pod，且 master 可以在集群中的多个 node 之间自动调度 Pod。示意图如下：</p><p><img src="https://d33wubrfki0l68.cloudfront.net/5cb72d407cbe2755e581b6de757e0d81760d5b86/a9df9/docs/tutorials/kubernetes-basics/public/images/module_03_nodes.svg" alt="enter image description here"></p><p>常用的查询应用的命令包括：</p><ul><li><strong>kubectl get</strong> ： 列出资源</li><li><strong>kubectl describe</strong> : 展示资源详情</li><li><strong>kubectl logs</strong> : 打印某个 Pod 中的一个容器的日志</li><li><strong>kubectl exec</strong> : 在一个 Pod 中的一个容器中执行命令</li></ul><h2 id="7-部署-Service"><a href="#7-部署-Service" class="headerlink" title="7. 部署 Service"></a>7. 部署 Service</h2><p>一个 Service 是集群中的一个抽象，它定义了一组逻辑相关的 Pods 以及如何访问它们的策略。Services 允许独立的 Pods 间的松耦合。</p><p><img src="https://d33wubrfki0l68.cloudfront.net/cc38b0f3c0fd94e66495e3a4198f2096cdecd3d5/ace10/docs/tutorials/kubernetes-basics/public/images/module_04_services.svg" alt="enter image description here"></p><p>Service 使用标签（Label）和选择器（Selector）来匹配一组 Pods。</p><p><img src="https://d33wubrfki0l68.cloudfront.net/b964c59cdc1979dd4e1904c25f43745564ef6bee/f3351/docs/tutorials/kubernetes-basics/public/images/module_04_labels.svg" alt="enter image description here"></p><p>尽管每个 Pod 都有自己独立的 IP，但是这些 IP 要是没有 Service 就无法被外部网络访问。Service 有以下配置模式：</p><ul><li>ClusterIP（默认）： 赋予 Service 一个集群内部 IP 。这种模式使得服务只能在集群内可被访问。</li><li>NodePort：通过 NAT 允许 Service 使用集群内一个 Node 的 IP。从而就可以使用 \&lt;NodeIP>:\&lt;NodePort> 的方式让该 Service 可被集群外部访问。</li><li>LoadBalancer：创建一个外部负载均衡器，并赋予 Service 一个固定的外部 IP。</li><li>ExternalName：不使用代理，赋予 Service 一个任意的名字（由配置文件中的 <code>externalName</code> 参数决定）</li></ul><p>以下命令可创建一个名为 “kubernetes-bootcamp” 的 NodePort 模式的 Service（其对外部网络可见）。再使用 <code>describe service</code> 命令可查看某个 Service 的详情：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl expose deployment/kubernetes-bootcamp --type=&quot;NodePort&quot; --port 8080</span><br><span class="line">$ kubectl describe services/kubernetes-bootcamp</span><br></pre></td></tr></table></figure></p><p>可设置环境变量 NODE_PORT，通过 \&lt;NodeIP>:\&lt;NodePort> 从外网访问该 Service：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template=&apos;&#123;&#123;(index .spec.ports 0).nodePort&#125;&#125;&apos;)</span><br><span class="line">$ echo NODE_PORT=$NODE_PORT</span><br><span class="line">$ curl host01:$NODE_PORT</span><br></pre></td></tr></table></figure></p><p>接下来介绍 Label（标签）的使用。Deployment 会自动为 Pod 创建一个 Label，使用<code>kubectl describe</code>可以查看 Label 名字。使用带参的 <code>kubectl get</code> 命令可以查询特定 Label 的 Pod 或 Service。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods -l run=kubernetes-bootcamp</span><br><span class="line">$ kubectl get services -l run=kubernetes-bootcamp</span><br></pre></td></tr></table></figure></p><p>使用 <code>kubectl label</code> 命令为 Pod 增加一个新 Label 后，可用<code>kubectl describe</code>查询该 Pod 是否已有新 Label：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ export POD_NAME=$(kubectl get pods -o go-template --template &apos;&#123;&#123;range .items&#125;&#125;&#123;&#123;.metadata.name&#125;&#125;&#123;&#123;&quot;\n&quot;&#125;&#125;&#123;&#123;end&#125;&#125;&apos;)</span><br><span class="line">$ echo Name of the Pod: $POD_NAME</span><br><span class="line">$ kubectl label pod $POD_NAME app=v1</span><br><span class="line">$ kubectl describe pods $POD_NAME</span><br></pre></td></tr></table></figure></p><p>删除一个指定标签的 Service，之后便可测试到外部无法再通过 NodeIP 的方式访问到 app 了，但 app 仍在 Pod 中运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete service -l run=kubernetes-bootcamp</span><br><span class="line">$ curl host01:$NODE_PORT</span><br><span class="line">$ kubectl exec -ti $POD_NAME curl localhost:8080</span><br></pre></td></tr></table></figure></p><h2 id="8-调整应用规模"><a href="#8-调整应用规模" class="headerlink" title="8. 调整应用规模"></a>8. 调整应用规模</h2><p>在之前的章节中，Deployment 只创建了一个 Pod 来运行应用，但当通信量增加时，就需要扩展应用数量来满足需求。实现的主要方式则是改变 Deployment 配置中的副本数量。应用规模变化的示意图如下：</p><p><img src="https://d33wubrfki0l68.cloudfront.net/043eb67914e9474e30a303553d5a4c6c7301f378/0d8f6/docs/tutorials/kubernetes-basics/public/images/module_05_scaling1.svg" alt="enter image description here"></p><p><img src="https://d33wubrfki0l68.cloudfront.net/30f75140a581110443397192d70a4cdb37df7bfc/b5f56/docs/tutorials/kubernetes-basics/public/images/module_05_scaling2.svg" alt="enter image description here"></p><p>若当前集群已有一个 Deployment（假设名为”kubernetes-bootcamp”），则可使用<code>kubectl scale</code>命令来扩展副本数量到 4 个，之后便可以检查到 pods 数量发生了变化。同时该变化也被 Deployment 记录到日志，可在详情中查看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl scale deployments/kubernetes-bootcamp --replicas=4</span><br><span class="line">$ kubectl get deployments</span><br><span class="line">$ kubectl get pods -o wide</span><br><span class="line">$ kubectl describe deployments/kubernetes-bootcamp</span><br></pre></td></tr></table></figure></p><h2 id="9-执行滚动更新"><a href="#9-执行滚动更新" class="headerlink" title="9. 执行滚动更新"></a>9. 执行滚动更新</h2><p>通常用户希望应用可一直被访问，而开发者希望应用可短时间内更新多次。而<strong>滚动更新</strong>能满足该要求，允许应用以零停机时间进行部署更新（通过新增的 Pods 来更新 Pods 实例）。默认情况下，更新过程中不可用 Pods 的最大数量与新创建 Pods 的最大数量相等。k8s 集群也可以回滚该更新。</p><p><img src="https://d33wubrfki0l68.cloudfront.net/678bcc3281bfcc588e87c73ffdc73c7a8380aca9/703a2/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates2.svg" alt="enter image description here"></p><p><img src="https://d33wubrfki0l68.cloudfront.net/9b57c000ea41aca21842da9e1d596cf22f1b9561/91786/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates3.svg" alt="enter image description here"></p><p><img src="https://d33wubrfki0l68.cloudfront.net/6d8bc1ebb4dc67051242bc828d3ae849dbeedb93/fbfa8/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates4.svg" alt="enter image description here"></p><p>使用<code>set image</code>命令可进行镜像更新，<code>rollout status</code>命令可进行更新确认提交，<code>rollout undo</code>可进行更新回滚。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=jocatalin/kubernetes-bootcamp:v2</span><br><span class="line">$ kubectl rollout status deployments/kubernetes-bootcamp</span><br><span class="line">$ kubectl rollout undo deployments/kubernetes-bootcamp</span><br></pre></td></tr></table></figure></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>机器的内存必须在4G以上，否则启动 VirtualBox 时会失败</li><li>使用 curl 下载时，偶尔会因为网速问题无法下载成功。此时应当通过其他方式下载文件然后手动上传到系统中</li><li>启动 minikube 时可能会存在 localkube 找不到对应文件的情况，这是因为 localkube 的镜像下载不成功。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://kubernetes.io/docs/getting-started-guides/minikube/#minikube-features" target="_blank" rel="noopener">Running Kubernetes Locally via Minikube</a>（来自官网）</p><p><a href="https://linux.cn/article-8847-1.html" target="_blank" rel="noopener">Minikube：使用 Kubernetes 进行本地开发</a><br><!--stackedit_data:eyJoaXN0b3J5IjpbOTQ2MjI4MjY5XX0=--></p><hr><ul><li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p></li><li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p></li></ul><h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p><blockquote><p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p></blockquote><blockquote><p>体育&amp;户外用品推荐</p></blockquote><div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/se-notes/云计算实践/Kubernetes部署/k8s基础教程/../more/ads/amazon.gif" width="100%"></a> </div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#k8s-集群的介绍安装与配置实践版&quot;&gt;K8S 集群的介绍、安装与配置（实践版）&lt;/a&gt;&lt;pre&gt;&lt;code&gt;- [术语简介](#术语简介)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1--事前准
      
    
    </summary>
    
      <category term="通用技术" scheme="https://wnhby.github.io/categories/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/"/>
    
      <category term="云计算实践" scheme="https://wnhby.github.io/categories/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%AE%9E%E8%B7%B5/"/>
    
      <category term="kubernetes部署" scheme="https://wnhby.github.io/categories/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%AE%9E%E8%B7%B5/kubernetes%E9%83%A8%E7%BD%B2/"/>
    
    
      <category term="docker" scheme="https://wnhby.github.io/tags/docker/"/>
    
      <category term="云计算" scheme="https://wnhby.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="kubernetes" scheme="https://wnhby.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Docker-Notesby-CS-Notes.md</title>
    <link href="https://wnhby.github.io/Docker-Notes-by-CS-Notes/"/>
    <id>https://wnhby.github.io/Docker-Notes-by-CS-Notes/</id>
    <published>2019-01-03T13:49:30.000Z</published>
    <updated>2019-01-23T13:21:41.980Z</updated>
    
    <content type="html"><![CDATA[<!-- GFM-TOC --><ul><li><a href="#一解决的问题">一、解决的问题</a></li><li><a href="#二与虚拟机的比较">二、与虚拟机的比较</a></li><li><a href="#三优势">三、优势</a></li><li><a href="#四使用场景">四、使用场景</a></li><li><a href="#五镜像与容器">五、镜像与容器</a></li><li><a href="#参考资料">参考资料</a><!-- GFM-TOC --></li></ul><h1 id="一、解决的问题"><a href="#一、解决的问题" class="headerlink" title="一、解决的问题"></a>一、解决的问题</h1><p>由于不同的机器有不同的操作系统，以及不同的库和组件，在将一个应用部署到多台机器上需要进行大量的环境配置操作。</p><p>Docker 主要解决环境配置问题，它是一种虚拟化技术，对进程进行隔离，被隔离的进程独立于宿主操作系统和其它隔离的进程。使用 Docker 可以不修改应用程序代码，不需要开发人员学习特定环境下的技术，就能够将现有的应用程序部署在其他机器中。</p><div align="center"> <img src="/Docker-Notes-by-CS-Notes/pics/011f3ef6-d824-4d43-8b2c-36dab8eaaa72-1.png" width="400px"> </div><br><br><br># 二、与虚拟机的比较<br><br>虚拟机也是一种虚拟化技术，它与 Docker 最大的区别在于它是通过模拟硬件，并在硬件上安装操作系统来实现。<br><br><div align="center"> <img src="/Docker-Notes-by-CS-Notes/pics/71f61bc3-582d-4c27-8bdd-dc7fb135bf8f.png" width="250px"> </div><br><br><br><div align="center"> <img src="/Docker-Notes-by-CS-Notes/pics/7e873b60-44dc-4911-b080-defd5b8f0b49.png" width="250"> </div><br><br><br>## 启动速度<br><br>启动虚拟机需要启动虚拟机的操作系统，再启动应用，这个过程非常慢；<br><br>而启动 Docker 相当于启动宿主操作系统上的一个进程。<br><br>## 占用资源<br><br>虚拟机是一个完整的操作系统，需要占用大量的磁盘、内存和 CPU，一台机器只能开启几十个的虚拟机。<br><br>而 Docker 只是一个进程，只需要将应用以及相关的组件打包，在运行时占用很少的资源，一台机器可以开启成千上万个 Docker。<br><br># 三、优势<br><br>除了启动速度快以及占用资源少之外，Docker 具有以下优势：<br><br>## 更容易迁移<br><br>提供一致性的运行环境，可以在不同的机器上进行迁移，而不用担心环境变化导致无法运行。<br><br>## 更容易维护<br><br>使用分层技术和镜像，使得应用可以更容易复用重复部分。复用程度越高，维护工作也越容易。<br><br>## 更容易扩展<br><br>可以使用基础镜像进一步扩展得到新的镜像，并且官方和开源社区提供了大量的镜像，通过扩展这些镜像可以非常容易得到我们想要的镜像。<br><br># 四、使用场景<br><br>## 持续集成<br><br>持续集成指的是频繁地将代码集成到主干上，这样能够更快地发现错误。<br><br>Docker 具有轻量级以及隔离性的特点，在将代码集成到一个 Docker 中不会对其它 Docker 产生影响。<br><br>## 提供可伸缩的云服务<br><br>根据应用的负载情况，可以很容易地增加或者减少 Docker。<br><br>## 搭建微服务架构<br><br>Docker 轻量级的特点使得它很适合用于部署、维护、组合微服务。<br><br># 五、镜像与容器<br><br>镜像是一种静态的结构，可以看成面向对象里面的类，而容器是镜像的一个实例。<br><br>镜像包含着容器运行时所需要的代码以及其它组件，它是一种分层结构，每一层都是只读的（read-only layers）。构建镜像时，会一层一层构建，前一层是后一层的基础。镜像的这种分层存储结构很适合镜像的复用以及定制。<br><br>构建容器时，通过在镜像的基础上添加一个可写层（writable layer），用来保存着容器运行过程中的修改。<br><br><div align="center"> <img src="/Docker-Notes-by-CS-Notes/pics/docker-filesystems-busyboxrw.png"> </div><br><br><br># 参考资料<br><br>- <a href="https://blog.docker.com/2017/08/docker-101-introduction-docker-webinar-recap/" target="_blank" rel="noopener">DOCKER 101: INTRODUCTION TO DOCKER WEBINAR RECAP</a><br>- <a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">Docker 入门教程</a><br>- <a href="http://www.bogotobogo.com/DevOps/Docker/Docker_Container_vs_Virtual_Machine.php" target="_blank" rel="noopener">Docker container vs Virtual machine</a><br>- <a href="https://linoxide.com/linux-how-to/dockerfile-create-docker-container/" target="_blank" rel="noopener">How to Create Docker Container using Dockerfile</a><br>- <a href="http://www.cnblogs.com/sammyliu/p/5877964.html" target="_blank" rel="noopener">理解 Docker（2）：Docker 镜像</a><br>- <a href="https://yeasy.gitbooks.io/docker_practice/introduction/why.html" target="_blank" rel="noopener">为什么要使用 Docker？</a><br>- <a href="https://www.docker.com/what-docker" target="_blank" rel="noopener">What is Docker</a><br>- <a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" target="_blank" rel="noopener">持续集成是什么？</a><br><br>[转自]: <a href="https://github.com/CyC2018/" target="_blank" rel="noopener">https://github.com/CyC2018/</a><br><br><br>—<br><br><em> <a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </em> <a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a><br><br><br>### Ads<br><br><em>这是小广告! 如果有需要, 不妨支持一下吧~</em><br><br>&gt;  <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"><br><br>&gt; 体育&amp;户外用品推荐<br><div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/Docker-Notes-by-CS-Notes/../more/ads/amazon.gif" width="100%"></a> </div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- GFM-TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一解决的问题&quot;&gt;一、解决的问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#二与虚拟机的比较&quot;&gt;二、与虚拟机的比较&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#三优势&quot;&gt;三、优势&lt;/a&gt;&lt;/li&gt;
&lt;li
      
    
    </summary>
    
      <category term="通用技术" scheme="https://wnhby.github.io/categories/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Docker" scheme="https://wnhby.github.io/categories/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/Docker/"/>
    
    
      <category term="docker" scheme="https://wnhby.github.io/tags/docker/"/>
    
      <category term="CS-Notes" scheme="https://wnhby.github.io/tags/CS-Notes/"/>
    
  </entry>
  
  <entry>
    <title>kubeadm部署多节点集群</title>
    <link href="https://wnhby.github.io/se-notes/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%AE%9E%E8%B7%B5/Kubernetes%E9%83%A8%E7%BD%B2/kubeadm%E9%83%A8%E7%BD%B2%E5%A4%9A%E8%8A%82%E7%82%B9%E9%9B%86%E7%BE%A4/"/>
    <id>https://wnhby.github.io/se-notes/云计算实践/Kubernetes部署/kubeadm部署多节点集群/</id>
    <published>2019-01-03T13:49:30.000Z</published>
    <updated>2019-02-19T05:21:17.004Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#kubeadm-%E9%83%A8%E7%BD%B2%E5%A4%9A%E8%8A%82%E7%82%B9-k8s-%E9%9B%86%E7%BE%A4%E6%95%99%E7%A8%8B191">kubeadm 部署多节点 k8s 集群教程（1.9.1）</a><ul><li><a href="#%E4%B8%80-%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6">一. 前提条件</a></li><li><a href="#%E4%BA%8C-%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E7%8E%AF%E5%A2%83">二. 安装依赖环境</a><ul><li><a href="#%E5%AE%89%E8%A3%85-docker">安装 Docker</a></li></ul></li></ul></li><li><a href="#k8sconf%E6%98%AFk8s%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">k8s.conf是k8s的配置文件</a></li><li><a href="#dashboard-service">——————- Dashboard Service ——————-</a><ul><li><a href="#kubectl-delete--f-kubernetes-dashboardyaml">$ kubectl delete -f kubernetes-dashboard.yaml</a></li></ul></li></ul><!-- /TOC --><h1 id="kubeadm-部署多节点-k8s-集群教程（1-9-1）"><a href="#kubeadm-部署多节点-k8s-集群教程（1-9-1）" class="headerlink" title="kubeadm 部署多节点 k8s 集群教程（1.9.1）"></a>kubeadm 部署多节点 k8s 集群教程（1.9.1）</h1><p>kubeadm 是一个用于快速创建与扩展 k8s 集群的工具包。本教程主要讲述如何使用 kubeadm 构建一个双节点的 k8s 集群（版本为 1.9.1），构建集群中的 pod 通信网络，最后安装可视化的管理控制台。</p><p>本教程的集群节点均是由同一台 PC 所虚拟出来的两台虚机。</p><h2 id="一-前提条件"><a href="#一-前提条件" class="headerlink" title="一. 前提条件"></a>一. 前提条件</h2><p>配置要求如下：</p><ul><li>两台安装有 CentOS 7 操作系统的机器（命名为 kube-1 与 kube-2）</li><li>每台机器拥有 2G 以上内存以及 2核 以上处理器</li><li>每台机器关闭防火墙与 SELinux</li><li>每台机器彼此之间都可以通过网络联通</li><li>拥有一个可以“科学上网”的 ShadowSocksS 服务器</li></ul><p>禁用 swap，以保证 kubelet 正确运行：每台机器执行<code>swapoff -a</code>。（注意：机器重启后可能需要再次禁用 swap）</p><p>确认每台机器的 MAC 地址与 product_uuid 都是独有的。查询 MAC 地址：<code>ifconfig -a</code>，查询 product_uuid：<code>cat /sys/class/dmi/id/product_uuid</code>。</p><p>拥有一个可以科学上网的 VPS 服务器：<a href="https://github.com/Zouzhp3/Learn/blob/master/kubernetes/%E9%85%8D%E7%BD%AE%20VPS%20%E8%BF%9B%E8%A1%8C%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91.md" target="_blank" rel="noopener">VPS 配置 Shadowsocks 教程</a>。</p><p>每台机器都可以科学上网：<a href="https://github.com/Zouzhp3/Learn/blob/master/kubernetes/%28%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%29Linux%20%E9%85%8D%E7%BD%AE%20Shadowsocks%20%E5%AE%A2%E6%88%B7%E7%AB%AF.md" target="_blank" rel="noopener">Linux 配置 Shadowsocks 客户端</a>，以及 <a href="https://github.com/Zouzhp3/Learn/blob/master/kubernetes/%E4%B8%BA%20Docker%20%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86.md" target="_blank" rel="noopener">为 Docker 配置网络代理</a>。如果不能科学上网的话，就会导致很多镜像无法正常下载。</p><h2 id="二-安装依赖环境"><a href="#二-安装依赖环境" class="headerlink" title="二. 安装依赖环境"></a>二. 安装依赖环境</h2><h3 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h3><p>为所有节点（逻辑上的机器）安装 Docker，官方推荐安装 v1.12 版本（过高版本将不兼容 k8s）。可参考 <a href="https://github.com/Zouzhp3/Learn/blob/master/kubernetes/Docker%20CE%20%E5%AE%89%E8%A3%85.md" target="_blank" rel="noopener">Docker CE 安装</a>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">$ yum makecache fast</span><br><span class="line">$ yum install -y docker-ce</span><br><span class="line">$ systemctl enable docker &amp;&amp; systemctl start docker</span><br><span class="line">``` ocker stmeablekertesocker</span><br></pre></td></tr></table></figure></p><p> ucgr    r<br>    /tc/docker/eoso<br>  ec atuiersystemdocker  et r ocker<code></code></p><h3 id="安装-kubeadm-kubelet-与-kubectl"><a href="#安装-kubeadm-kubelet-与-kubectl" class="headerlink" title="安装 kubeadm, kubelet 与 kubectl"></a>安装 kubeadm, kubelet 与 kubectl</h3><p>需要在所有节点上安装：</p><ul><li>kubeadm：引导集群的命令工具</li><li>kubelet：运行在集群中所有节点上的组件，负责处理 Pods 与容器。</li><li>kubectl：与集群交互的命令工具</li></ul><p>若可以“科学上网”（否则需要手动下载 rpm 包），则安装命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">$ yum install -y kubelet-1.9.1 kubeadm-1.9.1 kubectl-1.9.1</span><br><span class="line">$ systemctl enable kubelet &amp;&amp; systemctl start kubelet</span><br></pre></td></tr></table></figure></p><blockquote><p>选择 1.9.1 版本进行下载，但请注意必须确保 kubeadm， kubelet 的版本都一致，且与 kubectl 不低于 kubeadm 的版本。</p></blockquote><p>为防止“科学上网”，则可直接进行下一步。否则就需要手动 kubeadm 初始化 k8s 时 RHEL/CentOS 7 的用户可能会报错配置失败：<code>You should ensure net.bridge.bridge-nf-call-iptables is set to 1 in your sysctl config</code>。需要执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># k8s.conf是k8s的配置文件</span><br><span class="line">$ cat &lt;&lt;EOF &gt;  /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br><span class="line">$ sysctl --system</span><br></pre></td></tr></table></figure></p><p>若 Docker 也配置了代理“科学上网”，则可直接进行下一步，否则就需要手动下载如下镜像到本地：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY                                               TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">gcr.io/google_containers/kube-apiserver-amd64            v1.9.1              e313a3e9d78d        7 weeks ago         210.4 MB</span><br><span class="line">gcr.io/google_containers/kube-scheduler-amd64            v1.9.1              677911f7ae8f        7 weeks ago         62.7 MB</span><br><span class="line">gcr.io/google_containers/kube-proxy-amd64                v1.9.1              e470f20528f9        7 weeks ago         109.1 MB</span><br><span class="line">gcr.io/google_containers/kube-controller-manager-amd64   v1.9.1              4978f9a64966        7 weeks ago         137.8 MB</span><br><span class="line">quay.io/coreos/flannel                                   v0.9.1-amd64        2b736d06ca4c        3 months ago        51.31 MB</span><br><span class="line">gcr.io/google_containers/k8s-dns-sidecar-amd64           1.14.7              db76ee297b85        4 months ago        42.03 MB</span><br><span class="line">gcr.io/google_containers/k8s-dns-kube-dns-amd64          1.14.7              5d049a8c4eec        4 months ago        50.27 MB</span><br><span class="line">gcr.io/google_containers/k8s-dns-dnsmasq-nanny-amd64     1.14.7              5feec37454f4        4 months ago        40.95 MB</span><br><span class="line">gcr.io/google_containers/etcd-amd64                      3.1.10              1406502a6459        5 months ago        192.7 MB</span><br><span class="line">gcr.io/google_containers/pause-amd64                     3.0                 99e59f495ffa        22 months ago       746.9 kB</span><br></pre></td></tr></table></figure></p><p>可通过 <a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-init/" target="_blank" rel="noopener">官网</a> 来查看所需手动下载的依赖镜像的版本。</p><h2 id="三-使用-kubeadm-初始化集群"><a href="#三-使用-kubeadm-初始化集群" class="headerlink" title="三. 使用 kubeadm 初始化集群"></a>三. 使用 kubeadm 初始化集群</h2><p>在一个节点（该节点将会成为集群的 master ）上使用<code>kubeadm init --kubernetes-version 1.9.1 --pod-network-cidr=10.244.0.0/16</code>来初始化一个集群（<code>--pod-network-cidr</code> 在下一节介绍）。</p><blockquote><p>注意：若主机开启了“科学上网”的网络访问代理的话，需要先关掉主机的代理，否则初始化集群时访问内部 IP 也会经过代理，从而导致报错。</p></blockquote><p>若运行成功，则输出将如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">[kubeadm] WARNING: kubeadm is in beta, please do not use it for production clusters.</span><br><span class="line">[init] Using Kubernetes version: v1.8.0</span><br><span class="line">[init] Using Authorization modes: [Node RBAC]</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">[kubeadm] WARNING: starting in 1.8, tokens expire after 24 hours by default (if you require a non-expiring token use --token-ttl 0)</span><br><span class="line">[certificates] Generated ca certificate and key.</span><br><span class="line">[certificates] Generated apiserver certificate and key.</span><br><span class="line">[certificates] apiserver serving cert is signed for DNS names [kubeadm-master kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 10.138.0.4]</span><br><span class="line">[certificates] Generated apiserver-kubelet-client certificate and key.</span><br><span class="line">[certificates] Generated sa key and public key.</span><br><span class="line">[certificates] Generated front-proxy-ca certificate and key.</span><br><span class="line">[certificates] Generated front-proxy-client certificate and key.</span><br><span class="line">[certificates] Valid certificates and keys now exist in &quot;/etc/kubernetes/pki&quot;</span><br><span class="line">[kubeconfig] Wrote KubeConfig file to disk: &quot;admin.conf&quot;</span><br><span class="line">[kubeconfig] Wrote KubeConfig file to disk: &quot;kubelet.conf&quot;</span><br><span class="line">[kubeconfig] Wrote KubeConfig file to disk: &quot;controller-manager.conf&quot;</span><br><span class="line">[kubeconfig] Wrote KubeConfig file to disk: &quot;scheduler.conf&quot;</span><br><span class="line">[controlplane] Wrote Static Pod manifest for component kube-apiserver to &quot;/etc/kubernetes/manifests/kube-apiserver.yaml&quot;</span><br><span class="line">[controlplane] Wrote Static Pod manifest for component kube-controller-manager to &quot;/etc/kubernetes/manifests/kube-controller-manager.yaml&quot;</span><br><span class="line">[controlplane] Wrote Static Pod manifest for component kube-scheduler to &quot;/etc/kubernetes/manifests/kube-scheduler.yaml&quot;</span><br><span class="line">[etcd] Wrote Static Pod manifest for a local etcd instance to &quot;/etc/kubernetes/manifests/etcd.yaml&quot;</span><br><span class="line">[init] Waiting for the kubelet to boot up the control plane as Static Pods from directory &quot;/etc/kubernetes/manifests&quot;</span><br><span class="line">[init] This often takes around a minute; or longer if the control plane images have to be pulled.</span><br><span class="line">[apiclient] All control plane components are healthy after 39.511972 seconds</span><br><span class="line">[uploadconfig] Storing the configuration used in ConfigMap &quot;kubeadm-config&quot; in the &quot;kube-system&quot; Namespace</span><br><span class="line">[markmaster] Will mark node master as master by adding a label and a taint</span><br><span class="line">[markmaster] Master master tainted and labelled with key/value: node-role.kubernetes.io/master=&quot;&quot;</span><br><span class="line">[bootstraptoken] Using token: &lt;token&gt;</span><br><span class="line">[bootstraptoken] Configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials</span><br><span class="line">[bootstraptoken] Configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token</span><br><span class="line">[bootstraptoken] Creating the &quot;cluster-info&quot; ConfigMap in the &quot;kube-public&quot; namespace</span><br><span class="line">[addons] Applied essential addon: kube-dns</span><br><span class="line">[addons] Applied essential addon: kube-proxy</span><br><span class="line"></span><br><span class="line">Your Kubernetes master has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run (as a regular user):</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  http://kubernetes.io/docs/admin/addons/</span><br><span class="line"></span><br><span class="line">You can now join any number of machines by running the following on each node</span><br><span class="line">as root:</span><br><span class="line"></span><br><span class="line">  kubeadm join --token &lt;token&gt; &lt;master-ip&gt;:&lt;master-port&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt;</span><br></pre></td></tr></table></figure></p><p>初始化完毕后，运行以下命令给予用户权限来使用集群：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p $HOME/.kube</span><br><span class="line">$ sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">$ sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure></p><p>执行 <code>kubectl get nodes</code>，发现得到了一个状态为<code>NotReady</code>的 Node。</p><p>查看一下集群状态<code>kubectl get cs</code>，确认各个组件都处于 healthy 状态。：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NAME                 STATUS    MESSAGE              ERROR</span><br><span class="line">scheduler            Healthy   ok</span><br><span class="line">controller-manager   Healthy   ok</span><br><span class="line">etcd-0               Healthy   &#123;&quot;health&quot;: &quot;true&quot;&#125;</span><br></pre></td></tr></table></figure></p><p>查看集群组件 pod 运行情况：<code>kubectl get pods --all-namespaces</code>，正常情况下的输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NAMESPACE     NAME                             READY     STATUS    RESTARTS   AGE</span><br><span class="line">kube-system   etcd-kube-1                      1/1       Running   0          1h</span><br><span class="line">kube-system   kube-apiserver-kube-1            1/1       Running   0          1h</span><br><span class="line">kube-system   kube-controller-manager-kube-1   1/1       Running   0          1h</span><br><span class="line">kube-system   kube-dns-6f4fd4bdf-jthnq         0/3       Pending   0          1h</span><br><span class="line">kube-system   kube-proxy-2r2m4                 1/1       Running   0          1h</span><br><span class="line">kube-system   kube-scheduler-kube-1            1/1       Running   0          1h</span><br></pre></td></tr></table></figure></p><blockquote><p>上面输出的 kube-dns 的状态是正常的，因为集群还没有配置网络。</p></blockquote><p>此外，集群初始化如果遇到问题，可以使用下面的命令进行清理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ kubeadm reset</span><br><span class="line">$ ifconfig cni0 down</span><br><span class="line">$ ip link delete cni0</span><br><span class="line">$ ifconfig flannel.1 down</span><br><span class="line">$ ip link delete flannel.1</span><br><span class="line">$ rm -rf /var/lib/cni/</span><br></pre></td></tr></table></figure></p><h2 id="四-配置集群网络（Flannel）"><a href="#四-配置集群网络（Flannel）" class="headerlink" title="四. 配置集群网络（Flannel）"></a>四. 配置集群网络（Flannel）</h2><p>集群必须安装一个 pod 网络插件以便于 pods 能够互相通信，本教程中使用 Flannel 作为集群配置网络。</p><blockquote><p>为使 flannel 运行成功，<code>kubeadm init</code> 运行时必须加上参数<code>--pod-network-cidr=10.244.0.0/16</code>。</p></blockquote><p>运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/v0.9.1/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure></p><p>正常输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clusterrole &quot;flannel&quot; created</span><br><span class="line">clusterrolebinding &quot;flannel&quot; created</span><br><span class="line">serviceaccount &quot;flannel&quot; created</span><br><span class="line">configmap &quot;kube-flannel-cfg&quot; created</span><br><span class="line">daemonset &quot;kube-flannel-ds&quot; created</span><br></pre></td></tr></table></figure></p><p>等待一段时间后，查看组件 pod 的运行情况：<code>kubectl get pods --all-namespaces</code>，若所有pods 都处于运行成功的状态，则说明网络部署成功。然后执行 <code>kubectl get nodes</code> 也可以发现 Node 已经处于 Ready 状态了。</p><blockquote><p>注意：若主机有多个网卡，则可能会遭遇错误如右：<a href="https://github.com/kubernetes/kubernetes/issues/39701" target="_blank" rel="noopener">flannel issues 3970</a>。<br>解决该问题（尚未测试）：目前需要在 kube-flannel.yml 中使用<code>--iface</code>参数指定集群主机内网网卡的名称，否则可能会导致 dns 无法解析。因此需要将 kube-flannel.yml 下载到本地，flanneld 启动参数加上 <code>--iface=&lt;iface-name&gt;</code>。</p></blockquote><h3 id="配置-master-节点是否调度-pod（可选）"><a href="#配置-master-节点是否调度-pod（可选）" class="headerlink" title="配置 master 节点是否调度 pod（可选）"></a>配置 master 节点是否调度 pod（可选）</h3><p>出于安全性考虑，在默认情况下 pod 不会被调度到 master 节点上，也就是说它不参与工作负载。但如果需要 master 也能调度 pod，以便于构造一个单节点集群用于开发用，则可以执行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl taint nodes --all node-role.kubernetes.io/master-</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node &quot;test-01&quot; untainted</span><br><span class="line">taint key=&quot;dedicated&quot; and effect=&quot;&quot; not found.</span><br><span class="line">taint key=&quot;dedicated&quot; and effect=&quot;&quot; not found.</span><br></pre></td></tr></table></figure></p><h2 id="五-向集群中添加节点"><a href="#五-向集群中添加节点" class="headerlink" title="五. 向集群中添加节点"></a>五. 向集群中添加节点</h2><p>Node 是集群中负责运行容器与 Pod 的节点，当需要添加一个主机到集群中成为一个新 Node 时，ssh 连接到该主机，切换到 root 用户权限，运行 master 节点 <code>kubeadm init</code> 时的输出中的参考命令，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubeadm join --token &lt;token&gt; &lt;master-ip&gt;:&lt;master-port&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt;</span><br></pre></td></tr></table></figure></p><p>若运行成功则输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[preflight] Running pre-flight checks.</span><br><span class="line">[WARNING FileExisting-crictl]: crictl not found in system path</span><br><span class="line">[discovery] Trying to connect to API Server &quot;192.168.80.128:6443&quot;</span><br><span class="line">[discovery] Created cluster-info discovery client, requesting info from &quot;https://192.168.80.128:6443&quot;</span><br><span class="line">[discovery] Requesting info from &quot;https://192.168.80.128:6443&quot; again to validate TLS against the pinned public key</span><br><span class="line">[discovery] Cluster info signature and contents are valid and TLS certificate validates against pinned roots, will use API Server &quot;192.168.80.128:6443&quot;</span><br><span class="line">[discovery] Successfully established connection with API Server &quot;192.168.80.128:6443&quot;</span><br><span class="line"></span><br><span class="line">This node has joined the cluster:</span><br><span class="line">* Certificate signing request was sent to master and a response</span><br><span class="line">  was received.</span><br><span class="line">* The Kubelet was informed of the new secure connection details.</span><br><span class="line"></span><br><span class="line">Run &apos;kubectl get nodes&apos; on the master to see this node join the cluster.</span><br></pre></td></tr></table></figure></p><p>过一段时间后查询 <code>kubectl get nodes</code> 即可得到处于 Ready 状态的新 Node。</p><h3 id="尝试运行一个应用（可选-amp-重要）"><a href="#尝试运行一个应用（可选-amp-重要）" class="headerlink" title="尝试运行一个应用（可选&amp;重要）"></a>尝试运行一个应用（可选&amp;重要）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl run curl --image=radial/busyboxplus:curl -i --tty</span><br><span class="line">If you don&apos;t see a command prompt, try pressing enter.</span><br><span class="line">[ root@curl-2716574283-xr8zd:/ ]$</span><br></pre></td></tr></table></figure><p>进入后执行 <code>nslookup kubernetes.default</code> 确认是否解析正常:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ nslookup kubernetes.default</span><br><span class="line">Server:    10.96.0.10</span><br><span class="line">Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local</span><br><span class="line"></span><br><span class="line">Name:      kubernetes.default</span><br><span class="line">Address 1: 10.96.0.1 kubernetes.default.svc.cluster.local</span><br></pre></td></tr></table></figure></p><h3 id="从-master-以外的节点来控制集群（可选-amp-重要）"><a href="#从-master-以外的节点来控制集群（可选-amp-重要）" class="headerlink" title="从 master 以外的节点来控制集群（可选&amp;重要）"></a>从 master 以外的节点来控制集群（可选&amp;重要）</h3><p>为了让其他节点（或者集群外部的节点）上的 kubectl 可以与集群通信，你需要从 master 节点复制管理员集群配置文件 <code>admin.conf</code> 到目标节点，命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ scp root@&lt;master ip&gt;:/etc/kubernetes/admin.conf .</span><br><span class="line">$ kubectl --kubeconfig ./admin.conf get nodes</span><br></pre></td></tr></table></figure></p><blockquote><p><code>admin.conf</code> 给予用户控制集群的超级权限，必须谨慎使用。<br>对于普通用户而言，建议生成一个独一凭证，使得放置该用户于白名单中：<code>$ kubeadm alpha phase kubeconfig user --client-name &lt;CN&gt;</code>，该命令将会输出一个 KubeConfig 文件，你可以保存该文件并发给该普通用户。然后使用<code>$ kubectl create (cluster)rolebinding</code> 启动白名单。</p></blockquote><h3 id="配置-API-Server-的代理到本地-localhost（可选-amp-重要）"><a href="#配置-API-Server-的代理到本地-localhost（可选-amp-重要）" class="headerlink" title="配置 API Server 的代理到本地 localhost（可选&amp;重要）"></a>配置 API Server 的代理到本地 localhost（可选&amp;重要）</h3><p>若需要从<strong>集群外部</strong>连接到集群的 API Server，则可以使用<code>kubectl proxy</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ scp root@&lt;master ip&gt;:/etc/kubernetes/admin.conf .</span><br><span class="line">$ kubectl --kubeconfig ./admin.conf proxy</span><br></pre></td></tr></table></figure></p><p>这样就可以在本地通过 <code>http://localhost:8001/api/v1</code> 来访问集群的 API Server 了。</p><h2 id="六-从集群中删除节点"><a href="#六-从集群中删除节点" class="headerlink" title="六. 从集群中删除节点"></a>六. 从集群中删除节点</h2><p>当需要从一个集群中删除节点时，首先需要停止该节点以确保该节点在关闭前是空的。</p><p>在 master 上运行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl drain &lt;node name&gt; --delete-local-data --force --ignore-daemonsets</span><br><span class="line">$ kubectl delete node &lt;node name&gt;</span><br></pre></td></tr></table></figure></p><p>然后在被删除的节点上重置 kubeadm 的状态即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubeadm reset</span><br></pre></td></tr></table></figure></p><h2 id="七-安装-Dashboard"><a href="#七-安装-Dashboard" class="headerlink" title="七. 安装 Dashboard"></a>七. 安装 Dashboard</h2><p><a href="https://github.com/kubernetes/dashboard" target="_blank" rel="noopener">Kubernetes Dashboard</a> 是一个基于 web 的 k8s 集群控制台，它允许用户管理和调试已经运行在集群上的应用，甚至可以管理集群本身。</p><p>下载 Dashboard 的 yaml 配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://raw.githubusercontent.com/kubernetes/dashboard/master/src/deploy/recommended/kubernetes-dashboard.yaml</span><br></pre></td></tr></table></figure></p><p>由于Dashboard 的 service 配置模式是 ClusterIP 而不能被集群外访问，因此我们需要配置成 NodePort 模式。编辑 <code>kubernetes-dashboard.yaml</code> 文件，在 <code>Dashboard Service</code> 中添加<code>type: NodePort</code>，暴露 Dashboard 服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># ------------------- Dashboard Service ------------------- #</span><br><span class="line"></span><br><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  name: kubernetes-dashboard</span><br><span class="line">  namespace: kube-system</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort</span><br><span class="line">  ports:</span><br><span class="line">    - port: 443</span><br><span class="line">      targetPort: 8443</span><br><span class="line">  selector:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br></pre></td></tr></table></figure></p><p>根据配置文件安装 Dashboard（若不能“科学上网”则可能下载镜像失败）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f kubernetes-dashboard.yaml</span><br></pre></td></tr></table></figure></p><p>执行 <code>kubectl proxy</code> 启动代理后，可以在<strong>代理机本地</strong>通过以下 URL 访问 Dashboard 网站：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/</span><br></pre></td></tr></table></figure></p><p>也可以在外部通过<code>https://[NodeIP]:[NodePort]</code>来访问。</p><p>查看网站页面的登录 token：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n kube-system get secret | grep kubernetes-dashboard</span><br><span class="line">kubernetes-dashboard-token-jxq7l kubernetes.io/service-account-token 3  22h</span><br><span class="line">$ kubectl describe -n kube-system secret/kubernetes-dashboard-token-jxq7l</span><br></pre></td></tr></table></figure></p><p>当需要卸载 Dashboard ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete -f kubernetes-dashboard.yaml</span><br></pre></td></tr></table></figure></p><h3 id="如何使用管理员权限？"><a href="#如何使用管理员权限？" class="headerlink" title="如何使用管理员权限？"></a>如何使用管理员权限？</h3><p>如果我们直接使用上面获取的 token 登录 Dashboard 的网站后，发现几乎大部分的权限都不可以使用。 这是因为默认的 <code>kubernetes-dashboard.yaml</code> 文件中的 ServiceAccount <code>kubernetes-dashboard</code> 只有相对较小的权限。</p><p>因此我们需要创建一个 <code>kubernetes-dashboard-admin</code> 的 ServiceAccount 并授予其集群 admin 的权限。创建 <code>kubernetes-dashboard-admin.rbac.yaml</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  name: kubernetes-dashboard-admin</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  </span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1beta1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: kubernetes-dashboard-admin</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: kubernetes-dashboard-admin</span><br><span class="line">  namespace: kube-system</span><br></pre></td></tr></table></figure></p><p>执行该文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f kubernetes-dashboard-admin.rbac.yaml</span><br></pre></td></tr></table></figure></p><p>再按照同样的方法查询到 <code>kubernetes-dashboard-admin</code> 的 token ，登录 Dashborad 网站后便可以使用所有功能了。</p><h2 id="八-Heapster-插件部署"><a href="#八-Heapster-插件部署" class="headerlink" title="八. Heapster 插件部署"></a>八. Heapster 插件部署</h2><p>安装 <a href="https://github.com/kubernetes/heapster/" target="_blank" rel="noopener">Heapster</a> 可以为集群添加使用统计和监控功能，为 Dashboard 添加仪表盘。使用 InfluxDB 做为 Heapster 的后端存储，开始部署：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/k8s/heapster</span><br><span class="line">cd ~/k8s/heapster</span><br><span class="line">wget https://raw.githubusercontent.com/kubernetes/heapster/master/deploy/kube-config/influxdb/grafana.yaml</span><br><span class="line">wget https://raw.githubusercontent.com/kubernetes/heapster/master/deploy/kube-config/rbac/heapster-rbac.yaml</span><br><span class="line">wget https://raw.githubusercontent.com/kubernetes/heapster/master/deploy/kube-config/influxdb/heapster.yaml</span><br><span class="line">wget https://raw.githubusercontent.com/kubernetes/heapster/master/deploy/kube-config/influxdb/influxdb.yaml</span><br><span class="line"></span><br><span class="line">kubectl create -f ./</span><br></pre></td></tr></table></figure><p>最后确认所有的 pod 都处于 running 状态，打开 Dashboard，集群的使用统计会以仪表盘的形式显示出来。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="1-为何配置了科学上网也无法-pull-gcr-io-的镜像？"><a href="#1-为何配置了科学上网也无法-pull-gcr-io-的镜像？" class="headerlink" title="1. 为何配置了科学上网也无法 pull gcr.io 的镜像？"></a>1. 为何配置了科学上网也无法 pull gcr.io 的镜像？</h3><p>主机网络代理与 docker 的网络代理设置是不同的，你还需要设置 docker 的网络代理：<a href="https://github.com/Zouzhp3/Learn/blob/master/kubernetes/%E4%B8%BA%20Docker%20%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86.md" target="_blank" rel="noopener">为 Docker 配置网络代理</a></p><h3 id="2-kubelet-服务不正常运行"><a href="#2-kubelet-服务不正常运行" class="headerlink" title="2. kubelet 服务不正常运行"></a>2. kubelet 服务不正常运行</h3><p>启动启动报错 </p><p>单独使用 <code>kubelet</code> 服务后命令时 ，发现没有正常运行，日志报错如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">error: failed to run Kubelet: failed to create kubelet: misconfiguration: kubelet cgroup driver: &quot;cgroupfs&quot; is different from docker cgroup driver: &quot;systemd&quot;</span><br><span class="line">``` </span><br><span class="line">kubelet 的配置文件是`/etc/systemd/system/kubelet.service.d/10-kubeadm.conf`，请确保里面`KUBELET_CGROUP_ARGS=--cgroup-driver=systemd`的 `--cgroup-driver`驱动与 `docker info` 里的 `--cgroup-driver` 驱动相同。但即使确保了相同，独自执行`kubelet`命令时也会继续报同样的错。</span><br><span class="line"></span><br><span class="line">后来发现，该配置文件是在集群初始化时才会成功读取，而单独执行`kubelet`时不会读取配置文件。</span><br><span class="line"></span><br><span class="line">因此无视此问题即可，不影响集群初始化。在集群初始化成功后，可以发现`kubelet`服务是正常运行的。后来发现不影响集群初始化，且成功初始化</span><br><span class="line"></span><br><span class="line">可参考：[1.6.0 kubelet fails with error &quot;misconfiguration: kubelet cgroup driver: &quot;cgroupfs&quot; is different from docker cgroup driver: &quot;systemd&quot;](https://github.com/kubernetes/kubernetes/issues/43805)</span><br><span class="line"></span><br><span class="line">### 3. 运行 kubeadm init 时弹出警告</span><br><span class="line"></span><br><span class="line">警告如下：</span><br></pre></td></tr></table></figure></p><p>[preflight] Running pre-flight checks.<br>    [WARNING FileExisting-crictl]: crictl not found in system path<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">经过 github 上的开发者确认，这个 warning 可以无视。</span><br><span class="line"></span><br><span class="line">### 4. 运行 kubeadm init 时报错</span><br><span class="line"></span><br><span class="line">报错如下所示：</span><br></pre></td></tr></table></figure></p><p>[kubelet-check] It seems like the kubelet isn’t running or healthy.<br>[kubelet-check] The HTTP call equal to ‘curl -sSL <a href="http://localhost:10255/healthz" target="_blank" rel="noopener">http://localhost:10255/healthz</a>‘ failed with error: Get <a href="http://localhost:10255/healthz" target="_blank" rel="noopener">http://localhost:10255/healthz</a>: dial tcp [::1]:10255: getsockopt: connection refused.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">经查资料发现是因为没有禁用 swap（每次机器重启会重置 swap），但是经过重置虚拟机网络以及恢复快照后得到的系统仍然会出现此错误。后来经过重新安装 kubeadm 与 kubelet 成功解决。</span><br><span class="line"></span><br><span class="line">### 5. 忘记了集群初始化成功时输出的参考命令</span><br><span class="line"></span><br><span class="line">如果不小心忘记了集群初始化成功时输出的参考命令，可使用以下命令来查询。</span><br><span class="line"></span><br><span class="line">查看 master 的 token：</span><br></pre></td></tr></table></figure></p><p>$ kubeadm token list | grep authentication,signing | awk ‘{print $1}’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查看 master 的 discovery-token-ca-cert-hash：</span><br></pre></td></tr></table></figure></p><p>$ openssl x509 -pubkey -in  /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null  | openssl dgst -sha256 -hex | sed ‘s/^.* //‘<br><code>`</code></p><h3 id="6-为何设置了-NodePort-模式也无法从外部访问-Dashboard-网站？"><a href="#6-为何设置了-NodePort-模式也无法从外部访问-Dashboard-网站？" class="headerlink" title="6. 为何设置了 NodePort 模式也无法从外部访问 Dashboard 网站？"></a>6. 为何设置了 NodePort 模式也无法从外部访问 Dashboard 网站？</h3><p>这是因为 Dashboard 配置文件默认采取了 HTTPS 协议，因此需要以 <code>https://[NodeIP]:[NodePort]</code> 的方式来访问。同时又因为 Chrome 浏览器不能支持访问未认证的 https 网站，所以建议使用其他浏览器（如 Firefox）。</p><h2 id="部署总结"><a href="#部署总结" class="headerlink" title="部署总结"></a>部署总结</h2><p>从零开始学习使用 kubeadm 部署一个 k8s 集群总计花了我五天多时间，一开始大部分时间花在了如何下载合适版本的 kubeadm 和 kubelet，以及通过各种手段下载国内获取不到的镜像，但效果仍然不好。之后通过搭建 ShadowSocks 客户端使得可以成功下载合适版本的 kubeadm 和 kubelet，但发现还是 pull 不了镜像，最后发现是因为 Docker 的代理配置与主机的代理配置是不共用的。配置了 Docker 代理后便可以在初始化集群的过程中自动 pull 需要的镜像。通过使用翻墙代理，确实可以少花很多不必要的时间。</p><p>部署期间也遇到一些问题，有的是因为过于钻牛角尖，陷入到单独启动 <code>kubelet</code> 失败的问题中了，误以为该问题必须在集群初始化之前解决；有的是因为理论知识不扎实，对 Docker 的不了解；还有的是就是虚拟机网络配置突然变化导致的玄学和 Chrome 不支持不安全证书的 HTTPS 网站而导致的误判。</p><p>总而言之，以官方文档作为主线，配以他人博客上的成功部署经验，再加上使用翻墙代理，才能够又快又好地部署成功。此外，学会使用虚拟机的快照功能也是很重要的，方便进行重要操作前的备份。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://kubernetes.io/docs/setup/independent/install-kubeadm/" target="_blank" rel="noopener">Installing kubeadm</a> （官网）</p><p><a href="https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/" target="_blank" rel="noopener">Using kubeadm to Create a Cluster</a>（官网）</p><p><a href="https://github.com/kubernetes/dashboard/wiki/Creating-sample-user" target="_blank" rel="noopener">Dashboard: Creating sample user</a> （Dashboard 的 github）</p><p><a href="http://blog.csdn.net/zhuchuangang/article/details/76572157#2-%E9%85%8D%E7%BD%AEkubelet" target="_blank" rel="noopener">使用kubeadm安装kubernetes1.7/1.8/1.9</a></p><p><a href="https://blog.frognew.com/2017/12/kubeadm-install-kubernetes-1.9.html#1%E5%87%86%E5%A4%87" target="_blank" rel="noopener">使用kubeadm安装Kubernetes 1.9</a>（Dashboard）</p><p><a href="https://www.kubernetes.org.cn/2906.html" target="_blank" rel="noopener">使用kubeadm安装Kubernetes 1.8版本</a></p><p><a href="https://www.kubernetes.org.cn/3357.html" target="_blank" rel="noopener">使用 kubeadm 创建 kubernetes 1.9 集群</a></p><p><a href="https://www.zybuluo.com/ncepuwanghui/note/953929" target="_blank" rel="noopener">使用kubeadm在CentOS 7上安装Kubernetes 1.8</a>（Dashboard） 参考资料</p><p><a href="https://kubernetes.io/docs/setup/independent/install-kubeadm/" target="_blank" rel="noopener">Installing kubeadm</a> （来自官网）</p><p><a href="http://blog.csdn.net/zhuchuangang/article/details/76572157#2-%E9%85%8D%E7%BD%AEkubelet" target="_blank" rel="noopener">使用kubeadm安装kubernetes1.7/1.8/1.9</a></p><!--stackedit_data:eyJoaXN0b3J5IjpbNDk4MTAzMDE2LDc3Nzg2ODE4OF19--><hr><ul><li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p></li><li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p></li></ul><h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p><blockquote><p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p></blockquote><blockquote><p>体育&amp;户外用品推荐</p></blockquote><div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/se-notes/云计算实践/Kubernetes部署/kubeadm部署多节点集群/../more/ads/amazon.gif" width="100%"></a> </div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#kubeadm-%E9%83%A8%E7%BD%B2%E5%A4%9A%E8%8A%82%E7%82%B9-k8s-%E9%9B%86%E7%BE%A4%E6%95%99%E7%A8%8B191&quot;&gt;kubeadm 部
      
    
    </summary>
    
      <category term="通用技术" scheme="https://wnhby.github.io/categories/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/"/>
    
      <category term="云计算实践" scheme="https://wnhby.github.io/categories/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%AE%9E%E8%B7%B5/"/>
    
      <category term="kubernetes部署" scheme="https://wnhby.github.io/categories/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%AE%9E%E8%B7%B5/kubernetes%E9%83%A8%E7%BD%B2/"/>
    
    
      <category term="docker" scheme="https://wnhby.github.io/tags/docker/"/>
    
      <category term="云计算" scheme="https://wnhby.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="kubernetes" scheme="https://wnhby.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>LVS+Keepalived双机热备方案</title>
    <link href="https://wnhby.github.io/se-notes/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%AE%9E%E8%B7%B5/%E9%9B%86%E7%BE%A4%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88/LVS+Keepalived%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87%E6%96%B9%E6%A1%88/"/>
    <id>https://wnhby.github.io/se-notes/云计算实践/集群高可用方案/LVS+Keepalived双机热备方案/</id>
    <published>2019-01-03T13:49:30.000Z</published>
    <updated>2019-02-19T05:21:55.796Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#lvs--keepalived-%E5%8F%8C%E6%9C%BA%E9%AB%98%E5%8F%AF%E7%94%A8%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88centos">LVS + keepalived 双机高可用部署方案（CentOS）</a><ul><li><a href="#%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87">前期准备</a></li><li><a href="#web-%E8%8A%82%E7%82%B9%E9%85%8D%E7%BD%AE">web 节点配置</a></li><li><a href="#lvs-%E8%8A%82%E7%82%B9%E9%85%8D%E7%BD%AE">LVS 节点配置</a></li><li><a href="#%E6%B5%8B%E8%AF%95">测试</a></li><li><a href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3">参考文档</a></li><li><a href="#ads">Ads</a></li></ul></li></ul><!-- /TOC --><h1 id="LVS-keepalived-双机高可用部署方案（CentOS）"><a href="#LVS-keepalived-双机高可用部署方案（CentOS）" class="headerlink" title="LVS + keepalived 双机高可用部署方案（CentOS）"></a>LVS + keepalived 双机高可用部署方案（CentOS）</h1><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>准备四台虚机，分别记作 LVS-master、LVS-slave、web-node1、web-node2。前两者作为 LVS 负载均衡调度器，后两者是提供应用服务的 web 服务器。</p><p>安装<code>epel-realease</code>源，关闭所有虚机的防火墙与 SELinux，编辑所有节点的<code>/etc/hosts</code>文件设置主机名互相解析。使用<code>yum install ntpdate</code>安装 ntpdate，并通过<code>ntpdate 202.120.2.101</code>命令进行时间同步。</p><blockquote><p>202.120.2.101 是上海交通大学网络中心 NTP 服务器的地址</p></blockquote><h3 id="web-节点配置"><a href="#web-节点配置" class="headerlink" title="web 节点配置"></a>web 节点配置</h3><p>在两台 web 机上开启 httpd 服务，并编辑 Real Server （真实服务器，简称 RS）用于绑定 VIP （虚拟 IP）脚本<code>realserver.sh</code>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash  </span><br><span class="line">#   </span><br><span class="line"># Script to start LVS DR real server.   </span><br><span class="line"># description: LVS DR real server   </span><br><span class="line">#   </span><br><span class="line">.  /etc/rc.d/init.d/functions</span><br><span class="line">VIP=192.168.18.200   # 在此处设置VIP  </span><br><span class="line">host=`/bin/hostname`</span><br><span class="line">case &quot;$1&quot; in  </span><br><span class="line">start)   </span><br><span class="line">       # Start LVS-DR real server on this machine.   </span><br><span class="line">        /sbin/ifconfig lo down   </span><br><span class="line">        /sbin/ifconfig lo up   </span><br><span class="line">        echo 1 &gt; /proc/sys/net/ipv4/conf/lo/arp_ignore   </span><br><span class="line">        echo 2 &gt; /proc/sys/net/ipv4/conf/lo/arp_announce   </span><br><span class="line">        echo 1 &gt; /proc/sys/net/ipv4/conf/all/arp_ignore   </span><br><span class="line">        echo 2 &gt; /proc/sys/net/ipv4/conf/all/arp_announce</span><br><span class="line">        /sbin/ifconfig lo:0 $VIP broadcast $VIP netmask 255.255.255.255 up  </span><br><span class="line">        /sbin/route add -host $VIP dev lo:0</span><br><span class="line">;;  </span><br><span class="line">stop)</span><br><span class="line">        # Stop LVS-DR real server loopback device(s).  </span><br><span class="line">        /sbin/ifconfig lo:0 down   </span><br><span class="line">        echo 0 &gt; /proc/sys/net/ipv4/conf/lo/arp_ignore   </span><br><span class="line">        echo 0 &gt; /proc/sys/net/ipv4/conf/lo/arp_announce   </span><br><span class="line">        echo 0 &gt; /proc/sys/net/ipv4/conf/all/arp_ignore   </span><br><span class="line">        echo 0 &gt; /proc/sys/net/ipv4/conf/all/arp_announce</span><br><span class="line">;;  </span><br><span class="line">status)</span><br><span class="line">        # Status of LVS-DR real server.  </span><br><span class="line">        islothere=`/sbin/ifconfig lo:0 | grep $VIP`   </span><br><span class="line">        isrothere=`netstat -rn | grep &quot;lo:0&quot; | grep $VIP`   </span><br><span class="line">        if [ ! &quot;$islothere&quot; -o ! &quot;isrothere&quot; ];then   </span><br><span class="line">            # Either the route or the lo:0 device   </span><br><span class="line">            # not found.   </span><br><span class="line">            echo &quot;LVS-DR real server Stopped.&quot;   </span><br><span class="line">        else   </span><br><span class="line">            echo &quot;LVS-DR real server Running.&quot;   </span><br><span class="line">        fi   </span><br><span class="line">;;   </span><br><span class="line">*)   </span><br><span class="line">            # Invalid entry.   </span><br><span class="line">            echo &quot;$0: Usage: $0 &#123;start|status|stop&#125;&quot;   </span><br><span class="line">            exit 1   </span><br><span class="line">;;   </span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>使用 <code>chmod +x realserver.sh</code>命令给脚本文件添加执行权限，并通过<code>/.realserver.sh start</code>命令启动该脚本的服务。该服务的作用是使 RS 的网卡与 VIP 进行绑定，从而可允许 RS 处理来自负载调度器转发的请求（DR 模式）。启动该服务后可用<code>ifconfig</code>命令查看是否已绑定 VIP。</p><h3 id="LVS-节点配置"><a href="#LVS-节点配置" class="headerlink" title="LVS 节点配置"></a>LVS 节点配置</h3><p>LVS 节点使用<code>yum install keepalived ipvsadm</code>命令安装 keepalived 服务与 LVS 服务。</p><p>配置文件的路径是<code>/etc/keepalived/keepalived.conf</code>。keepalived 配置文件以 block 形式组织，每个块内容都包含在<code>{}</code>中。keepalived 配置分为三类：</p><ul><li>全局配置：对整个 keepalived 都生效的配置</li><li>VRRPD 配置：核心配置，主要实现高可用功能</li><li>LVS 配置：LVS 相关功能的配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">######################</span><br><span class="line">#  全局配置（大部分选项为邮件通知服务的参数。可设置为空）</span><br><span class="line">######################</span><br><span class="line">global_defs &#123;                               # global_defs 全局配置标识 </span><br><span class="line">                                            --------------------------------------</span><br><span class="line">   notification_email &#123;                     # notification_email用于设置报警邮件地址</span><br><span class="line">     acassen@firewall.loc                   # 可以设置多个，每行一个</span><br><span class="line">     failover@firewall.loc                  # 设置邮件报警，需开启本机Sendmail 服务</span><br><span class="line">     sysadmin@firewall.loc                  # yum -y install mailx sendmail</span><br><span class="line">   &#125;                                        --------------------------------------</span><br><span class="line">   </span><br><span class="line">   notification_email_from 233@qq.com  # 设置邮件发送地址</span><br><span class="line">   smtp_server 192.168.200.1           # 设置邮件的smtp server地址</span><br><span class="line">   smtp_connect_timeout 30             # 设置连接smtp sever超时时间</span><br><span class="line">   router_id LVS_DEVEL                 # 表示运行keepalived服务器标识</span><br><span class="line">   # 发邮件时会显示在邮件主题中</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">######################</span><br><span class="line">#  VRRPD配置</span><br><span class="line">######################</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;         # VRRPD 配置标识 VI_1是实例名称</span><br><span class="line"></span><br><span class="line">    state MASTER             # 指定Keepalvied角色。</span><br><span class="line">                             # MASTER表示此主机为主服务器，BACKUP则是表示为备用服务器</span><br><span class="line">    interface eth0           # 指定HA监测网络的接口。检查是否与ifconfig命令查看的网卡名称一致。</span><br><span class="line">    virtual_router_id 51     # 虚拟路由标识，标识为数字，同一个VRRP实例使用唯一的标识</span><br><span class="line">                             # 即可表示在同一个vrrp_instance下 MASTER_ID = BACKUP_ID</span><br><span class="line">    priority 100             # 定义节点优先级，数字越大表示节点的优先级越高</span><br><span class="line">                             # 同一个VRRP_instance下</span><br><span class="line">                             # 必须 MASTE_PRIORITY &gt; BACKUP_PRIORITY </span><br><span class="line">    advert_int 1             # 设定MASTER与BACKUP主机质检同步检查的时间间隔，单位为秒</span><br><span class="line">             </span><br><span class="line">    authentication &#123;         # 设定节点间通信验证类型和密码，验证类型主要有PASS和AH两种</span><br><span class="line">        auth_type PASS       # 同一个vrrp_instance，MASTER验证密码和BACKUP保持一致</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    virtual_ipaddress &#123;      # 设置虚拟IP地址 (VIP)，也可仅设置一个</span><br><span class="line">        192.168.200.16</span><br><span class="line">        192.168.200.17</span><br><span class="line">        192.168.200.18</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">######################</span><br><span class="line"># LVS配置</span><br><span class="line">######################</span><br><span class="line"></span><br><span class="line">virtual_server 192.168.18.200 80 &#123;    # virtual_server LVS配置标识 </span><br><span class="line">                                      # 格式：virtual_server [VIP] [port]</span><br><span class="line">    delay_loop 6     # 设置健康检查时间间隔，单位为秒   </span><br><span class="line">    lb_algo rr       # 设置负载调度算法，可用的调度算法有：rr、wlc、lc、lblc、sh、dh等</span><br><span class="line">    lb_kind DR       # 设置LVS实现负载均衡的机制，有NAT、TUN和DR三种模式可选                   </span><br><span class="line">    nat_mask 255.255.255.0   # NAT子网掩码</span><br><span class="line">    persistence_timeout 50  # 会话保持时间 </span><br><span class="line">    protocol TCP             # 指定转发协议类型</span><br><span class="line">    </span><br><span class="line">#---------------------------------------------------------------------------------</span><br><span class="line"># persistence_timeout 会话保持时间对动态网页非常有用，为集群系统中的seesion共享提供了一个很好的解决方案</span><br><span class="line"># 用户的请求会一直分发到某个服务节点，直至超过这个会话的保持时间（指最大无响应超时时间）</span><br><span class="line"># =[用户操作动态页面如果在50s没有执行任何操作则被分发到另外的节点]</span><br><span class="line">#---------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">    real_server 192.168.18.201 80 &#123; # 设置real server段开始的标识 [IP为真实IP地址]</span><br><span class="line">        weight 1                    # 用于配置real server节点的权值，数字越大，权值越高</span><br><span class="line">                                    # 设置权值大小可以为不同性能的服务器分配不同的负载</span><br><span class="line">        HTTP_GET &#123;   </span><br><span class="line">            url &#123;   </span><br><span class="line">              path /   </span><br><span class="line">          status_code 200   </span><br><span class="line">            &#125;   </span><br><span class="line">            connect_timeout 2   </span><br><span class="line">            nb_get_retry 3   </span><br><span class="line">            delay_before_retry 1   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">    real_server 192.168.18.202 80 &#123;   </span><br><span class="line">        weight 1   </span><br><span class="line">        HTTP_GET &#123;   </span><br><span class="line">            url &#123;   </span><br><span class="line">              path /   </span><br><span class="line">              status_code 200   </span><br><span class="line">            &#125;   </span><br><span class="line">            connect_timeout 2   </span><br><span class="line">            nb_get_retry 3   </span><br><span class="line">            delay_before_retry 1   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>keepalived 的配置文件路径在<code>/etc/keepalived/keepalived.conf</code>。LVS-master 与 LVS-slave 的配置文件除了 VRRPD 配置中的状态与优先级这两个参数不同外，其他参数应当相同。</p><p>配置完成后，启动 LVS-master 与 LVS-slave的 keepalived 服务：<code>service keepalived start</code>，并可使用<code>ipvsadm -L -n</code>命令查看 LVS 状态。</p><blockquote><p>Tips：可使用<code>service keepalived status</code>命令查看 keepalived 服务的 log。</p></blockquote><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>通过关闭与开启 LVS-master 的 keepalived 服务，观察 VIP 在 LVS 节点上的浮动情况。通过关闭与开启某一个 web 节点的 web 服务，观察集群的高可用是否生效。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p>实验步骤参考：<a href="http://freeloda.blog.51cto.com/2033581/1280962" target="_blank" rel="noopener">Linux 高可用集群之keepalived详解</a><br>详细配置参数参考：<a href="https://my.oschina.net/luciamoore/blog/607034" target="_blank" rel="noopener">Keepalived 工作原理及简要安装</a></p><hr><ul><li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p></li><li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p></li></ul><h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p><blockquote><p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p></blockquote><blockquote><p>体育&amp;户外用品推荐</p></blockquote><div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/se-notes/云计算实践/集群高可用方案/LVS+Keepalived双机热备方案/../more/ads/amazon.gif" width="100%"></a> </div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#lvs--keepalived-%E5%8F%8C%E6%9C%BA%E9%AB%98%E5%8F%AF%E7%94%A8%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88centos&quot;&gt;LVS
      
    
    </summary>
    
      <category term="通用技术" scheme="https://wnhby.github.io/categories/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/"/>
    
      <category term="云计算实践" scheme="https://wnhby.github.io/categories/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%AE%9E%E8%B7%B5/"/>
    
      <category term="集群高可用方案" scheme="https://wnhby.github.io/categories/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%AE%9E%E8%B7%B5/%E9%9B%86%E7%BE%A4%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="云计算" scheme="https://wnhby.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="集群" scheme="https://wnhby.github.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>Flask-Web工程手册-README</title>
    <link href="https://wnhby.github.io/se-notes/Flask-Web%E5%B7%A5%E7%A8%8B%E6%89%8B%E5%86%8C/README/"/>
    <id>https://wnhby.github.io/se-notes/Flask-Web工程手册/README/</id>
    <published>2019-01-03T13:49:30.000Z</published>
    <updated>2019-02-19T05:18:13.457Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#flask-web%E5%B7%A5%E7%A8%8B%E6%89%8B%E5%86%8C-readme">Flask-Web工程手册-README</a><ul><li><a href="#ads">Ads</a></li></ul></li></ul><!-- /TOC --><h1 id="Flask-Web工程手册-README"><a href="#Flask-Web工程手册-README" class="headerlink" title="Flask-Web工程手册-README"></a>Flask-Web工程手册-README</h1><ul><li>ch1-创建Python虚拟环境</li><li>ch2-Flask项目基本部署</li><li>ch3-Flask常用扩展插件</li><li>ch4-Linux服务器部署</li><li>ch5-使用lsyncd进行文件实时备份</li><li>ch6-配置集群共享文件NFS服务器</li><li>ch7-Nginx安装与重写URL-CentOS7</li><li>ch8-高可用与负载均衡集群部署-Ubuntu</li><li>…</li></ul><hr><ul><li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p></li><li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p></li></ul><h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p><blockquote><p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p></blockquote><blockquote><p>体育&amp;户外用品推荐</p></blockquote><div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/se-notes/Flask-Web工程手册/README/../more/ads/amazon.gif" width="100%"></a> </div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#flask-web%E5%B7%A5%E7%A8%8B%E6%89%8B%E5%86%8C-readme&quot;&gt;Flask-Web工程手册-README&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#ads&quot;&gt;Ads&lt;/a
      
    
    </summary>
    
      <category term="框架" scheme="https://wnhby.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="python-web应用框架" scheme="https://wnhby.github.io/categories/%E6%A1%86%E6%9E%B6/python-web%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="web开发" scheme="https://wnhby.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="flask" scheme="https://wnhby.github.io/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>ch2-Flask项目基本部署</title>
    <link href="https://wnhby.github.io/se-notes/Flask-Web%E5%B7%A5%E7%A8%8B%E6%89%8B%E5%86%8C/ch2-Flask%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E9%83%A8%E7%BD%B2/"/>
    <id>https://wnhby.github.io/se-notes/Flask-Web工程手册/ch2-Flask项目基本部署/</id>
    <published>2019-01-03T13:49:30.000Z</published>
    <updated>2019-02-19T05:17:07.846Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#flask-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E9%83%A8%E7%BD%B2">Flask 项目基本部署</a><ul><li><a href="#%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85">环境安装</a></li><li><a href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84">目录结构</a></li><li><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3">配置文件详解</a><ul><li><a href="#configpy">config.py</a></li><li><a href="#appinitpy">app/init.py</a></li><li><a href="#managepy">manage.py</a></li><li><a href="#ads">Ads</a></li></ul></li></ul></li></ul><!-- /TOC --><h1 id="Flask-项目基本部署"><a href="#Flask-项目基本部署" class="headerlink" title="Flask 项目基本部署"></a>Flask 项目基本部署</h1><p>Flask 项目没有固定的目录配置，因此在此介绍一个对 Flask 进行基本部署的教程。</p><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><p>首先使用 virtualenv 构建好虚拟的 python 依赖环境，并安装必要的 Flask 依赖包，比如：</p><ul><li>flask：Flask 框架的基础库</li><li>mysql-python：处理与数据库的底层交互</li><li>SQLAlchemy：一个 ORM 框架，用于处理数据库与对象之间的映射</li><li>Flask-SQLAlchemy：简化在 Flask 中 SQLAlchemy 的 使用</li><li>Flask-Script：为 Flask 程序提供了命令行模式</li><li>Flask-Migrate：数据库迁移工具</li><li>Flask-Login：封装用户会话管理</li></ul><p>其他功能性的扩展插件可选择安装，比如：</p><ul><li>flask-mail：用于管理邮件自动发送</li><li>Flask-babel：实现语言互相转换的翻译工具</li><li>Werkzeug： 计算密码散列值并进行核对</li><li>Flask-WTF： Web 表单</li></ul><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>初始目录结构如下图所示：</p><p><img src="https://cloud.githubusercontent.com/assets/22606175/23286448/9f0c3b46-fa72-11e6-87d7-b90f25452eec.jpg" alt="初始目录配置图"></p><ul><li>Flask 程序一般都保存在名为 app 的文件夹中</li><li>migrations 文件夹包含数据库迁移脚本</li><li>venv 文件夹包含 Python 虚拟环境</li><li>requirements.txt 列出了所有依赖包，便于项目迁移时重新生成相同的虚拟环境；</li><li>config.py 存储配置参数，如数据库账户密码等</li><li>manage.py 用于通过命令行启动程序的脚本</li></ul><h2 id="配置文件详解"><a href="#配置文件详解" class="headerlink" title="配置文件详解"></a>配置文件详解</h2><h3 id="config-py"><a href="#config-py" class="headerlink" title="config.py"></a>config.py</h3><p>config.py 是初始化 Flask app 的配置文件，主要包括多种模式下的配置类型和全局参数（如密钥、连接数据库的 URL） 等。此外需注意的是，敏感数据不能直接写入，应从操作系统的环境变量中读取。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">basedir = os.path.abspath(os.path.dirname(__file__))</span><br><span class="line"></span><br><span class="line">class Config:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line">    @staticmethod</span><br><span class="line">    def init_app(app):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">class DevelopmentConfig(Config):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line">    DEBUG = True</span><br><span class="line">    SQLALCHEMY_DATABASE_URI = (os.environ.get(&apos;DEV_DATABASE_URL&apos;) or</span><br><span class="line">                               &apos;mysql://root:123456@localhost/lancs&apos;)</span><br><span class="line"></span><br><span class="line">class ProductionConfig(Config):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line">    SQLALCHEMY_DATABASE_URI = (os.environ.get(&apos;DEV_DATABASE_URL&apos;) or</span><br><span class="line">                               &apos;mysql://root:123456@localhost/lancs&apos;)</span><br><span class="line"></span><br><span class="line">config = &#123;</span><br><span class="line">    &apos;development&apos;: DevelopmentConfig,</span><br><span class="line">    &apos;production&apos;: ProductionConfig,</span><br><span class="line">    &apos;default&apos;: DevelopmentConfig</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="app-init-py"><a href="#app-init-py" class="headerlink" title="app/init.py"></a>app/init.py</h3><p>app/init.py 是程序包的构造文件，主要包括创建 flask app 的工厂函数。配置 Flask 扩展插件时往往在工厂函数中对 app 进行相关的初始化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">from flask_sqlalchemy import SQLAlchemy</span><br><span class="line">from config import config</span><br><span class="line"></span><br><span class="line">db = SQLAlchemy()</span><br><span class="line"></span><br><span class="line">def create_app(config_name):</span><br><span class="line">    app = Flask(__name__)</span><br><span class="line">    app.config.from_object(config[config_name])</span><br><span class="line">    config[config_name].init_app(app)</span><br><span class="line"></span><br><span class="line">    db.init_app(app)</span><br><span class="line"></span><br><span class="line">    # Register all the filter.</span><br><span class="line">    from .main import main as main_blueprint</span><br><span class="line">    app.register_blueprint(main_blueprint)</span><br><span class="line"></span><br><span class="line">    return app</span><br></pre></td></tr></table></figure></p><h3 id="manage-py"><a href="#manage-py" class="headerlink" title="manage.py"></a>manage.py</h3><p>manage.py 是使用命令行启动服务进程、数据库迁移的脚本文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">from Lancs import create_app, db</span><br><span class="line">from flask_script import Manager</span><br><span class="line">from flask_migrate import Migrate, MigrateCommand</span><br><span class="line"></span><br><span class="line">app = create_app(os.getenv(&apos;LANCS_CONFIG&apos;) or &apos;default&apos;)</span><br><span class="line">manager = Manager(app)</span><br><span class="line">migrate = Migrate(app, db)</span><br><span class="line"></span><br><span class="line">manager.add_command(&apos;db&apos;, MigrateCommand)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    manager.run()</span><br></pre></td></tr></table></figure></p><hr><ul><li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p></li><li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p></li></ul><h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p><blockquote><p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p></blockquote><blockquote><p>体育&amp;户外用品推荐</p></blockquote><div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/se-notes/Flask-Web工程手册/ch2-Flask项目基本部署/../more/ads/amazon.gif" width="100%"></a> </div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#flask-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E9%83%A8%E7%BD%B2&quot;&gt;Flask 项目基本部署&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%8E%AF%E
      
    
    </summary>
    
      <category term="框架" scheme="https://wnhby.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="python-web应用框架" scheme="https://wnhby.github.io/categories/%E6%A1%86%E6%9E%B6/python-web%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="web开发" scheme="https://wnhby.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="flask" scheme="https://wnhby.github.io/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>ch1-创建Python虚拟环境</title>
    <link href="https://wnhby.github.io/se-notes/Flask-Web%E5%B7%A5%E7%A8%8B%E6%89%8B%E5%86%8C/ch1-%E5%88%9B%E5%BB%BAPython%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
    <id>https://wnhby.github.io/se-notes/Flask-Web工程手册/ch1-创建Python虚拟环境/</id>
    <published>2019-01-03T13:49:30.000Z</published>
    <updated>2019-02-19T05:16:53.119Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%BD%BF%E7%94%A8-virtualenv-%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83">使用 virtualenv 虚拟环境</a><ul><li><a href="#%E9%9C%80%E6%B1%82%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8">需求文件的创建及使用</a><ul><li><a href="#ads">Ads</a></li></ul></li></ul></li></ul><!-- /TOC --><h1 id="使用-virtualenv-虚拟环境"><a href="#使用-virtualenv-虚拟环境" class="headerlink" title="使用 virtualenv 虚拟环境"></a>使用 virtualenv 虚拟环境</h1><p>virtualenv 是 Python 的虚拟环境，可以在同一台 PC 上隔离不同的开发环境。主要用于为不同的项目构建独立与隔离的三方库依赖。</p><ol><li>在系统中安装 virtualenv：<code>pip install virtualenv</code></li><li>在项目目录中建立 virtualenv 虚拟环境：<code>virtualenv [环境名]</code> </li><li>启动虚拟环境：<ul><li><code>env_dir\Scripts\activate</code>(Windows)</li><li><code># source env_dir/bin/activate</code>(Linux)</li></ul></li><li>退出虚拟环境： <code>deactivate</code></li></ol><blockquote><p>Note：python3 中有内置的虚拟环境，使用<code>python -m venv [环境名]</code>命令即可创建</p></blockquote><h2 id="需求文件的创建及使用"><a href="#需求文件的创建及使用" class="headerlink" title="需求文件的创建及使用"></a>需求文件的创建及使用</h2><p>Python项目中往往必须包含一个 requirements.txt 文件，用于记录所有依赖包及其精确的版本号，以便在新环境中部署。</p><p>在虚拟环境中使用 pip 生成需求文件：</p><blockquote><p><code>(venv) $ pip freeze &gt; requirements.txt</code></p></blockquote><p>安装或升级包后，最好更新该文件。</p><p>按照需求文件上的所列项，安装依赖包：</p><blockquote><p><code>(venv) $ pip install -r requirements.txt</code></p></blockquote><hr><ul><li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p></li><li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p></li></ul><h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p><blockquote><p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p></blockquote><blockquote><p>体育&amp;户外用品推荐</p></blockquote><div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/se-notes/Flask-Web工程手册/ch1-创建Python虚拟环境/../more/ads/amazon.gif" width="100%"></a> </div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BD%BF%E7%94%A8-virtualenv-%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83&quot;&gt;使用 virtualenv 虚拟环境&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="框架" scheme="https://wnhby.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="python-web应用框架" scheme="https://wnhby.github.io/categories/%E6%A1%86%E6%9E%B6/python-web%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="web开发" scheme="https://wnhby.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="flask" scheme="https://wnhby.github.io/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>ch3-Flask常用扩展插件</title>
    <link href="https://wnhby.github.io/se-notes/Flask-Web%E5%B7%A5%E7%A8%8B%E6%89%8B%E5%86%8C/ch3-Flask%E5%B8%B8%E7%94%A8%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/"/>
    <id>https://wnhby.github.io/se-notes/Flask-Web工程手册/ch3-Flask常用扩展插件/</id>
    <published>2019-01-03T13:49:30.000Z</published>
    <updated>2019-02-19T05:17:29.059Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#flask-常用扩展插件">Flask 常用扩展插件</a><ul><li><a href="#flask-sqlalchemy">Flask-SQLAlchemy</a><ul><li><a href="#初始化应用">初始化应用</a></li><li><a href="#模型声明">模型声明</a></li></ul></li><li><a href="#flask-script-与-flask-migrate">Flask-Script 与 Flask-Migrate</a></li><li><a href="#mysql-python">MySQL-python</a><ul><li><a href="#参考文章">参考文章</a></li></ul></li><li><a href="#flask-login">Flask-Login</a><ul><li><a href="#初始化应用-1">初始化应用</a></li><li><a href="#相关配置">相关配置</a></li><li><a href="#使用方法">使用方法</a></li></ul></li><li><a href="#flask_babel">Flask_Babel</a><ul><li><a href="#初始化应用-2">初始化应用</a></li><li><a href="#配置参数">配置参数</a></li><li><a href="#生成翻译模板">生成翻译模板</a></li><li><a href="#创建翻译文本">创建翻译文本</a></li><li><a href="#编译">编译</a></li><li><a href="#修改翻译">修改翻译</a></li></ul></li><li><a href="#flask-mail">Flask-Mail</a><ul><li><a href="#初始化应用-3">初始化应用</a></li><li><a href="#参数配置">参数配置</a></li><li><a href="#发送邮件">发送邮件</a></li></ul></li><li><a href="#自定义模板过滤器">自定义模板过滤器</a></li></ul></li></ul><!-- /TOC --><h1 id="Flask-常用扩展插件"><a href="#Flask-常用扩展插件" class="headerlink" title="Flask 常用扩展插件"></a>Flask 常用扩展插件</h1><p>仅仅靠 Flask 基础库的功能是不够的，Flask 拥有多种扩展插件来实现各种模块化的功能。以下按照常用的配置目录，来介绍 Flask 中较为常见的功能插件。</p><h2 id="Flask-SQLAlchemy"><a href="#Flask-SQLAlchemy" class="headerlink" title="Flask-SQLAlchemy"></a>Flask-SQLAlchemy</h2><p>一个从模型到数据库的映射框架，在 Flask 中提供了模型以及数据库操作。</p><h3 id="初始化应用"><a href="#初始化应用" class="headerlink" title="初始化应用"></a>初始化应用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># app/init.py</span><br><span class="line">from flask import Flask</span><br><span class="line">from flask_sqlalchemy import SQLAlchemy</span><br><span class="line">from config import config</span><br><span class="line"></span><br><span class="line"># 由于是全局的实例，此后其他模块引入需SQLAlchemy时只需引入db即可</span><br><span class="line">db = SQLAlchemy() </span><br><span class="line"></span><br><span class="line">def create_app(config_name):</span><br><span class="line">    app = Flask(__name__)</span><br><span class="line">    app.config.from_object(config[config_name])</span><br><span class="line">    config[config_name].init_app(app)</span><br><span class="line"></span><br><span class="line">    db.init_app(app)</span><br></pre></td></tr></table></figure><h3 id="模型声明"><a href="#模型声明" class="headerlink" title="模型声明"></a>模型声明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># app/models.py</span><br><span class="line">from . import db</span><br><span class="line"></span><br><span class="line">class User(db.Model):</span><br><span class="line">    __tablename__ = &apos;users&apos;   # 将创建的数据库的实际表名</span><br><span class="line">    id = db.Column(db.Integer, primary_key=True)</span><br><span class="line">    username = db.Column(db.String(80), unique=True)</span><br><span class="line">    email = db.Column(db.String(120), unique=True)</span><br><span class="line"></span><br><span class="line">    def __init__(self, username, email):</span><br><span class="line">        self.username = username</span><br><span class="line">        self.email = email</span><br></pre></td></tr></table></figure><p>详细的模型关系说明请看 <a href="https://github.com/xuelangZF/ehpc/wiki/Flask-sqlalchemy-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E6%96%87%E6%A1%A3" target="_blank" rel="noopener">Flask sqlalchemy 数据库操作文档</a> 。</p><h2 id="Flask-Script-与-Flask-Migrate"><a href="#Flask-Script-与-Flask-Migrate" class="headerlink" title="Flask-Script 与 Flask-Migrate"></a>Flask-Script 与 Flask-Migrate</h2><p>Flask-Script 为 Flask 提供了可通过外部脚本使用命令行运行程序的功能，如启动服务、数据库迁移、在环境上下文中启动 shell 等。而 Flask-Migrate 用于进行数据库迁移。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># manage.py</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">from app import app</span><br><span class="line">from flask_script import Manager</span><br><span class="line">from flask_migrate import Migrate, MigrateCommand</span><br><span class="line"></span><br><span class="line">manager = Manager(app)</span><br><span class="line">migrate = Migrate(app, db)</span><br><span class="line"></span><br><span class="line">manager.add_command(&apos;db&apos;, MigrateCommand)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    manager.run()</span><br></pre></td></tr></table></figure></p><p>数据库迁移的命令主要包括：</p><ul><li>初始化迁移库：<code># python manage.py db init</code></li><li>创建迁移脚本：<code># python manage.py db migrate</code></li><li>更新数据库：<code># python manage.py db upgrade</code></li></ul><h2 id="MySQL-python"><a href="#MySQL-python" class="headerlink" title="MySQL-python"></a>MySQL-python</h2><p>MySQL-python 是 python 环境与 mysql 数据库的底层交互接口。作为一个必需库，在安装时经常会遇到安装失败的情况。因此一般是在 windows 开发环境下使用 exe 进行安装后再把库文件复制到已部署项目的虚拟环境中。</p><p>在 centos 系统中使用 pip 安装 MySQL-python 时遇到的一些问题的解决方法：</p><ol><li>执行<code>pip install mysql-python</code>时，报错 <code>EnvironmentError: mysql_config not found</code> ，解决方法为：<code>yum install mysql-devel</code></li><li>再次执行<code>pip install mysql-python</code>安装时，仍然报错<code>error: command &#39;gcc&#39; failed with exit status 1</code>， 解决方法：<code>yum install gcc python-devel</code></li></ol><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="http://www.cnblogs.com/yangxia-test/p/4691947.html" target="_blank" rel="noopener">centos下pip安装mysql_python</a></p><h2 id="Flask-Login"><a href="#Flask-Login" class="headerlink" title="Flask-Login"></a>Flask-Login</h2><p>Flask-Login 为 Flask 提供了会话管理。它处理日常的登入、登出并长期保留用户会话。</p><h3 id="初始化应用-1"><a href="#初始化应用-1" class="headerlink" title="初始化应用"></a>初始化应用</h3><p>Flask-Login 最重要的部分就是登录管理器类 LoginManager ，实例化后对应用进行初始化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># app/init.py</span><br><span class="line"></span><br><span class="line">from flask_login import LoginManager</span><br><span class="line"></span><br><span class="line">login_manager = LoginManager()</span><br><span class="line">login_manager.init_app(app)</span><br><span class="line"></span><br><span class="line">#设置会话保护强度：None、&quot;basic&quot; 或 &quot;strong&quot;</span><br><span class="line">login_manager.session_protection = &apos;strong&apos;</span><br><span class="line">#设置登录视图</span><br><span class="line">login_manager.login_view = &apos;user.signin&apos;</span><br></pre></td></tr></table></figure></p><h3 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h3><p>需要设置一个 user_loader 回调函数，这个函数用于从会话中存储的用户 ID 重新加载用户对象（注意：如果 ID 无效，它应该返回 None，而不是抛出异常），如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@login_manager.user_loader</span><br><span class="line">def load_user(userid):</span><br><span class="line">    return User.get(userid)</span><br></pre></td></tr></table></figure></p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>当用户通过验证后，用 login_user 函数来登入他们：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@app.route(&quot;/login&quot;, methods=[&quot;GET&quot;, &quot;POST&quot;])</span><br><span class="line">def login():</span><br><span class="line">    form = LoginForm()</span><br><span class="line">    if form.validate_on_submit():</span><br><span class="line">        # login and validate the user...</span><br><span class="line">        login_user(user)</span><br><span class="line">        flash(&quot;Logged in successfully.&quot;)</span><br><span class="line">        return redirect(request.args.get(&quot;next&quot;) or url_for(&quot;index&quot;))</span><br><span class="line">    return render_template(&quot;login.html&quot;, form=form)</span><br></pre></td></tr></table></figure></p><p>可以通过 current_user 代理访问当前会话中已登录的用户。但当用户未登录时，current_user 被设置为一个 AnonymousUser 对象，它包含下列属性： </p><ul><li>is_active 和 is_authenticated 返回 False </li><li>is_active 返回 True </li><li>get_id 返回 None。</li></ul><p>需要用户登入的视图可以用 login_required 装饰器来装饰，被 login_required 装饰器拦截的请求会跳转到登录视图。当重定向到登入视图，请求字符串中往往会额外设置一个 next 变量，值为用户之前试图访问的页面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@app.route(&quot;/settings&quot;)</span><br><span class="line">@login_required</span><br><span class="line">def settings():</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></p><p>当用户要登出时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@app.route(&quot;/logout&quot;)</span><br><span class="line">@login_required</span><br><span class="line">def logout():</span><br><span class="line">    logout_user()</span><br><span class="line">    return redirect(somewhere)</span><br></pre></td></tr></table></figure></p><h2 id="Flask-Babel"><a href="#Flask-Babel" class="headerlink" title="Flask_Babel"></a>Flask_Babel</h2><p>Flask_Babel 是 Flask 的翻译扩展工具，可配置指定文字的翻译文本。</p><h3 id="初始化应用-2"><a href="#初始化应用-2" class="headerlink" title="初始化应用"></a>初始化应用</h3><p>使用命令<code>$ pip install Flask-Babel</code>进行安装。</p><p>在完成 app 的基本配置初始化后，使用 Babel 对 app 进行初始化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">from config import config</span><br><span class="line">from flask_babel import Babel</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config.from_object(config[config_name])</span><br><span class="line">babel = Babel(app)</span><br></pre></td></tr></table></figure></p><h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><p>首先在 app 的 config 中设置 Babel 的配置参数，分别代表翻译文本的默认语言以及其默认时区。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BABEL_DEFAULT_LOCALE = &apos;zh&apos;</span><br><span class="line">BABEL_DEFAULT_TIMEZONE = &apos;CST&apos;</span><br></pre></td></tr></table></figure></p><p>在 app 目录下创建配置文件 babel.cfg，用于设置 babel 要从哪些位置搜索需翻译的字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[python: **.py]</span><br><span class="line">[jinja2: **/templates/**.html]</span><br><span class="line">extensions=jinja2.ext.autoescape,jinja2.ext.with_</span><br></pre></td></tr></table></figure></p><h3 id="生成翻译模板"><a href="#生成翻译模板" class="headerlink" title="生成翻译模板"></a>生成翻译模板</h3><p>使用<code># pybabel extract -F babel.cfg -o messages.pot .</code>命令生成翻译模板<code>messages.pot</code>。该模板自动查找 babel.cfg 中所配置的区域中需要翻译的字符串。</p><h3 id="创建翻译文本"><a href="#创建翻译文本" class="headerlink" title="创建翻译文本"></a>创建翻译文本</h3><p>使用<code># pybabel init -i messages.pot -d translations -l zh</code>创建中文翻译。这句命令会在 app 主目录中生成一个 translations 目录。要确保 flask 能找到翻译内容，translations 目录要和 templates 目录在同一个目录中。接下来我们就可以进行翻译了，修改 <code>translations/zh_Hans_CN/LC_MESSAGES/messages.po</code>文件添加翻译文本。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>翻译完后执行命令<code># pybabel compile -d translations</code>进行编译，编译结果为 message.mo 文件。编译成功后，即可在应用的网页上看到翻译后的文本。</p><h3 id="修改翻译"><a href="#修改翻译" class="headerlink" title="修改翻译"></a>修改翻译</h3><p>有时我们需要对程序和模板做修改，翻译也要随之更新。更新后需要用前面的命令重新生成 messages.pot 文件，然后使用命令<code># pybabel update -i messages.pot -d translations</code>将更新的内容 merge 到原来的翻译中，最后再到对应 locale 的文件夹下更新翻译并 compile 即可。</p><p>若只是修改翻译文本而未更改程序和模板，则只需修改 messages.po 文件里的文本后重新编译即可。</p><h2 id="Flask-Mail"><a href="#Flask-Mail" class="headerlink" title="Flask-Mail"></a>Flask-Mail</h2><p>Flask-Mail 用于自动发送邮件。</p><h3 id="初始化应用-3"><a href="#初始化应用-3" class="headerlink" title="初始化应用"></a>初始化应用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># app/init.py</span><br><span class="line">from flask_mail import Mail</span><br><span class="line"></span><br><span class="line">mail = Mail()</span><br><span class="line">mail.init_app(app)</span><br></pre></td></tr></table></figure><h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h3><p>可参考 <a href="http://www.pythondoc.com/flask-mail/index.html" target="_blank" rel="noopener">Flask-Mail 文档</a> 进行如下内置参数配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># config.py</span><br><span class="line"></span><br><span class="line"># If use QQ email, please see http://service.mail.qq.com/cgi-bin/help?id=28 firstly.</span><br><span class="line">MAIL_SERVER = &apos;smtp.sina.com&apos;</span><br><span class="line">MAIL_PORT = 465</span><br><span class="line">MAIL_USE_SSL = True</span><br><span class="line">MAIL_USERNAME = os.environ.get(&apos;MAIL_USERNAME&apos;) or &apos;milanlanlanlan@sina.com&apos;</span><br><span class="line">MAIL_PASSWORD = os.environ.get(&apos;MAIL_PASSWORD&apos;) or &apos;1970025901a&apos;</span><br></pre></td></tr></table></figure></p><p>除了设置参数以外，还应当确保邮件服务器可提供服务。</p><h3 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h3><p>为了能够发送邮件，首先需要创建一个 Message 实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from flask_mail import Message</span><br><span class="line">@app.route(&quot;/&quot;)</span><br><span class="line">def index():</span><br><span class="line">    msg = Message(&quot;Hello&quot;,     # 此处构造函数的首个参数的值&quot;Hello&quot;是邮件标题</span><br><span class="line">                  sender=&quot;from@example.com&quot;,</span><br><span class="line">                  recipients=[&quot;to@example.com&quot;])</span><br></pre></td></tr></table></figure><p>可设置一个或者多个收件人:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msg.recipients = [&quot;you@example.com&quot;]</span><br><span class="line">msg.add_recipient(&quot;somebodyelse@example.com&quot;)</span><br></pre></td></tr></table></figure></p><p>若设置了 MAIL_DEFAULT_SENDER，就不必再次填写发件人，默认情况下将会使用配置项的发件人。</p><p>邮件内容可以直接包含 body 或者包含 HTML:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msg.body = &quot;testing&quot;</span><br><span class="line">msg.html = &quot;&lt;b&gt;testing&lt;/b&gt;&quot;</span><br></pre></td></tr></table></figure></p><p>最后，发送邮件的时候请使用 Flask 应用设置的 Mail 实例:<code>mail.send(msg)</code></p><h2 id="自定义模板过滤器"><a href="#自定义模板过滤器" class="headerlink" title="自定义模板过滤器"></a>自定义模板过滤器</h2><p>为了使视图层和控制层解耦，往往使用自定义的模板过滤器，而不是在控制层中增加逻辑。</p><p><code>`</code> </p><h1 id="app-util-init-py"><a href="#app-util-init-py" class="headerlink" title="app/util/init.py"></a>app/util/init.py</h1><p>from flask import Blueprint<br>filter_blueprint = Blueprint(‘filters’, <strong>name</strong>)</p><h1 id="Register-all-the-filter"><a href="#Register-all-the-filter" class="headerlink" title="Register all the filter."></a>Register all the filter.</h1><h1 id="往往不是把所有过滤器写入同一个文件中，而是分多个文件，然后在本文件中用-import-引用。"><a href="#往往不是把所有过滤器写入同一个文件中，而是分多个文件，然后在本文件中用-import-引用。" class="headerlink" title="往往不是把所有过滤器写入同一个文件中，而是分多个文件，然后在本文件中用 import 引用。"></a>往往不是把所有过滤器写入同一个文件中，而是分多个文件，然后在本文件中用 import 引用。</h1><p>@filter_blueprint.app_template_filter(‘reversel’)<br>def reverse_filter(s):<br>    return s[::-1]</p><hr><ul><li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p></li><li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p></li></ul><h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p><blockquote><p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p></blockquote><blockquote><p>体育&amp;户外用品推荐</p></blockquote><div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/se-notes/Flask-Web工程手册/ch3-Flask常用扩展插件/../more/ads/amazon.gif" width="100%"></a> </div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#flask-常用扩展插件&quot;&gt;Flask 常用扩展插件&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#flask-sqlalchemy&quot;&gt;Flask-SQLAlchemy&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#初始
      
    
    </summary>
    
      <category term="框架" scheme="https://wnhby.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="python-web应用框架" scheme="https://wnhby.github.io/categories/%E6%A1%86%E6%9E%B6/python-web%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="web开发" scheme="https://wnhby.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="flask" scheme="https://wnhby.github.io/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>ch4-Linux服务器部署</title>
    <link href="https://wnhby.github.io/se-notes/Flask-Web%E5%B7%A5%E7%A8%8B%E6%89%8B%E5%86%8C/ch4-Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/"/>
    <id>https://wnhby.github.io/se-notes/Flask-Web工程手册/ch4-Linux服务器部署/</id>
    <published>2019-01-03T13:49:30.000Z</published>
    <updated>2019-02-19T05:17:36.806Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#linux服务器部署">Linux服务器部署</a><ul><li><a href="#初始化服务器">初始化服务器</a></li><li><a href="#安装mysql">安装MySQL</a><ul><li><a href="#导出数据库sql脚本">导出数据库（sql脚本）</a></li><li><a href="#导入数据库sql脚本">导入数据库（sql脚本）</a></li><li><a href="#参考文章">参考文章</a></li><li><a href="#在-centos-上安装-mysql-python">在 CentOS 上安装 mysql-python</a></li></ul></li><li><a href="#设置远程访问-mysql">设置远程访问 MySQL</a></li><li><a href="#安装-virtualenv">安装 virtualenv</a><ul><li><a href="#参考文章-1">参考文章</a></li></ul></li><li><a href="#开放端口">开放端口</a></li><li><a href="#使用-supervisor-维护服务进程">使用 supervisor 维护服务进程</a></li><li><a href="#使用-gunicorn-作为-web-服务器">使用 gunicorn 作为 Web 服务器</a><ul><li><a href="#gevent">gevent</a></li><li><a href="#ads">Ads</a></li></ul></li></ul></li></ul><!-- /TOC --><h1 id="Linux服务器部署"><a href="#Linux服务器部署" class="headerlink" title="Linux服务器部署"></a>Linux服务器部署</h1><h2 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h2><p>首先需安装 Linux 操作系统并对其进行初始化配置。具体步骤请参见该文章：<a href="https://github.com/Zouzhp3/Learn/blob/master/Cloud/%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E4%BA%91%E4%B8%BB%E6%9C%BA%28CentOS%29.md" target="_blank" rel="noopener">配置虚拟云主机(CentOS 7)</a></p><p>此外，最好不要用 root 账户直接进行操作，应当设置一个拥有 sudo 权限的新用户，使用该用户进行服务器的操作。</p><p><a href="http://www.cnblogs.com/woshimrf/p/5906084.html" target="_blank" rel="noopener">教程：添加一个新用户并授权</a></p><h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><p>在 CentOS 7和 CentOS 7.1系统中，默认安装的 mysql 是它的分支 mariadb ，因此需要从 mysql 的官网中下载。</p><ol><li>下载 Yum Repo：<br>从 <a href="http://dev.mysql.com/downloads/repo/yum/" target="_blank" rel="noopener">mysql官方下载地址</a> 获取 Yum Repo，并使用<code>yum install</code>命令进行安装该 Repo：<code># yum -y install mysql57-community-release-el7-7.noarch.rpm</code>。完成后可以用<code># yum list | grep mysql</code>来查看可安装的 mysql 包。</li><li>安装 MySQL 数据库的服务器版本：<br><code># yum install mysql-community-server</code></li><li>启动服务：<br><code># service mysqld start</code>，并可用<code># service mysqld status</code>查看服务状态。</li><li>获取初始密码：<br>使用YUM安装并启动MySQL服务后，MySQL进程会自动在进程日志中打印 root 用户的初始密码。使用<code>grep &quot;password&quot; /var/log/mysqld.log</code>可查看日志中的MySQL root 密码。</li><li>修改root用户密码：<br>使用<code># mysql -uroot -p</code>并输入密码后进入 mysql 终端，再使用<code>mysql&gt; ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;new password&#39;;</code>命令修改 mysql 的密码。</li></ol><p>注意：如果装的 mysql 版本是5.7，则可能出现修改密码时报错<code>ERROR 1819 (HY000): Your password does not satisfy the current policy requirements</code>，这是因为新密码安全性较低。可使用<code>mysql&gt; set global validate_password_policy=0;</code>降低密码安全等级后解决。</p><p>mariadb 是 mysql 的一个分支版本，与 mysql 不能同时安装，但是接口与 mysql 完全兼容。当数据库需要迁移到 mariadb 时，可能会出现<code>ImportError: libmysqlclient.so.18</code>的错误，解决方法为’pip install mysql-client’（这里很奇怪，如果是 mysql 数据库的话不用安装 mysql-client 也可以）。</p><h3 id="导出数据库（sql脚本）"><a href="#导出数据库（sql脚本）" class="headerlink" title="导出数据库（sql脚本）"></a>导出数据库（sql脚本）</h3><p><code>mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名</code></p><p>例如：<code>mysqldump -u root -p db_name &gt; test_db.sql</code></p><h3 id="导入数据库（sql脚本）"><a href="#导入数据库（sql脚本）" class="headerlink" title="导入数据库（sql脚本）"></a>导入数据库（sql脚本）</h3><p>使用<code>mysql -u root -p</code>命令进入 MySQL 后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use test;</span><br><span class="line">mysql&gt; source c:/test.sql</span><br></pre></td></tr></table></figure></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://typecodes.com/linux/yuminstallmysql5710.html" target="_blank" rel="noopener">CentOS 7.2使用yum安装MYSQL 5.7.10</a></p><p><a href="https://typecodes.com/web/centos7yuminstallmysql5.html" target="_blank" rel="noopener">阿里云CentOS 7.1使用yum安装MySql 5.6.24</a></p><p><a href="http://bbs.bestsdk.com/detail/762.html" target="_blank" rel="noopener">修改MySQL 5.7.9版本的root密码方法以及一些新变化整理</a> </p><h3 id="在-CentOS-上安装-mysql-python"><a href="#在-CentOS-上安装-mysql-python" class="headerlink" title="在 CentOS 上安装 mysql-python"></a>在 CentOS 上安装 mysql-python</h3><p>在 CentOS 下用<code>pip install mysql-python</code>命令直接安装时会出现找不到<code>mysql_config</code>、<code>gcc</code>等错误，解决方案是安装mysql(或mariadb)的devel包(如mysql-devel或mariadb-devel)，以及安装python的devel包。</p><h2 id="设置远程访问-MySQL"><a href="#设置远程访问-MySQL" class="headerlink" title="设置远程访问 MySQL"></a>设置远程访问 MySQL</h2><p>linux 上的 mysql 数据库都是默认仅允许本地访问。设置 mysql 为远程访问，可以供开发者在本地使用数据库可视化工具远程连接而不用通过 ssh。</p><p>在shell中，$mysql -r -u root -p 输入密码后进入 mysql 数据库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;use mysql;</span><br><span class="line">mysql&gt;update user set host = &apos;%&apos; where user = &apos;root&apos;;    //这个命令执行错误时可略过</span><br><span class="line">mysql&gt;flush privileges;</span><br><span class="line">mysql&gt;select host, user from user; //检查‘%’ 是否插入到数据库中</span><br></pre></td></tr></table></figure><p>找到文件/etc/mysql/my.cnf 修改 bind-address = 0.0.0.0 之后，重启 mysql 进程：<code>$service mysqld restart</code>。</p><h2 id="安装-virtualenv"><a href="#安装-virtualenv" class="headerlink" title="安装 virtualenv"></a>安装 virtualenv</h2><p>首先需安装 python-pip ，若提示没有包可安装，则使用命令<code># yum -y install epel-release</code>安装扩展仓库后再使用 yum 进行安装。使用 pip 安装 virtualenv：<code># pip install virtualenv</code>。</p><p>使用virtualenv命令创建python虚拟环境：<code># virtualenv [虚拟环境名称]</code>，之后在本地会生成一个与虚拟环境同名的文件夹。默认情况下虚拟环境不会依赖系统环境的global site-packages，如果想依赖系统环境的第三方软件包，也可以使用参数–system-site-packages。</p><p>进入虚拟环境目录，启动虚拟环境，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd env1/</span><br><span class="line">[root@localhost env1]# source bin/activate</span><br><span class="line">(env1)[root@localhost env1]# python -V</span><br><span class="line">Python 2.7.8</span><br></pre></td></tr></table></figure></p><p>部署服务时，可直接把开发者 windows 本地的虚拟环境下的 /Lib/site-packages 复制到 Linux 系统里的虚拟环境中，有些出于 python 版本不同导致的兼容问题可通过重新下载库来解决。</p><h3 id="参考文章-1"><a href="#参考文章-1" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="http://qicheng0211.blog.51cto.com/3958621/1561685" target="_blank" rel="noopener">使用 virtualenv 搭建独立的 Python 环境</a></p><h2 id="开放端口"><a href="#开放端口" class="headerlink" title="开放端口"></a>开放端口</h2><p>如果系统的防火墙开启，则需要设置防火墙开放端口。若没有启动防火墙服务，则默认开放所有端口。</p><p>当使用脚本启动 flask 服务时可以指定 Host 和 端口：<code># python manage.py runserver -h 0.0.0.0 -p 80</code>（使用80端口时需要 root 权限）</p><h2 id="使用-supervisor-维护服务进程"><a href="#使用-supervisor-维护服务进程" class="headerlink" title="使用 supervisor 维护服务进程"></a>使用 supervisor 维护服务进程</h2><p>supervisor 是用 Python 开发的一套通用的 Linux 进程管理程序，能将一个普通的命令行进程变为后台 daemon，并监控进程状态，使其异常退出时能自动重启。</p><p>首先使用<code># yum install supervisor</code>命令安装 supervisor 。查看配置文件<code>/etc/supervisord.conf</code>，检查项 [include] 里的应用配置文件应放置在哪个目录，然后在指定目录下新建应用配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[program:app]                                         # app 为具体用户名</span><br><span class="line">command=python manage.py runserver -h 0.0.0.0 -p 5000 # 启动命令，与手动启动命令一样</span><br><span class="line">directory=/home/netlab301/lancs                       # 程序的启动目录</span><br><span class="line">user=root                                             # 启动命令所使用的用户身份</span><br></pre></td></tr></table></figure></p><p>启动 supervisor 即可：<code>supervisord -c /etc/supervisord.conf</code></p><p>常用命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep python  # 查看进程</span><br><span class="line">ps -aux | grep 5000    # 查看占用某端口的进程</span><br><span class="line"></span><br><span class="line">supervisorctl status         # 监控状态</span><br><span class="line">supervisorctl stop app       # 停止 app</span><br><span class="line">supervisorctl start app      # 启动 app （往往需要先启动 virtualenv 虚拟环境）</span><br><span class="line">supervisorctl restart app    # 重启 app</span><br></pre></td></tr></table></figure></p><p>由于 supervisor 往往需要与虚拟环境同时使用，因此 supervisor 脚本中的 python 命令可以用虚拟环境中的 python 命令替代（如：<code>/home/ehpcadmin/venv/bin/python manage.py runserver</code>）</p><h2 id="使用-gunicorn-作为-Web-服务器"><a href="#使用-gunicorn-作为-Web-服务器" class="headerlink" title="使用 gunicorn 作为 Web 服务器"></a>使用 gunicorn 作为 Web 服务器</h2><p>由于 Flask 自带的服务器（通过<code>runserver</code>命令启动）性能差且无法支持并发请求，因此需要使用 gunicorn 作为服务器（或其他 web 服务器）来提供更好的性能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Gunicorn &apos;Green Unicorn&apos; is a Python WSGI HTTP Server for UNIX. It&apos;s a pre-fork worker model. The Gunicorn server is broadly compatible with various web frameworks, simply implemented, light on server resources, and fairly speedy.</span><br></pre></td></tr></table></figure><p>安装 gunicorn：<code>pip install gunicorn</code></p><p>启动 gunicorn 服务器：<code>gunicron -w4 -b0.0.0.0:8000 myapp:app</code>，其中 -w 表示开启多少个 worker，-b 表示 gunicorn 开放的访问地址。想要结束 gunicorn 只需执行<code>pkill gunicorn</code>。</p><p><a href="http://docs.gunicorn.org/en/stable/run.html" target="_blank" rel="noopener">Gunicorn 官方文档</a></p><h3 id="gevent"><a href="#gevent" class="headerlink" title="gevent"></a>gevent</h3><p>gevent 是第三方库，可通过 greenlet 实现协程，其基本思想是：当一个 greenlet 遇到 IO 操作时，比如访问网络，就自动切换到其他的 greenlet，等到 IO 操作完成，再在适当的时候切换回来继续执行。由于 IO 操作非常耗时，经常使程序处于等待状态，有了 gevent 为我们自动切换协程，就保证总有 greenlet 在运行，而不是等待 IO。</p><p>因此结合 gunicorn 启动服务的命令可设置为：<code>gunicorn manage:app -b 0.0.0.0:8080 -w 4 --worker-class gevent</code>（此命令可写入 supervisor 的应用配置文件中）</p><hr><ul><li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p></li><li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p></li></ul><h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p><blockquote><p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p></blockquote><blockquote><p>体育&amp;户外用品推荐</p></blockquote><div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/se-notes/Flask-Web工程手册/ch4-Linux服务器部署/../more/ads/amazon.gif" width="100%"></a> </div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#linux服务器部署&quot;&gt;Linux服务器部署&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#初始化服务器&quot;&gt;初始化服务器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#安装mysql&quot;&gt;安装MySQL&lt;/a&gt;&lt;ul&gt;

      
    
    </summary>
    
      <category term="框架" scheme="https://wnhby.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="python-web应用框架" scheme="https://wnhby.github.io/categories/%E6%A1%86%E6%9E%B6/python-web%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="web开发" scheme="https://wnhby.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="flask" scheme="https://wnhby.github.io/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>ch5-使用lsyncd进行文件实时备份</title>
    <link href="https://wnhby.github.io/se-notes/Flask-Web%E5%B7%A5%E7%A8%8B%E6%89%8B%E5%86%8C/ch5-%E4%BD%BF%E7%94%A8lsyncd%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E5%AE%9E%E6%97%B6%E5%A4%87%E4%BB%BD/"/>
    <id>https://wnhby.github.io/se-notes/Flask-Web工程手册/ch5-使用lsyncd进行文件实时备份/</id>
    <published>2019-01-03T13:49:30.000Z</published>
    <updated>2019-02-19T05:17:43.891Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#安装">安装</a><ul><li><a href="#ubuntu-环境">Ubuntu 环境</a></li><li><a href="#centos-环境">CentOS 环境</a></li></ul></li><li><a href="#配置">配置</a><ul><li><a href="#配置选项说明">配置选项说明</a></li><li><a href="#启动-lsyncd">启动 lsyncd</a></li></ul></li><li><a href="#ssh-密钥配置">SSH 密钥配置</a><ul><li><a href="#备份服务器操作">备份服务器操作</a></li><li><a href="#主服务器操作">主服务器操作</a></li></ul></li><li><a href="#配置文件模式示例">配置文件模式示例</a></li><li><a href="#参考文档">参考文档</a><ul><li><a href="#ads">Ads</a></li></ul></li></ul><!-- /TOC --><p>Lysncd 实际上是 lua 语言封装了 inotify 和 rsync 工具，采用了 Linux 内核（2.6.13 及以后）里的 inotify 触发机制，然后通过 rsync 去差异同步，达到实时的效果。它完美解决了 inotify + rsync 海量文件同步带来的文件频繁发送文件列表的问题 —— 通过时间延迟或累计触发事件次数实现。</p><p>另外，它的配置方式很简单，lua 本身就是一种配置语言，可读性非常强。lsyncd 也有多种工作模式可以选择（本地目录 cp，本地目录 rsync，远程目录 rsyncssh）。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Ubuntu-环境"><a href="#Ubuntu-环境" class="headerlink" title="Ubuntu 环境"></a>Ubuntu 环境</h3><p>已经收录在 ubuntu 的官方镜像源里，直接通过<code>apt-get install lsyncd</code>命令安装。</p><h3 id="CentOS-环境"><a href="#CentOS-环境" class="headerlink" title="CentOS 环境"></a>CentOS 环境</h3><p>安装了 epel-release 扩展源后，通过<code>yum install lsyncd</code>命令安装。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>lsyncd 安装完后默认并没有提供配置文件，因此需要我们自行创建。配置文件 lsyncd.conf 的一个示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># cd /usr/local/lsyncd-2.1.5</span><br><span class="line"># mkdir etc var</span><br><span class="line"># vi etc/lsyncd.conf</span><br><span class="line"></span><br><span class="line">settings &#123;</span><br><span class="line">    logfile = &quot;/home/ubuntu/Desktop/lsyncd.log&quot;,</span><br><span class="line">    statusFile = &quot;/home/ubuntu/Desktop/lsyncd.status&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sync &#123;</span><br><span class="line">    default.rsyncssh,</span><br><span class="line">    source = &quot;/home/ubuntu/Desktop/src&quot;,</span><br><span class="line">    host = &quot;192.168.10.133&quot;,</span><br><span class="line">    targetdir = &quot;/home/ubuntu/Desktop/dst&quot;,</span><br><span class="line">    delay = 15</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置选项说明"><a href="#配置选项说明" class="headerlink" title="配置选项说明"></a>配置选项说明</h3><p><strong>settings</strong>里是全局设置，<code>--</code>开头表示注释，下面是几个常用选项说明：</p><ul><li><code>logfile</code> ：设置日志文件</li><li><code>stausFile</code> ：设置状态文件</li><li><code>statusInterval</code> ：将 lsyncd 的状态写入上面的statusFile的间隔，默认10秒</li><li><code>inotifyMode</code> ：指定inotify监控的事件，默认是<code>CloseWrite</code>，还可以是<code>Modify</code>或<code>CloseWrite or Modify</code></li><li><code>maxProcesses</code> ：同步进程的最大个数。假如同时有20个文件需要同步，而<code>maxProcesses = 8</code>，则最大能看到有8个rysnc进程</li><li><code>maxDelays</code> ：累计到多少所监控的事件激活一次同步，即使后面的<code>delay</code>延迟时间还未到</li></ul><p><strong>sync</strong>里是定义同步参数。</p><p>一般第一个参数指定 lsyncd serv以什么模式运行：<strong>rsync</strong>、<strong>rsyncssh</strong>、<strong>direct</strong> 三种模式：</p><ul><li><code>default.rsync</code> ：<strong>本地目录间同步</strong>。使用 rsync 也可以达到使用 ssh 形式的远程 rsync 效果<br><code>default.direct</code> ：<strong>本地目录间同步</strong>，使用 cp、rm 等命令完成差异文件备份<br><code>default.rsyncssh</code> ：<strong>同步到远程主机目录</strong>，rsync 的 ssh 模式，需要使用 key 来认证</li><li><code>source</code> ：同步的源目录，使用绝对路径。</li><li><code>target</code> ：同步的目的目录，在不同模式下有不同的写法。</li><li><code>init</code> ：当<code>init=false</code>时表示跳过初始同步，启动时即使原目录有差异时也不会同步。默认值为<code>true</code>。</li><li><code>delay</code> ：等待同步的延时，默认15s，即每15s同步一次。</li><li><code>excludeFrom</code>： 排除选项，后面指定排除的列表文件.</li></ul><p>更多参数设置可以在参考文档中查看。</p><h3 id="启动-lsyncd"><a href="#启动-lsyncd" class="headerlink" title="启动 lsyncd"></a>启动 lsyncd</h3><p>使用命令加载配置文件启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsyncd -log Exec [CONFIG-FILE]</span><br></pre></td></tr></table></figure><p>[CONFIG-FILE]为配置文件所在路径。</p><blockquote><p>更加详细的说明可以通过<code>lsyncd -help</code>查看。</p></blockquote><h2 id="SSH-密钥配置"><a href="#SSH-密钥配置" class="headerlink" title="SSH 密钥配置"></a>SSH 密钥配置</h2><p>为了让<code>lysncd</code>能够以 rsyncssh 模式进行工作，我们还需要对备份服务器进行一些配置。</p><blockquote><p>主服务器是指需要被备份的服务器，备份服务器是指用来实现主服务器备份的服务器。</p></blockquote><h3 id="备份服务器操作"><a href="#备份服务器操作" class="headerlink" title="备份服务器操作"></a>备份服务器操作</h3><p>在备份服务器中创建一个密钥对，直接回车即可，然后设置为<code>authorized_keys</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br><span class="line">cd ~/.ssh</span><br><span class="line">cat id_rsa.pub &gt;&gt; authorized_keys</span><br></pre></td></tr></table></figure><p>然后检查备份服务器有没有安装<code>openssh-server</code>，没有的话需要安装。</p><h3 id="主服务器操作"><a href="#主服务器操作" class="headerlink" title="主服务器操作"></a>主服务器操作</h3><p>将备份服务器中生成的私钥<code>id_rsa</code>拷贝到主服务器的<code>~/.ssh/</code>里面。然后设置好权限，并且测试是否能够正常登陆。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 600 ~/.ssh/id_rsa</span><br><span class="line">ssh [USER]@[REMOTE_IP]</span><br></pre></td></tr></table></figure><p>[USER]和[REMOTE_IP]为登陆的用户和备份服务器的IP。如果能成功登陆的话则表示配置成功。</p><blockquote><p>也可以在主服务器中生成一对密钥，把公钥拷贝到备份服务器的<code>~/.ssh/authorized_keys</code>中。</p></blockquote><h2 id="配置文件模式示例"><a href="#配置文件模式示例" class="headerlink" title="配置文件模式示例"></a>配置文件模式示例</h2><p>下面的内容几乎涵盖了所有同步的模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">settings &#123;</span><br><span class="line">    logfile =&quot;/usr/local/lsyncd-2.1.5/var/lsyncd.log&quot;,</span><br><span class="line">    statusFile =&quot;/usr/local/lsyncd-2.1.5/var/lsyncd.status&quot;,</span><br><span class="line">    inotifyMode = &quot;CloseWrite&quot;,</span><br><span class="line">    maxProcesses = 8,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- I. 本地目录同步，direct：cp/rm/mv。 适用：500+万文件，变动不大</span><br><span class="line">sync &#123;</span><br><span class="line">    default.direct,</span><br><span class="line">    source    = &quot;/tmp/src&quot;,</span><br><span class="line">    target    = &quot;/tmp/dest&quot;,</span><br><span class="line">    delay = 1</span><br><span class="line">    maxProcesses = 1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">-- II. 本地目录同步，rsync模式：rsync</span><br><span class="line">sync &#123;</span><br><span class="line">    default.rsync,</span><br><span class="line">    source    = &quot;/tmp/src&quot;,</span><br><span class="line">    target    = &quot;/tmp/dest1&quot;,</span><br><span class="line">    excludeFrom = &quot;/etc/rsyncd.d/rsync_exclude.lst&quot;,</span><br><span class="line">    rsync     = &#123;</span><br><span class="line">        binary = &quot;/usr/bin/rsync&quot;,</span><br><span class="line">        archive = true,</span><br><span class="line">        compress = true,</span><br><span class="line">        bwlimit   = 2000</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">-- III. 远程目录同步，rsync模式 + rsyncd daemon</span><br><span class="line">sync &#123;</span><br><span class="line">    default.rsync,</span><br><span class="line">    source    = &quot;/tmp/src&quot;,</span><br><span class="line">    target    = &quot;syncuser@172.29.88.223::module1&quot;,</span><br><span class="line">    delete=&quot;running&quot;,</span><br><span class="line">    exclude = &#123; &quot;.*&quot;, &quot;.tmp&quot; &#125;,</span><br><span class="line">    delay = 30,</span><br><span class="line">    init = false,</span><br><span class="line">    rsync     = &#123;</span><br><span class="line">        binary = &quot;/usr/bin/rsync&quot;,</span><br><span class="line">        archive = true,</span><br><span class="line">        compress = true,</span><br><span class="line">        verbose   = true,</span><br><span class="line">        password_file = &quot;/etc/rsyncd.d/rsync.pwd&quot;,</span><br><span class="line">        _extra    = &#123;&quot;--bwlimit=200&quot;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">-- IV. 远程目录同步，rsync模式 + ssh shell</span><br><span class="line">sync &#123;</span><br><span class="line">    default.rsync,</span><br><span class="line">    source    = &quot;/tmp/src&quot;,</span><br><span class="line">    target    = &quot;172.29.88.223:/tmp/dest&quot;,</span><br><span class="line">    -- target    = &quot;root@172.29.88.223:/remote/dest&quot;,</span><br><span class="line">    -- 上面target，注意如果是普通用户，必须拥有写权限</span><br><span class="line">    maxDelays = 5,</span><br><span class="line">    delay = 30,</span><br><span class="line">    -- init = true,</span><br><span class="line">    rsync     = &#123;</span><br><span class="line">        binary = &quot;/usr/bin/rsync&quot;,</span><br><span class="line">        archive = true,</span><br><span class="line">        compress = true,</span><br><span class="line">        bwlimit   = 2000</span><br><span class="line">        -- rsh = &quot;/usr/bin/ssh -p 22 -o StrictHostKeyChecking=no&quot;</span><br><span class="line">        -- 如果要指定其它端口，请用上面的rsh</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">-- V. 远程目录同步，rsync模式 + rsyncssh，效果与上面相同</span><br><span class="line">sync &#123;</span><br><span class="line">    default.rsyncssh,</span><br><span class="line">    source    = &quot;/tmp/src2&quot;,</span><br><span class="line">    host      = &quot;172.29.88.223&quot;,</span><br><span class="line">    targetdir = &quot;/remote/dir&quot;,</span><br><span class="line">    excludeFrom = &quot;/etc/rsyncd.d/rsync_exclude.lst&quot;,</span><br><span class="line">    -- maxDelays = 5,</span><br><span class="line">    delay = 0,</span><br><span class="line">    -- init = false,</span><br><span class="line">    rsync    = &#123;</span><br><span class="line">        binary = &quot;/usr/bin/rsync&quot;,</span><br><span class="line">        archive = true,</span><br><span class="line">        compress = true,</span><br><span class="line">        verbose   = true,</span><br><span class="line">        _extra = &#123;&quot;--bwlimit=2000&quot;&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    ssh      = &#123;</span><br><span class="line">        port  =  1234</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://axkibe.github.io/lsyncd/manual/config/layer4/" target="_blank" rel="noopener">Config Layer 4: Default Config</a></p><p><a href="http://clavinli.github.io/2013/11/12/linux-server-lsyncd/" target="_blank" rel="noopener">Lsyncd | 使用lsyncd同步文件目录</a>    </p><p><a href="http://seanlook.com/2015/05/06/lsyncd-synchronize-realtime/" target="_blank" rel="noopener">lsyncd实时同步搭建指南——取代rsync+inotify</a></p><hr><ul><li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p></li><li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p></li></ul><h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p><blockquote><p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p></blockquote><blockquote><p>体育&amp;户外用品推荐</p></blockquote><div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/se-notes/Flask-Web工程手册/ch5-使用lsyncd进行文件实时备份/../more/ads/amazon.gif" width="100%"></a> </div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#安装&quot;&gt;安装&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#ubuntu-环境&quot;&gt;Ubuntu 环境&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#centos-环境&quot;&gt;CentOS 环境&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
      
    
    </summary>
    
      <category term="框架" scheme="https://wnhby.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="python-web应用框架" scheme="https://wnhby.github.io/categories/%E6%A1%86%E6%9E%B6/python-web%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="web开发" scheme="https://wnhby.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="flask" scheme="https://wnhby.github.io/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>ch8-高可用与负载均衡集群部署-Ubuntu</title>
    <link href="https://wnhby.github.io/se-notes/Flask-Web%E5%B7%A5%E7%A8%8B%E6%89%8B%E5%86%8C/ch8-%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2-Ubuntu/"/>
    <id>https://wnhby.github.io/se-notes/Flask-Web工程手册/ch8-高可用与负载均衡集群部署-Ubuntu/</id>
    <published>2019-01-03T13:49:30.000Z</published>
    <updated>2019-02-19T05:18:07.564Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#ehpc负载均衡及高可用集群部署说明">EHPC负载均衡及高可用集群部署说明</a><ul><li><a href="#一物理架构及技术简介">一.物理架构及技术简介</a><ul><li><a href="#haproxy">HAProxy</a></li><li><a href="#keepalived">Keepalived</a></li><li><a href="#nfs">NFS</a></li></ul></li><li><a href="#二部署准备">二.部署准备</a></li><li><a href="#三数据库节点配置">三.数据库节点配置</a><ul><li><a href="#nfs-服务配置">NFS 服务配置</a></li><li><a href="#mysql-服务配置">MySQL 服务配置</a></li></ul></li><li><a href="#四web服务节点配置">四.Web服务节点配置</a></li><li><a href="#五haproxy代理节点配置">五.HAProxy代理节点配置</a></li><li><a href="#如何进行项目文件更新">如何进行项目文件更新</a></li><li><a href="#架构中将来可能遇到的问题">架构中将来可能遇到的问题</a></li><li><a href="#部署问题汇总">部署问题汇总</a><ul><li><a href="#ubuntu系统设置dns失败">ubuntu系统设置DNS失败</a></li><li><a href="#启动-80-端口的-web-节点的服务时提示端口被占用">启动 80 端口的 web 节点的服务时提示端口被占用</a></li><li><a href="#virtualenv-虚拟环境迁移后无法正常引用库">virtualenv 虚拟环境迁移后无法正常引用库</a></li><li><a href="#复制-bashrc-文件后虚拟环境导向出错">复制 .bashrc 文件后虚拟环境导向出错</a></li><li><a href="#设置语言的环境变量时警告-warning-setlocale-lc_all-cannot-change-locale-zh_cnutf-8">设置语言的环境变量时警告 warning: setlocale: LC_ALL： cannot change locale (zh_CN.UTF-8)</a></li><li><a href="#安装-gevent-失败">安装 gevent 失败</a></li><li><a href="#supervisor启动后-web-服务启动失败">supervisor启动后 web 服务启动失败</a></li><li><a href="#ads">Ads</a></li></ul></li></ul></li></ul><!-- /TOC --><h1 id="EHPC负载均衡及高可用集群部署说明"><a href="#EHPC负载均衡及高可用集群部署说明" class="headerlink" title="EHPC负载均衡及高可用集群部署说明"></a>EHPC负载均衡及高可用集群部署说明</h1><h2 id="一-物理架构及技术简介"><a href="#一-物理架构及技术简介" class="headerlink" title="一.物理架构及技术简介"></a>一.物理架构及技术简介</h2><p>使用 Haproxy + Keepalived + nfs 作为集群部署方式。其中一台或多台 Hapoxy 代理服务器作为集群负载均衡的调度前端，多个 web 服务节点、单个数据库节点（同时提供 nfs 文件共享存储）作为对外隐藏的集群后端。</p><h3 id="HAProxy"><a href="#HAProxy" class="headerlink" title="HAProxy"></a>HAProxy</h3><p>HAProxy（High Available Proxy）是一款提供高可用性、负载均衡以及基于 TCP（第四层）和 HTTP（第七层）应用的代理软件。 HAProxy 配置简单、支持多达上万并发连接。其运行模型可使得它非常容易和无风险地集成到现有的架构中，并且同时可以保护 web 服务器不被暴露到网络上。</p><h3 id="Keepalived"><a href="#Keepalived" class="headerlink" title="Keepalived"></a>Keepalived</h3><p>Keepalived 是一款高可用软件，它的功能是基于 VRRP 协议、通过 IP 漂移实现服务的高可用：服务器集群共享一个虚拟 IP，同一时间只有一个服务器占有虚拟 IP 并对外提供服务。若该服务器不可用，则虚拟 IP 漂移至另一台服务器并对外提供服务。</p><h3 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h3><p>在 Web 服务中往往需要涉及到一些不储存在数据库中的文件资源（比如用户上传的图片、文件等），而在集群中，若每个节点都有独立的文件存储的话，会造成存储不一致的后果。因此解决方案是构建一个 NFS（Network File System）服务器专门提供服务器节点间的共享文件存储，这样服务器节点间的存储就可以保持一致性。</p><h2 id="二-部署准备"><a href="#二-部署准备" class="headerlink" title="二.部署准备"></a>二.部署准备</h2><p>准备四台虚机（Linux Ubuntu），分别作为前端代理（ ha1[10.182.15.46]）、服务节点（web1[10.182.15.51<br>]、web2[10.182.15.52]）、数据库节点（nfs1[10.182.15.50]）。所有节点均可访问外网，其中只有 ha1 拥有公网 IP。</p><blockquote><p>此外还拥有一台备份节点，用于对数据库节点 nfs1 的数据库以及文件目录进行实时主从备份。</p></blockquote><p>所有节点须设置好 hosts 互相解析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#vi /etc/hosts</span><br><span class="line">10.182.15.46    ha1</span><br><span class="line">10.182.15.50    nfs1</span><br><span class="line">10.182.15.51    web1</span><br><span class="line">10.182.15.52    web2</span><br></pre></td></tr></table></figure></p><p>以及更新好 apt-get 库：<code>apt-get update</code></p><h2 id="三-数据库节点配置"><a href="#三-数据库节点配置" class="headerlink" title="三.数据库节点配置"></a>三.数据库节点配置</h2><p>数据库节点为 nfs1，主要提供 NFS 与 MySQL 服务。</p><h3 id="NFS-服务配置"><a href="#NFS-服务配置" class="headerlink" title="NFS 服务配置"></a>NFS 服务配置</h3><p>安装 NFS 服务<code>sudo apt-get install nfs-kernel-server</code>，并编辑配置文件（路径为<code>/etc/exports</code>），配置文件中的每一行表示设置一个共享目录以及有其访问权限的主机地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 共享目录路径为“/home/share”，对 web1 与 web2 两台主机开放读写权限</span><br><span class="line">/home/share   web1(rw,sync,no_root_squash) web2(rw,sync,no_root_squash)</span><br></pre></td></tr></table></figure><p>启动 NFS 服务：<code>service nfs-kernel-server start</code>后， NFS 客户端才可对共享目录进行挂载。</p><p>共享目录中放置 ehpc 的服务端项目文件，所有 web 服务节点将一起使用共享目录中的项目文件。</p><p>更多配置参数请参考 <a href="https://github.com/Zouzhp3/Learn/blob/master/Cloud/%E9%85%8D%E7%BD%AE%E9%9B%86%E7%BE%A4%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%20NFS%20%E6%9C%8D%E5%8A%A1%E5%99%A8.md" target="_blank" rel="noopener">NFS服务器配置文档</a>。</p><h3 id="MySQL-服务配置"><a href="#MySQL-服务配置" class="headerlink" title="MySQL 服务配置"></a>MySQL 服务配置</h3><p>ubuntu 系统一般会自带 MySQL 5.5，因此无需再安装一遍。首先使用默认的 mysql root 账户进入 mysql 命令行，修改 root 默认密码，并创建一个拥有访问权限的普通用户。</p><p>按照以下步骤设置开放 MySQL 的远程访问权限：</p><ul><li>保证远程访问的 mysql 用户的 host 为’%’而不是’localhost’</li><li><code>sudo vi /etc/mysql/my.cnf</code>，注释掉<code>bind-address = 127.0.0.1</code></li><li>重启 mysql 服务</li></ul><p>之后导入原数据库的 sql 脚本即可。</p><p>至此便完成了节点 nfs1 的配置。</p><h2 id="四-Web服务节点配置"><a href="#四-Web服务节点配置" class="headerlink" title="四.Web服务节点配置"></a>四.Web服务节点配置</h2><p>本集群拥有两个 web 服务节点 web1、web2，两个节点的部署操作完全一致。</p><p>先使用 pip 安装 virtualenv、gunicorn、gevent、supervisor 等软件并使用<code>apt-get install nfs-common​</code>安装 NFS 客户端。再把 nfs1 节点开放的共享目录<code>/home/share</code>挂载到本地目录<code>/home/haproxy/share</code>，并设置为永久挂载（挂载操作参考 <a href="https://github.com/Zouzhp3/Learn/blob/master/Cloud/%E9%85%8D%E7%BD%AE%E9%9B%86%E7%BE%A4%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%20NFS%20%E6%9C%8D%E5%8A%A1%E5%99%A8.md" target="_blank" rel="noopener">NFS服务器配置文档</a>）。</p><p>迁移原 python 虚拟环境（迁移方法参考本文文末）后，还需要配置环境变量：把原脚本<code>.bashrc</code> copy 到用户根目录中，并对其中数据库配置等环境参数进行修改以满足当前实际要求，之后<code>source ~/.bashrc</code>刷新环境变量即可。</p><p>之后配置 supervisor（路径<code>/etc/supervisor/conf.d/ehpc.conf</code>）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[program:ehpc]</span><br><span class="line">command=/home/haproxy/env/bin/gunicorn manage:app -b 0.0.0.0:80 -w 4 --worker-class gevent</span><br><span class="line">autostart = true</span><br><span class="line">autorestart = true</span><br><span class="line">user=root</span><br></pre></td></tr></table></figure></p><blockquote><p>注意 manage.py 路径，需当前工作目录为项目主目录才可启动成功。最好在启动 supervisor 前手工启动跑一下以便及早发现可能的问题。</p></blockquote><h2 id="五-HAProxy代理节点配置"><a href="#五-HAProxy代理节点配置" class="headerlink" title="五.HAProxy代理节点配置"></a>五.HAProxy代理节点配置</h2><p>前端节点为 ha1，作为集群中唯一直接对外通信的代理服务器。</p><p>安装 HAProxy：<code>yum install haproxy</code>，然后配置 HAProxy（路径<code>/etc/haproxy/haproxy.cfg</code>）。</p><p>HAProxy 的配置文件分为五个部分：</p><ul><li>global：全局配置的进程级参数，用来控制 Haproxy 启动前的一些进程及系统设置</li><li>defaults：配置默认参数，可以被 frontend，backend，listen 段继承使用</li><li>frontend：定义接收请求的前端虚拟节点，可根据用户所请求的不同域名、URL 等做不同的请求处理</li><li>backend：定义处理业务的后端服务器集群，以及设置后端的权重、队列、连接数等选项</li><li>listen：frontend 和 backend 的组合体</li></ul><blockquote><p>配置参数详细说明请查阅 <a href="http://www.ttlsa.com/linux/haproxy-study-tutorial/" target="_blank" rel="noopener">HAProxy用法详解</a>。</p></blockquote><p>以下是 ha1 的配置实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">global</span><br><span class="line">        log /dev/log    local0</span><br><span class="line">        log /dev/log    local1 notice</span><br><span class="line">        chroot /var/lib/haproxy</span><br><span class="line">        maxconn 20000</span><br><span class="line">        daemon</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">        log     global</span><br><span class="line">        mode    http</span><br><span class="line">        option  httplog</span><br><span class="line">        option  dontlognull</span><br><span class="line">        option http-server-close</span><br><span class="line">        option forwardfor except 127.0.0.0/8</span><br><span class="line">        option redispatch</span><br><span class="line">        retries 3             # 3次连接失败就认为服务器不可用</span><br><span class="line">        timeout http-keep-alive 10s           # 默认持久连接超时时间</span><br><span class="line">        timeout check           10s           # 心跳检查超时时间</span><br><span class="line">        contimeout 5000</span><br><span class="line">        clitimeout 50000</span><br><span class="line">        srvtimeout 50000</span><br><span class="line">        errorfile 400 /etc/haproxy/errors/400.http</span><br><span class="line">        errorfile 403 /etc/haproxy/errors/403.http</span><br><span class="line">        errorfile 408 /etc/haproxy/errors/408.http</span><br><span class="line">        errorfile 500 /etc/haproxy/errors/500.http</span><br><span class="line">        errorfile 502 /etc/haproxy/errors/502.http</span><br><span class="line">        errorfile 503 /etc/haproxy/errors/503.http</span><br><span class="line">        errorfile 504 /etc/haproxy/errors/504.http</span><br><span class="line"></span><br><span class="line">frontend  proxy *:80    #前端代理</span><br><span class="line">        default_backend  dynamic</span><br><span class="line"></span><br><span class="line">backend dynamic    #后端Web服务器</span><br><span class="line">        balance roundrobin</span><br><span class="line">        cookie  SESSION_ID insert indirect nocache    #设置cookie保持</span><br><span class="line">        server  web1  10.182.15.51:80 inter 3000 rise 2 fall 3 check maxconn 10000 cookie A</span><br><span class="line">        server  web2  10.182.15.52:80 inter 3000 rise 2 fall 3 check maxconn 10000 cookie B</span><br></pre></td></tr></table></figure></p><p>启动 HAProxy 服务：<code>service haproxy start</code>即可。</p><h2 id="如何进行项目文件更新"><a href="#如何进行项目文件更新" class="headerlink" title="如何进行项目文件更新"></a>如何进行项目文件更新</h2><p>更新之前先停掉 web1 与 web2 的服务：<code>supervisorctl stop ehpc</code></p><ul><li>更新数据库：登录 nfs1，进入 mysql 命令行进行新的数据库 sql 文件导入即可</li><li>更新项目文件：登录 nfs1，新的项目文件代替<code>/home/share</code>中对应的文件即可。</li></ul><blockquote><p>提示：由于通过跳板机登录 nfs1 不能使用 sftp 功能，因此目前也把跳板机下的目录挂载了 nfs1 上的共享目录，这样直接通过在跳板机上上传文件就可以修改项目文件了。</p></blockquote><p>最后记得要重启 web1 与 web2 的服务：<code>supervisorctl start ehpc</code></p><h2 id="架构中将来可能遇到的问题"><a href="#架构中将来可能遇到的问题" class="headerlink" title="架构中将来可能遇到的问题"></a>架构中将来可能遇到的问题</h2><p>由于 nfs1 既作为集群中唯一的数据库服务节点以及唯一的文件共享目录挂载节点，同时还负责对外实时备份，因此很有可能成为集群中效率的瓶颈。今后的架构重构中，应当考虑把数据库服务从文件共享目录挂载节点分离开，减小 nfs1 的压力。</p><h2 id="部署问题汇总"><a href="#部署问题汇总" class="headerlink" title="部署问题汇总"></a>部署问题汇总</h2><h3 id="ubuntu系统设置DNS失败"><a href="#ubuntu系统设置DNS失败" class="headerlink" title="ubuntu系统设置DNS失败"></a>ubuntu系统设置DNS失败</h3><p>在<code>/etc/resolvconf/resolv.conf.d/base</code>里添加 DNS 失败，则应当在<code>/etc/resolvconf/resolv.conf.d/head</code>中进行添加，之后使用<code>resolvconf -u</code>刷新即可。</p><h3 id="启动-80-端口的-web-节点的服务时提示端口被占用"><a href="#启动-80-端口的-web-节点的服务时提示端口被占用" class="headerlink" title="启动 80 端口的 web 节点的服务时提示端口被占用"></a>启动 80 端口的 web 节点的服务时提示端口被占用</h3><p>ubuntu 系统自带 Apache2 服务占用了 80 端口且开机自动启动，用<code>sudo lsof -i:80</code>命令找出 80 端口的占用程序 kill 掉即可，此外还可使用<code>sudo update-rc.d apache2 disable</code>命令关闭 apache2 的自启动。</p><h3 id="virtualenv-虚拟环境迁移后无法正常引用库"><a href="#virtualenv-虚拟环境迁移后无法正常引用库" class="headerlink" title="virtualenv 虚拟环境迁移后无法正常引用库"></a>virtualenv 虚拟环境迁移后无法正常引用库</h3><p>直接 copy 虚拟环境到另一台主机上就会出现新虚拟环境下的 python 无法引用库的问题。解决方法是在新主机上重新新建一个虚拟环境，然后把要原虚拟环境中的<code>lib/python2.7/site-packages/</code>目录下的库都 copy 到新虚拟环境中的该目录下即可。</p><h3 id="复制-bashrc-文件后虚拟环境导向出错"><a href="#复制-bashrc-文件后虚拟环境导向出错" class="headerlink" title="复制 .bashrc 文件后虚拟环境导向出错"></a>复制 .bashrc 文件后虚拟环境导向出错</h3><p>.bashrc 复制到新的主机的用户根目录下时出现，删除以下两行即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export WORKON_HOME=~/.Envs</span><br><span class="line">source /usr/local/bin/virtualenvwrapper.sh</span><br></pre></td></tr></table></figure></p><h3 id="设置语言的环境变量时警告-warning-setlocale-LC-ALL：-cannot-change-locale-zh-CN-UTF-8"><a href="#设置语言的环境变量时警告-warning-setlocale-LC-ALL：-cannot-change-locale-zh-CN-UTF-8" class="headerlink" title="设置语言的环境变量时警告 warning: setlocale: LC_ALL： cannot change locale (zh_CN.UTF-8)"></a>设置语言的环境变量时警告 warning: setlocale: LC_ALL： cannot change locale (zh_CN.UTF-8)</h3><p>如果不处理的话会导致程序中编码问题而报错。这是因为系统里没有安装对应的语言包，使用<code>sudo apt-get install language-pack-zh-hans</code>安装对应的语言包后重启并<code>source ~/.bashrc</code>即可。</p><h3 id="安装-gevent-失败"><a href="#安装-gevent-失败" class="headerlink" title="安装 gevent 失败"></a>安装 gevent 失败</h3><p>使用<code>pip install gevent</code>安装 gevent 时失败时，需要安装依赖包 python-dev ：<code>sudo apt-get install python-dev</code></p><h3 id="supervisor启动后-web-服务启动失败"><a href="#supervisor启动后-web-服务启动失败" class="headerlink" title="supervisor启动后 web 服务启动失败"></a>supervisor启动后 web 服务启动失败</h3><p>在使用 supervisor 启动服务前先使用<code>gunicorn manage:app -b 0.0.0.0:80 -w 4 --worker-class gevent</code>命令进行测试，观察服务能否正常启动。若测试成功，则还要保证以下三点：</p><ul><li>工作目录是 ehpc 项目的主目录</li><li>supervisor 服务处于开启状态：<code>sudo service supervisor status</code></li><li>使用<code>supervisord -c /etc/supervisor/supervisor.conf</code>启动 supervisor 进程</li></ul><hr><ul><li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p></li><li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p></li></ul><h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p><blockquote><p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p></blockquote><blockquote><p>体育&amp;户外用品推荐</p></blockquote><div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/se-notes/Flask-Web工程手册/ch8-高可用与负载均衡集群部署-Ubuntu/../more/ads/amazon.gif" width="100%"></a> </div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#ehpc负载均衡及高可用集群部署说明&quot;&gt;EHPC负载均衡及高可用集群部署说明&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一物理架构及技术简介&quot;&gt;一.物理架构及技术简介&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#h
      
    
    </summary>
    
      <category term="框架" scheme="https://wnhby.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="python-web应用框架" scheme="https://wnhby.github.io/categories/%E6%A1%86%E6%9E%B6/python-web%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="web开发" scheme="https://wnhby.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="flask" scheme="https://wnhby.github.io/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>ch6-配置集群共享文件NFS服务器</title>
    <link href="https://wnhby.github.io/se-notes/Flask-Web%E5%B7%A5%E7%A8%8B%E6%89%8B%E5%86%8C/ch6-%E9%85%8D%E7%BD%AE%E9%9B%86%E7%BE%A4%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6NFS%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://wnhby.github.io/se-notes/Flask-Web工程手册/ch6-配置集群共享文件NFS服务器/</id>
    <published>2019-01-03T13:49:30.000Z</published>
    <updated>2019-02-19T05:17:51.600Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#配置集群共享文件-nfs-服务器">配置集群共享文件 NFS 服务器</a><ul><li><a href="#简介">简介</a></li><li><a href="#安装与配置">安装与配置</a></li><li><a href="#启动与挂载">启动与挂载</a></li><li><a href="#nfs-的常用命令">NFS 的常用命令</a></li><li><a href="#参考文档">参考文档</a><ul><li><a href="#ads">Ads</a></li></ul></li></ul></li></ul><!-- /TOC --><h1 id="配置集群共享文件-NFS-服务器"><a href="#配置集群共享文件-NFS-服务器" class="headerlink" title="配置集群共享文件 NFS 服务器"></a>配置集群共享文件 NFS 服务器</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在 Web 服务中往往需要涉及到一些不储存在数据库中的文件资源（比如用户上传的图片、文件等），而在 Web 服务器集群中，若每个服务器节点都有独立的文件资源存储的话，会造成节点间存储不一致的后果。因此比较成熟的解决方案是构建一个 NFS（Network File System）服务器专门提供服务器节点间的共享文件存储。当其他所有 Web 服务器挂载共享目录后，每次读写共享文件资源时实际上读写的是 NFS 服务器上的共享文件系统，这样服务器节点间的存储就可以保持一致性。</p><h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><p>首先在服务器节点上安装 NFS 服务：<code>yum install nfs-utils rpcbind</code>，然后在客户端节点上安装 NFS 服务：<code>yum install nfs-utils</code>。</p><p>配置 NFS 服务器（配置文件路径<code>/etc/exports</code>），配置文件中的每一行表示设置一个共享目录以及其有访问权限的主机地址。以下是一个说明示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 共享目录路径为“/home/share”，对所有主机可读，对地址为192.168.1.19的主机可读可写</span><br><span class="line">/home/share *(sync,ro,no_root_squash) 192.168.1.19(sync,rw,no_root_squash)</span><br><span class="line"></span><br><span class="line"># 共享目录路径为“/home/pub”，对192.168.152.0子网内的所有主机可读</span><br><span class="line">/home/pub 192.168.152.0/24(sync,ro,no_root_squash)</span><br></pre></td></tr></table></figure></p><ul><li>sync：设置NFS服务器同步写磁盘，这样不会轻易丢失数据，建议所有的NFS共享目录都使用该选项</li><li>ro：设置输出的共享目录只读，与 rw 不能共同使用</li><li>rw：设置输出的共享目录可读写，与 ro 不能共同使用</li><li>root_squash：远程登录 NFS 主机后，使用该共享目录时相当于该目录的拥有者。但是如果是以 root 身份使用这个共享目录的时候，那么这个使用者（root）的权限将被压缩成为匿名使用者，即通常他的 UID 与 GID 都会变成nobody那个身份（较为安全）</li><li>no_root_squash：远程登录 NFS 主机后，使用该共享目录时相当于该目录的拥有者，如果是 root 的话，那么对于这个共享的目录来说，他就具有 root 的权限（不安全）</li><li>all_squash：不论登入 NFS 的使用者身份为何，他的身份都会被压缩成为匿名使用者，通常也就是 nobody</li></ul><h2 id="启动与挂载"><a href="#启动与挂载" class="headerlink" title="启动与挂载"></a>启动与挂载</h2><p>NFS 服务器启动 nfs 服务：<code>service nfs start</code>后， NFS 客户端即可进行挂载操作：<code>mount : </code>，如<code>mount 192.168.216.128:/home /mnt</code>。客户端卸载 NFS 共享时：<code>umount </code>。</p><p>挂载完成，但是这只是临时挂载，客户端重启后 NFS 挂载就失效了，要设置永久挂载可以编辑文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/fstab </span><br><span class="line">&#123;&#123;NFS服务器地址&#125;&#125;:&#123;&#123;远程共享目录&#125;&#125; &#123;&#123;本地挂载目录&#125;&#125; nfs defaults 0 0</span><br></pre></td></tr></table></figure></p><p>保存配置，执行mount -a 命令</p><blockquote><p>PS：客户端不需启动 nfs 服务，但需要安装 nfs 来支持挂载共享目录。客户端卸载共享目录时需保证当前工作目录不是所卸载的目录。</p></blockquote><h2 id="NFS-的常用命令"><a href="#NFS-的常用命令" class="headerlink" title="NFS 的常用命令"></a>NFS 的常用命令</h2><p>showmount 命令：</p><ul><li>showmount -e：显示 NFS 服务器的输出目录列表</li><li>showmount -d：显示当前主机 NFS 服务器中已经被 NFS 客户机挂载使用的共享目录</li><li>showmount -a：显示当前主机中 NFS 服务器的客户机信息</li><li>showmount -a [主机]：显示指定主机中 NFS 服务器的客户机信息</li></ul><p>exportfs 命令：</p><ul><li>exportfs -rv：使 NFS 服务器重新读取 exports 文件中的设置</li><li>exportfs -auv：停止当前主机中 NFS 服务器的所有目录输出</li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="http://www.swanlinux.net/2013/02/12/linux_nfs/" target="_blank" rel="noopener">Linux 系统中文件共享之 NFS</a></p><p><a href="https://www.cnyunwei.cc/archives/148" target="_blank" rel="noopener">NFS 文件共享配置参数</a></p><hr><ul><li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p></li><li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p></li></ul><h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p><blockquote><p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p></blockquote><blockquote><p>体育&amp;户外用品推荐</p></blockquote><div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/se-notes/Flask-Web工程手册/ch6-配置集群共享文件NFS服务器/../more/ads/amazon.gif" width="100%"></a> </div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#配置集群共享文件-nfs-服务器&quot;&gt;配置集群共享文件 NFS 服务器&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#简介&quot;&gt;简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#安装与配置&quot;&gt;安装与配置&lt;/a&gt;&lt;/li&gt;
      
    
    </summary>
    
      <category term="框架" scheme="https://wnhby.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="python-web应用框架" scheme="https://wnhby.github.io/categories/%E6%A1%86%E6%9E%B6/python-web%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="web开发" scheme="https://wnhby.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="flask" scheme="https://wnhby.github.io/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>ch7-Nginx安装与重写URL-CentOS7</title>
    <link href="https://wnhby.github.io/se-notes/Flask-Web%E5%B7%A5%E7%A8%8B%E6%89%8B%E5%86%8C/ch7-Nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E9%87%8D%E5%86%99URL-CentOS7/"/>
    <id>https://wnhby.github.io/se-notes/Flask-Web工程手册/ch7-Nginx安装与重写URL-CentOS7/</id>
    <published>2019-01-03T13:49:30.000Z</published>
    <updated>2019-02-19T05:17:59.099Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E9%87%8D%E5%86%99urlcentos7">Nginx安装与重写URL（CentOS7）</a><ul><li><a href="#nginx%E5%AE%89%E8%A3%85">Nginx安装</a></li><li><a href="#%E9%87%8D%E5%86%99url">重写URL</a><ul><li><a href="#ads">Ads</a></li></ul></li></ul></li></ul><!-- /TOC --><h1 id="Nginx安装与重写URL（CentOS7）"><a href="#Nginx安装与重写URL（CentOS7）" class="headerlink" title="Nginx安装与重写URL（CentOS7）"></a>Nginx安装与重写URL（CentOS7）</h1><h2 id="Nginx安装"><a href="#Nginx安装" class="headerlink" title="Nginx安装"></a>Nginx安装</h2><p>新建 /etc/yum.repos.d/nginx.repo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[nginx]</span><br><span class="line">name=nginx repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/7/$basearch/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure></p><p>使用命令<code># yum install nginx</code>安装nginx。安装完成后使用命令<code># nginx</code>启动 nginx 。使用<code># nginx -v</code>查看 nginx 版本。并可通过在浏览器里直接访问机器的IP地址可查看 nginx 是否启动成功（<strong>需确保关闭 CentOS 的 SELinux 和防火墙服务</strong>）。</p><h2 id="重写URL"><a href="#重写URL" class="headerlink" title="重写URL"></a>重写URL</h2><p>使用<code># nginx -t</code>命令查看当前 nginx 配置文件状态以及路径。在配置文件中的项 http{} 里可重写URL：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">        listen 80;                  #设置监听端口</span><br><span class="line">        server_name 172.18.216.123; #决定配置哪几台服务器，值可为域名也可为IP地址</span><br><span class="line">        location / &#123;                #对匹配目录&quot;/&quot;进行操作。也可设置为其它的目录</span><br><span class="line">            rewrite / http://www.baidu.com break; #执行URL重写，支持正则表达式</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可在配置文件的 server 块中写，此时是针对该服务器的全局配置。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    rewrite 规则 定向路径 重写类型;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>规则：可以是字符串或者正则来表示想匹配的目标url</li><li>定向路径：表示匹配到规则后要定向的路径，如果规则里有正则，则可以使用 $index 来表示正则里的捕获分组</li><li>重写类型：<ul><li>last ：匹配重写后的URL，再一次对URL重写规则进行匹配。浏览器地址栏URL地址不变</li><li>break；匹配重写URL后终止匹配，直接使用。浏览器地址栏URL地址不变</li><li>redirect：返回302临时重定向，浏览器地址会显示跳转后的URL地址</li><li>permanent：返回301永久重定向，浏览器地址栏会显示跳转后的URL地址</li></ul></li></ul><p>更多具体语法可参见官方文档 <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html" target="_blank" rel="noopener">Rewrite模块</a> 或中文技术博客 <a href="http://www.tuicool.com/articles/qEzMNrI" target="_blank" rel="noopener">Nginx配置URL重写</a>。</p><hr><ul><li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p></li><li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p></li></ul><h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p><blockquote><p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p></blockquote><blockquote><p>体育&amp;户外用品推荐</p></blockquote><div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/se-notes/Flask-Web工程手册/ch7-Nginx安装与重写URL-CentOS7/../more/ads/amazon.gif" width="100%"></a> </div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E9%87%8D%E5%86%99urlcentos7&quot;&gt;Nginx安装与重写URL（CentOS7）&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#n
      
    
    </summary>
    
      <category term="框架" scheme="https://wnhby.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="python-web应用框架" scheme="https://wnhby.github.io/categories/%E6%A1%86%E6%9E%B6/python-web%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="web开发" scheme="https://wnhby.github.io/tags/web%E5%BC%80%E5%8F%91/"/>
    
      <category term="flask" scheme="https://wnhby.github.io/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>JVM基础</title>
    <link href="https://wnhby.github.io/se-notes/Java%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/"/>
    <id>https://wnhby.github.io/se-notes/Java基础/JVM基础/</id>
    <published>2019-01-03T13:49:30.000Z</published>
    <updated>2019-02-19T05:18:45.393Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#jvm基础">JVM基础</a><ul><li><a href="#类加载器classloader">类加载器(classloader)</a><ul><li><a href="#双亲委托机制">双亲委托机制</a></li></ul></li><li><a href="#执行引擎execution-engine">执行引擎(execution engine)</a></li><li><a href="#运行时数据区域jvm-runtime-area">运行时数据区域(JVM Runtime Area)</a></li></ul></li><li><a href="#gc">GC</a><ul><li><a href="#找出需要回收的对象">找出需要回收的对象</a></li><li><a href="#垃圾回收算法">垃圾回收算法</a><ul><li><a href="#标记-清除算法">标记-清除算法</a></li><li><a href="#标记-整理算法">标记-整理算法</a></li><li><a href="#复制算法">复制算法</a></li><li><a href="#分代收集算法结合以上三种算法">分代收集算法（结合以上三种算法）</a></li></ul></li><li><a href="#heap-的组成">heap 的组成</a></li><li><a href="#\对象引用类型">*对象引用类型</a><ul><li><a href="#ads">Ads</a></li></ul></li></ul></li></ul><!-- /TOC --><h1 id="JVM基础"><a href="#JVM基础" class="headerlink" title="JVM基础"></a>JVM基础</h1><p> Java 虚拟机（Java virtual machine，JVM）是运行 Java 程序必不可少的机制。JVM 实现了 Java 最重要的特征：平台无关性。</p><p>原理：编译后的 Java 程序指令并不直接在硬件系统的 CPU 上执行，而是由 JVM 执行。JVM 屏蔽了与具体平台相关的信息，使 Java 语言编译程序只需要生成在 JVM 上运行的目标字节码（.class），就可以在多种平台上不加修改地运行。Java 虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行，由此实现平台无关性。</p><p><img src="https://segmentfault.com/img/bVkZat" alt="JVM模型"></p><p>JVM = 类加载器(classloader) + 执行引擎(execution engine) + 运行时数据区(runtime data area)</p><h2 id="类加载器-classloader"><a href="#类加载器-classloader" class="headerlink" title="类加载器(classloader)"></a>类加载器(classloader)</h2><p>类加载器用于装载 .class 文件到 JVM 中，有两种装载 class 的方式 ：</p><ul><li>隐式：运行过程中，碰到 new 方式生成对象时，隐式调用 classLoader 到 JVM</li><li>显式：通过 Class.forname() 动态加载</li></ul><h3 id="双亲委托机制"><a href="#双亲委托机制" class="headerlink" title="双亲委托机制"></a>双亲委托机制</h3><p>类的加载过程采用<strong>双亲委托机制</strong>，这种机制能更好的保证 Java 平台的安全。</p><p>该模型要求除了顶层的 Bootstrap class loader 启动类加载器外，其余的类加载器都应当有自己的父类加载器。子类加载器和父类加载器不是以继承（Inheritance）的关系来实现，而是通过组合（Composition）关系来复用父加载器的代码。每个类加载器都有自己的命名空间。</p><p>双亲委托机制的工作过程如下：</p><ol><li>当前 classLoader 首先从自己已经加载的类中查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。（每个类加载器都有自己的加载缓存，当一个类被加载了以后就会放入缓存，<br>等下次加载的时候就可以直接返回）</li><li>当前 classLoader 的缓存中没有找到被加载的类的时候，委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到 bootstrap ClassLoader 。（当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回）</li></ol><p>类加载器 classloader 是具有层次结构的，也就是父子关系。其中 Bootstrap 是所有类加载器的父亲。</p><p><img src="https://segmentfault.com/img/bVk0W2" alt="类加载器层次结构"></p><p>使用双亲委托机制的目的在于：</p><ol><li>安全性考虑：为了安全性，避免用户自己编写的类动态替换 Java 的一些核心类，比如 String。</li><li>避免重复加载：JVM 中区分不同类，不仅仅是根据类名。相同的 class 文件被不同的 ClassLoader 加载就是不同的两个类，如果相互转型的话会抛 java.lang.ClassCaseException。</li></ol><h2 id="执行引擎-execution-engine"><a href="#执行引擎-execution-engine" class="headerlink" title="执行引擎(execution engine)"></a>执行引擎(execution engine)</h2><p>执行引擎用于执行字节码或者本地方法。</p><h2 id="运行时数据区域-JVM-Runtime-Area"><a href="#运行时数据区域-JVM-Runtime-Area" class="headerlink" title="运行时数据区域(JVM Runtime Area)"></a>运行时数据区域(JVM Runtime Area)</h2><p>JVM 运行时数据区 (JVM Runtime Area) 是 JVM 在运行期间，其对 JVM 内存空间的划分和分配。JVM 在运行时将数据划分为了多个区域来存储。</p><p>程序员写的 Java 程序都被加载到运行时数据区域中，按不同类别存放在堆（Heap）、方法区（Method Area）、虚拟机栈（VM Stack）、程序计数器（PC）中。</p><p><img src="http://img.blog.csdn.net/20140218172737265?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2hhb2ZhbndlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="Java内存结构"></p><ul><li><p><strong>程序计数器</strong>：线程私有。当前线程所执行的字节码的指令计数器，存储每个线程下一步将执行的 JVM 指令。</p></li><li><p><strong>JVM栈</strong>：线程私有。与线程同时创建，生命周期与线程相同。每个方法被执行的时候都会同时创建一个<strong>栈帧</strong>（Stack Frame）用于存储局部变量、操作数栈等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p></li></ul><p><img src="https://segmentfault.com/img/bVmxl8" alt="JVM栈"></p><ul><li><p><strong>Native 方法栈</strong>：线程私有。类似于 JVM 栈，但虚拟机栈用于为虚拟机执行 java 方法，而本地方法栈则用于为虚拟机执行 native 方法。（native 方法是原生函数，是用 C/C++ 语言实现的，并且被编译成了 DLL，由 java 去调用）</p></li><li><p><strong>Java 堆</strong>：被所有线程共享的存储区域，在虚拟机启动时创建。它是 JVM 用于存储对象实例和数组的区域，Java 中所有通过 new 创建的对象的内存都在此分配。（这些对象被 GC 自动管理，无需也无法显式被销毁）</p><ul><li>内存分配方式：<strong>指针碰撞</strong>（用一个指针指向内存已用区和空闲区的分界点）和<strong>空闲列表</strong>（用一个列表记录哪些内存块可用）。</li><li>指针碰撞的分配方式明显要优于空闲列表的方式，但是使用哪种方式取决于堆内存是否规整，而堆内存是否规整则由使用的垃圾收集算法决定。</li><li>堆在 JVM 是所有线程共享的，因此在其上进行对象内存的分配均需要进行加锁，这也是 new 开销比较大的原因。</li><li>鉴于上面的原因，Sun Hotspot JVM 为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间，这块空间又称为 TLAB。</li></ul></li><li><p><strong>方法区</strong>：被所有线程共享的内存区域，在虚拟机启动时创建，它用于存储已被虚拟机加载的类信息、常量、静态变量等数据。<strong>JVM 用持久代（Permanet Generation）来存放方法区</strong>。</p><ul><li>运行时常量池：方法区的一部分，存放的为类中固定的常量信息、方法和域的引用信息。</li></ul></li></ul><h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><p>垃圾回收机制是由垃圾收集器 Garbage Collection（GC）来实现的，GC 是后台的守护进程。它是一个低优先级进程，但是可以根据内存的使用情况动态的调整它的优先级。因此，它在内存可用量低到一定限度时才会自动运行，从而实现对内存的回收。这就是垃圾回收的时间不确定的原因。</p><p>程序运行期间，所有对象实例存储在运行时数据区域的 heap 中，当一个对象不再被引用（使用），它就需要被收回。在 GC 过程中，这些不再被使用的对象从 heap 中收回，这样就会有内存空间被循环利用。</p><p>由于 GC 要消耗一些资源和时间，Java 在对对象的生命周期特征（eden or survivor）进行分析之后，采用了分代的方式进行对象的收集，以缩短 GC 对应用造成的暂停。</p><p>在垃圾回收器回收内存之前，还需要一些清理工作。<br>因为 GC 只能回收通过 new 申请的内存（在堆上），但是堆上的内存并不完全是通过 new 申请分配的。还有一些本地方法（一般是调用的 C 方法）。这部分特殊内存如果不手动释放，就会导致内存泄露，而 GC 是无法回收这部分内存的。<br>所以需要在 finalize 中用本地方法(native method)如 free 操作等，再使用 gc 方法。显式的 GC 方法是 system.gc() 。</p><h2 id="找出需要回收的对象"><a href="#找出需要回收的对象" class="headerlink" title="找出需要回收的对象"></a>找出需要回收的对象</h2><ul><li>引用计数法：给对象添加一个引用计数器，计数器的值代表着这个对象被引用的次数，当计数器的值为0的时候，就代表没有引用指向这个对象，所以就可以对它进行回收。但无法解决对象循环引用的问题。（即多个对象互相循环引用，但没有其他对象持有这些对象的引用，从而是一个孤立的系统）</li><li>可达性分析：从一些顶点开始，对有向图中的每个顶点进行可达性分析，就可以把不可达的对象找出来。这些起始对象被称为 GC Roots。可以作为 GC Roots 的对象有：栈区中引用的对象、 方法区中静态属性或常量引用的对象。</li></ul><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>找到需要回收的对象后，即可进行回收。JVM 中的 GC 是”自适应”的垃圾回收器，它会根据不同的环境和需要选择不同的处理方式。</p><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>通过可达性分析算法找到可以回收的对象后，对这些对象进行标记，代表它可以被回收。标记完成之后就统一回收所有被标记的对象。但是这种方式会产生大量的内存碎片，导致可用内存不规整，于是分配新的内存时就需要采用空闲列表的方法。如果没有找到足够大的空间，那么就要提前触发下一次垃圾收集。</p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>标记的过程和标记-清除算法一样，但是标记完成之后，让所有存活的对象都向堆内存的一端移动，最后直接清除掉边界以外的内存。这样对内存进行回收之后，内存是规整的，于是可以使用指针碰撞的方式分配新的内存。</p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>标记-清除算法和标记-整理算法都使用先标记的方式，但当对象数量很多时，这种算法的效率并不高。</p><p>复制算法将可用内存分成两个部分，每次只使用其中的一部分，当其中一块用完时，就将仍然存活的对象复制到另外一块上，再把原来的那一块内存清理掉。这样回收的结果同样能得到规整的剩余空间，但是会浪费一部分内存。</p><p>可将新生代划分为三个部分，分别为Eden、Survivor from、Survivor to，大小比例为8：1：1。每次只使用 Eden 和其中的一块 Survivor，回收时将存活的对象复制到另一块 Survivor 中，这样就只有10%的内存被浪费，但是如果存活的对象总大小超过了 Survivor 的大小，那么就把多出的对象放入老年代中。</p><h3 id="分代收集算法（结合以上三种算法）"><a href="#分代收集算法（结合以上三种算法）" class="headerlink" title="分代收集算法（结合以上三种算法）"></a>分代收集算法（结合以上三种算法）</h3><p>把 Java堆分成新生代和老年代，新生代使用复制算法，老年代使用标记-清理或标记-整理算法。这样可以根据各个代自己的特点，选用合适的收集算法，提高内存收集的效率。在新生代中长期存活的对象会逐渐向老年代过渡，新生代中的对象每经历一次 GC，年龄就增加一岁，当年龄超过一定值时，就会被移动到旧生代。</p><h2 id="heap-的组成"><a href="#heap-的组成" class="headerlink" title="heap 的组成"></a>heap 的组成</h2><p>由于 GC 需要消耗一些资源和时间的，Java 在对对象的生命周期特征进行分析后，采用了分代的方式来进行对象的收集，即按照新生代、旧生代的方式来对对象进行收集，以尽可能的缩短 GC 对应用造成的暂停。</p><p>heap 的组成有三区域/世代：(可以理解随着时间，对象实例不断变换 heap 中的等级)</p><ul><li>新生代（Young Generation）<ul><li>Eden Space：任何新进入运行时数据区域的实例都会存放在此</li><li>S0 Suvivor Space：存在时间较长，经过垃圾回收没有被清除的实例，就从Eden 搬到了S0</li><li>S1 Survivor Space：存在时间更长的实例，就从S0 搬到了S1</li></ul></li><li>旧生代（Old Generation/tenured）：存在时间更长的对象，多次 GC 没被清除，就从 S1 搬到了 tenured</li><li>持久代：存放运行时数据区的方法区</li></ul><p><img src="https://segmentfault.com/img/bVkZav" alt="分区"></p><p>Java 对新生代和旧生代使用不同的 GC 算法。新生代做“复制收集”，旧生代做“标记压缩收集”。</p><blockquote><p>PS：搬运工作都由 GC 完成。GC 负责在 heap 中搬运实例，以及收回存储空间。</p></blockquote><h2 id="对象引用类型"><a href="#对象引用类型" class="headerlink" title="*对象引用类型"></a>*对象引用类型</h2><p>JVM 中将对象的引用分为了四种类型，不同的对象引用类型会造成 GC 采用不同的方法进行回收： </p><ol><li>强引用：默认情况下，对象采用的均为强引用。（GC 不会回收）</li><li>软引用：软引用是 Java 中提供的一种比较适合于缓存场景的应用。（只有在内存不够用的情况下才会被GC）</li><li>弱引用：在GC时一定会被GC回收 </li><li>虚引用：在GC时一定会被GC回</li></ol><hr><ul><li><p><a href="/more/donate/index.html"><strong><em><font color="red">我觉得帮助到我了, 支持你一下.</font></em></strong></a><br>   </p></li><li><p><a href="https://www.paypal.me/momodainfo" target="_blank" rel="noopener"><strong><em><font color="red">If you think the article is helpful to you, you can reward me through paypal.</font></em></strong></a></p></li></ul><h3 id="Ads"><a href="#Ads" class="headerlink" title="Ads"></a>Ads</h3><p><em>这是小广告! 如果有需要, 不妨支持一下吧~</em></p><blockquote><p> <a target="_blank" href="https://amazon.cn/gp/search?ie=UTF8&tag=momoda-23&linkCode=ur2&linkId=4a0e4fbec0cfa8dfe540ca999d0bf999&camp=536&creative=3200&index=books&keywords=编程">这些好书您看了吗?</a><img src="//ir-cn.amazon-adsystem.com/e/ir?t=momoda-23&l=ur2&o=28" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;"></p></blockquote><blockquote><p>体育&amp;户外用品推荐</p></blockquote><p><div align="center"> <a href="https://www.amazon.cn/B07HWB88Z5/dp/B07HWB88Z5/ref=as_sl_pc_tf_til?tag=momoda-23&linkCode=w00&linkId=14df5124f2165d9eb3d65252e60ed2cf&creativeASIN=B07HWB88Z5" target="_blank" rel="noopener"><img src="/se-notes/Java基础/JVM基础/../more/ads/amazon.gif" width="100%"></a> </div>收</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#jvm基础&quot;&gt;JVM基础&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#类加载器classloader&quot;&gt;类加载器(classloader)&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#双亲委托机制&quot;&gt;双亲委托机制&lt;/
      
    
    </summary>
    
      <category term="编程语言" scheme="https://wnhby.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="java" scheme="https://wnhby.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/"/>
    
    
      <category term="java语法" scheme="https://wnhby.github.io/tags/java%E8%AF%AD%E6%B3%95/"/>
    
      <category term="java基础" scheme="https://wnhby.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
